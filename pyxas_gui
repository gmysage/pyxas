#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Jan 11 09:07:42 2018

@author: Mingyuan Ge
Email: gmysage@gmail.com, mingyuan@bnl.gov
"""

import sys
import gc
import h5py
import matplotlib as mpl
mpl.use('Qt5Agg')
#mpl.use('qtagg')
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import os
import threading
import time
import textwrap
import json
from multiprocessing import cpu_count


from scipy.ndimage import shift
from scipy.signal import medfilt2d, medfilt
from scipy import ndimage
from pathlib import Path
from skimage import io
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas
from matplotlib.figure import Figure
from copy import deepcopy
from mpl_toolkits.axes_grid1 import make_axes_locatable
import sys

from PyQt5 import QtGui
from PyQt5.QtWidgets import (QMainWindow, QFileDialog, QRadioButton, QApplication,QWidget, QPlainTextEdit,
                                 QLineEdit, QWidget, QPushButton, QLabel, QCheckBox, QGroupBox, QSystemTrayIcon,
                                 QScrollBar, QVBoxLayout, QHBoxLayout, QGridLayout, QTabWidget, QMenu,
                                 QListWidget, QListWidgetItem, QAbstractItemView, QScrollArea, QAction,
                                 QSlider, QComboBox, QButtonGroup, QMessageBox, QSizePolicy)
from PyQt5.QtGui import QIntValidator, QDoubleValidator, QIcon
from PyQt5 import QtCore

import pyxas
import warnings
from tqdm import trange
from multiprocessing import cpu_count


global xanes
global torch_installed

try:
    import torch
    torch_installed = 1
    from pyxas.pyml import *
except:
    torch_installed = 0

class App(QWidget):
    def __init__(self):
        super().__init__()
        self.title = 'pyXAS'
        screen_resolution = QApplication.desktop().screenGeometry()
        width, height = screen_resolution.width(), screen_resolution.height()
        self.width = 1020
        self.height = 800
        self.left = (width - self.width) // 2
        self.top = (height - self.height) // 2
        self.system_cpu = cpu_count()
        self.check_torch_installed()
        self.seg_flag = False
        self.initUI()
        self.bkg_memory_check()
        self.default_layout()
        #self.defaul_layout_ml()


    def closeEvent(self, *args, **kwargs):
        super().closeEvent(*args, **kwargs)
        print('close window')
        plt.close('all')

    def check_torch_installed(self):
        global torch_installed
        self.torch_installed = torch_installed


    def bkg_memory_check(self):
        thread = threading.Thread(target=self.bkg_memory_check_run, args=())
        thread.daemon = True
        thread.start()


    def bkg_memory_check_run(self):
        pass
        '''
        while True:
            PID = os.getpid()
            py = psutil.Process(PID)
            MEM = list(psutil.virtual_memory())
            prog_used_mem = py.memory_info()[0]
            MEM.append(prog_used_mem)
            prog_used = '{:4.1f}'.format(MEM[-1] / 2. ** 30)  # unit in Gb
            tot_mem = '{:4.1f}'.format(MEM[0] / 2. ** 30)
            mem_pecent = '{:2.1f}'.format(100 - MEM[2])
            self.lb_pid_display.setText(str(PID))
            self.lb_mem_prog_used.setText(prog_used + ' / ' + tot_mem + 'Gb')
            self.lb_mem_avail.setText(mem_pecent + ' %')
            if float(mem_pecent) < 10:
                self.lb_mem_avail.setStyleSheet('color: rgb(200, 50, 50);')
            else:
                self.lb_mem_avail.setStyleSheet('color: rgb(0, 0, 0);')
            time.sleep(1)
        '''


    def initUI(self):
        self.setWindowTitle(self.title)

        self.setGeometry(self.left, self.top, self.width, self.height)
        self.font1 = QtGui.QFont('Arial', 11, QtGui.QFont.Bold)
        self.font2 = QtGui.QFont('Arial', 11, QtGui.QFont.Normal)
        self.gui_fpath = __file__
        try:
            self.gui_fpath = os.readlink(self.gui_fpath)
        except:
            pass
        self.fpath = '/'.join(self.gui_fpath.split('/')[:-1])
        path_icon = self.fpath + '/icon.png'
        try:
            self.setWindowIcon(QtGui.QIcon(path_icon))
        except:
            pass
        self.roi_file_id = 0
        self.spectrum_ref = {}
        if self.torch_installed:
            try:
                self.gpu_count = torch.cuda.device_count()
                self.defaul_layout_ml()
            except:
                self.gpu_count = 0
        else:
            self.gpu_count = 0
        self.lb_empty = QLabel()
        grid1 = QGridLayout()
        gpbox_prep = self.layout_GP_prepare()
        gpbox_msg = self.layout_msg()
        gpbox_xanes = self.layout_xanes()

        grid1.addWidget(gpbox_prep, 0, 1)
        grid1.addLayout(gpbox_msg, 1, 1)
        grid1.addWidget(gpbox_xanes, 2, 1)

        layout1 = QVBoxLayout()
        layout1.addLayout(grid1)
        layout1.addWidget(QLabel())

        '''
        gpbox_3D_param_file = self.layout_3D_param_open_filefolder()
        gpbox_3D_msg = self.layout_3D_msg()
        gpbox_3D_fit_param = self.layout_3D_param_fit()

        grid2 = QGridLayout()
        grid2.addWidget(gpbox_3D_param_file, 0, 1)
        grid2.addLayout(gpbox_3D_msg, 1, 1)
        grid2.addLayout(gpbox_3D_fit_param, 2, 1)

        layout2 = QVBoxLayout()
        layout2.addLayout(grid2)
        layout2.addWidget(QLabel())

        '''
        layout2 = self.layout_3D()

        tabs = QTabWidget()
        tab1 = QWidget()
        tab2 = QWidget()

        tab1.setLayout(layout1)
        tab2.setLayout(layout2)

        tabs.addTab(tab1, '2D XANES')
        tabs.addTab(tab2, '3D XANES')
        if self.torch_installed:
            tab3 = QWidget()
            layout3 = self.layout_ml()
            tab3.setLayout(layout3)
            tabs.addTab(tab3, 'ML App.')
        tabs.setFont(self.font1)

        self.layout = QVBoxLayout(self)
        self.layout.addWidget(tabs)

        self.setLayout(self.layout)


    def default_layout(self):
        try:
            del self.img_xanes, self.img_update, self.xanes_2d_fit, self.xanes_fit_cost # self.img_bkg, self.img_bkg_removed, self.img_bkg_update
        except Exception as err:
            print(err)
        default_img = np.zeros([1,500, 500])
        self.refresh(self.seg_flag)
        self.fn_raw_image = ''
        self.save_version = 0
        self.xanes_eng = np.array([0])

        self.img_xanes = deepcopy(default_img)
        self.img_update = deepcopy(default_img)
        self.img_external = deepcopy(default_img)
        self.current_img = deepcopy(default_img)
        self.img_regulation = deepcopy(default_img)
        self.fit_peak_method = 2 # using polynomial curve to find peak position
        self.dataset_used_for_fitting = 0
        self.img_colormix_raw = np.array([])
        self.edge_normalized_flag = 0
        self.mask1 = np.array([1])
        self.mask2 = np.array([1])
        self.mask3 = np.array([1])
        self.mask_auto = np.array([1])
        self.mask = np.array([1])
        self.smart_mask = np.array([1])
        self.smart_mask_comp = 2
        self.smart_mask_current = np.array([1])
        self.img_compress = np.array([1])
        self.img_labels = np.array([1])
        self.img_rm_noise = np.array([1])
        self.roi_spec = np.array([0])
        self.external_spec = np.array([0, 0])
        self.msg = ''
        self.msg_3d = ''
        self.smooth_param = {'flag': 0, 'kernal_size': 3}
        self.shift_list = []
        self.lst_roi.clear()
        self.fit_edge_peak_res = {'method': 'poly'}
        self.roi_spec_dif = ''
        self.lb_eng1.setText('No energy data ...')
        self.data_summary= {}
        self.load_file_successful = 0
        self.pb_mask1.setStyleSheet('color: rgb(0, 0, 0);')
        self.pb_mask2.setStyleSheet('color: rgb(0, 0, 0);')
        self.pb_mask3.setStyleSheet('color: rgb(0, 0, 0);')
        self.pb_smart_mask.setStyleSheet('color: rgb(0, 0, 0);')
        self.save_fit_param_successful = 0
        self.load_fit_param_successful = 0
        self.multi_elem_fit_result = {}
        self.multi_elem_fit_result_roi = {}
        self.multi_elem_fit_roi_success = 0
        self.multi_elem_fitting_method = 'basic'
        self.load_file_multi_elem_batch_successfull = 0
        self.load_file_batch_color_successfull = 0
        self.multi_elem_batch_files = []
        self.dict_comb_xanes = {'img':{}, 'eng':{}}

        try:
            self.eng = self.eng  # for 3D batch fitting
            self.load_eng_successful = 1
        except:
            self.eng = np.array([0, 20])
            self.load_eng_successful = 0

        try:
            self.num_ref = self.num_ref
        except :
            self.num_ref = 0
            print('set num_ref = 0')

        try:
            self.spectrum_ref = self.spectrum_ref
            self.load_reference_successful = 1 # for 3D batch fitting
            print('Use existing Reference Spectrum')
        except:
            print('Need Reference Spectrum')
            self.spectrum_ref = {}



        self.fitting_method = 1
        self.xanes_2d_fit = None
        self.xanes_2d_fit_offset = 0
        self.xanes_fit_cost = 0
        self.img_pre_edge_sub_mean = np.array([1])
        self.elem_label = []
        self.figure = {}

        self.pb_plot_roi.setEnabled(True)
        self.pb_export_roi_fit.setEnabled(False)
        self.pb_colormix.setEnabled(True)
        self.pb_save2d.setEnabled(False)

        self.canvas1.cmax = 1
        self.canvas1.cmin = 0
        self.canvas1.current_img_index = 0
        self.canvas1.mask = np.array([1])
        self.canvas1.rgb_mask = np.array([1])
        self.canvas1.colorbar_on_flag = True
        #self.canvas1.colormap = 'viridis'
        #self.cb_cmap.setCurrentText('viridis')
        self.canvas1.title = []
        self.canvas1.draw_line = False
        self.canvas1.overlay_flag = True
        self.canvas1.x, self.y, = [], []
        self.canvas1.plot_label = ''
        self.canvas1.legend_flag = False
        self.canvas1.roi_list = {}
        self.canvas1.roi_color = {}
        self.canvas1.roi_count = 0
        self.canvas1.show_roi_flag = False
        self.canvas1.current_roi = [0, 0, 0, 0, '0'] # x1, y1, x2, y1, roi_name
        #self.canvas1.color_list = ['red', 'brown', 'orange', 'olive', 'green', 'cyan', 'blue', 'pink', 'purple', 'gray']
        self.canvas1.current_color = 'red'
        self.canvas1.special_info = None

        self.cb1.setCurrentText('Raw image')
        QApplication.processEvents()
        count = self.cb1.count()
        for i in reversed(range(count)):
            self.cb1.removeItem(i)
        count = self.cb_color_channel.count()
        #for i in range(count):
        #    self.cb_color_channel.removeItem(i)
        self.cb_color_channel.clear()
        self.update_canvas_img()

    def defaul_layout_ml(self):
        default_img = np.zeros([1, 500, 500])
        self.ml_img_stack = deepcopy(default_img)
        self.ml_eng = np.array([0])
        self.ml_model_dict = {}
        self.ml_msg = ''
        self.ml_img_path = ''
        self.ml_model_path = f'{self.fpath}/pyxas/pyml/trained_model/pre_traind_model_xanes_denoise.pth'
        self.ml_model_path_default = self.ml_model_path
        self.ml_train_root_dir = ''
        self.ml_train_gt_dir = ''
        self.ml_train_blur_dir = ''
        self.ml_train_eng_dir = ''
        self.ml_spectrum_ref = {}
        self.ml_num_ref = 0
        self.ml_h_loss = None



    def layout_msg(self):
        self.lb_ip = QLabel()
        self.lb_ip.setFont(self.font2)
        self.lb_ip.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_ip.setText('File loaded:')

        self.lb_msg = QLabel()
        self.lb_msg.setFont(self.font1)
        self.lb_msg.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_msg.setText('Message:')

        vbox_msg = QVBoxLayout()
        vbox_msg.addWidget(self.lb_ip)
        vbox_msg.addWidget(self.lb_msg)
        vbox_msg.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_msg


    def gpbox_system_info(self):
        lb_empty1 = QLabel()
        lb_empty1.setFixedWidth(80)
        lb_mem = QLabel()
        lb_mem.setFont(self.font1)
        lb_mem.setText('Memory:')
        lb_mem.setFixedWidth(80)

        lb_mem_prog_used = QLabel()
        lb_mem_prog_used.setFont(self.font2)
        lb_mem_prog_used.setText('Prog. used:')
        lb_mem_prog_used.setFixedWidth(80)

        lb_mem_avail = QLabel()
        lb_mem_avail.setFont(self.font2)
        lb_mem_avail.setText('Available:')
        lb_mem_avail.setFixedWidth(80)

        self.lb_mem_avail = QLabel()
        self.lb_mem_avail.setFont(self.font2)
        self.lb_mem_avail.setFixedWidth(60)

        self.lb_mem_prog_used = QLabel()
        self.lb_mem_prog_used.setFont(self.font2)
        self.lb_mem_prog_used.setFixedWidth(100)

        lb_pid = QLabel()
        lb_pid.setFont(self.font1)
        lb_pid.setText('PID:')
        lb_pid.setFixedWidth(80)

        self.lb_pid_display = QLabel()
        self.lb_pid_display.setFont(self.font2)
        self.lb_pid_display.setFixedWidth(80)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(lb_pid)
        hbox1.addWidget(self.lb_pid_display)
        hbox1.setAlignment(QtCore.Qt.AlignLeft)

        hbox2 = QHBoxLayout()
        hbox2.addWidget(lb_mem)
        hbox2.addWidget(lb_mem_prog_used)
        hbox2.addWidget(self.lb_mem_prog_used)

        hbox2.setAlignment(QtCore.Qt.AlignLeft)

        hbox3 = QHBoxLayout()
        hbox3.addWidget(lb_empty1)
        hbox3.addWidget(lb_mem_avail)
        hbox3.addWidget(self.lb_mem_avail)
        hbox3.setAlignment(QtCore.Qt.AlignLeft)

        vbox = QVBoxLayout()
        vbox.addLayout(hbox1)
        vbox.addLayout(hbox2)
        vbox.addLayout(hbox3)
        vbox.setAlignment(QtCore.Qt.AlignTop)
        return vbox


    def layout_GP_prepare(self):
        lb_empty = QLabel()
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(10)
        lb_empty3 = QLabel()
        lb_empty3.setFixedWidth(100)
        lb_empty4 = QLabel()
        lb_empty4.setFixedWidth(40)
        lb_empty5 = QLabel()
        lb_empty5.setFixedWidth(277)

        gpbox = QGroupBox('Load image')
        gpbox.setFont(self.font1)

        lb_ld = QLabel()
        lb_ld.setFont(self.font2)
        lb_ld.setText('Image file:')
        lb_ld.setFixedWidth(100)

        lb_ld_eng = QLabel()
        lb_ld_eng.setFont(self.font2)
        lb_ld_eng.setText('Energy file:')
        lb_ld_eng.setFixedWidth(100)

        self.pb_ld = QPushButton('Load image')
        self.pb_ld.setToolTip('image type: .hdf, .tiff')
        self.pb_ld.setFont(self.font2)
        self.pb_ld.clicked.connect(self.load_image)
        self.pb_ld.setFixedWidth(140)
        self.pb_ld.setFixedWidth(140)

        self.pb_ld_eng = QPushButton('Load energy')
        self.pb_ld_eng.setToolTip('File: .txt')
        self.pb_ld_eng.setFont(self.font2)
        self.pb_ld_eng.clicked.connect(self.load_energy)
        self.pb_ld_eng.setFixedWidth(140)

        lb_eng = QLabel()
        lb_eng.setFont(self.font2)
        lb_eng.setText('XANES energy:')
        lb_eng.setFixedWidth(120)

        self.lb_eng1 = QLabel()
        self.lb_eng1.setFont(self.font2)
        self.lb_eng1.setText('No energy data ...')
        self.lb_eng1.setFixedWidth(400)

        self.lb_eng2 = QLabel()
        self.lb_eng2.setFont(self.font2)
        self.lb_eng2.setText('Manual input  (python command):')
        self.lb_eng2.setFixedWidth(245)

        self.tx_eng = QLineEdit()
        self.tx_eng.setFixedWidth(285)
        self.tx_eng.setFont(self.font2)
        # self.tx_eng.setVisible(False)

        self.pb_eng = QPushButton('Execute')
        self.pb_eng.setFont(self.font2)
        self.pb_eng.clicked.connect(self.manu_energy_input)
        self.pb_eng.setFixedWidth(140)

        self.pb_fiji = QPushButton('ImageJ')
        self.pb_fiji.setFont(self.font2)
        self.pb_fiji.clicked.connect(self.open_imagej)
        self.pb_fiji.setFixedWidth(80)

        self.pb_closeImg = QPushButton('Close Figure')
        self.pb_closeImg.setFont(self.font2)
        self.pb_closeImg.clicked.connect(self.close_all_figures)
        self.pb_closeImg.setFixedWidth(140)

        lb_mod = QLabel()
        lb_mod.setFont(self.font2)
        lb_mod.setText('Image mode:')
        lb_mod.setFixedWidth(100)

        # radio button for loading image
        self.file_group = QButtonGroup()
        self.file_group.setExclusive(True)
        self.rd_hdf = QRadioButton('hdf')
        self.rd_hdf.setFixedWidth(60)
        self.rd_hdf.setChecked(True)
        self.rd_hdf.toggled.connect(self.select_file)

        self.rd_tif = QRadioButton('tif')
        self.rd_tif.setFixedWidth(60)
        self.rd_tif.toggled.connect(self.select_file)

        self.file_group.addButton(self.rd_hdf)
        self.file_group.addButton(self.rd_tif)
        self.file_group_eng = QButtonGroup()
        self.file_group_eng.setExclusive(True)

        self.rd_hdf_eng = QRadioButton('hdf')
        self.rd_hdf_eng.setFixedWidth(60)
        self.rd_hdf_eng.setChecked(True)
        self.rd_hdf_eng.toggled.connect(self.select_file)

        self.rd_txt_eng = QRadioButton('txt')
        self.rd_txt_eng.setFixedWidth(60)
        self.rd_txt_eng.toggled.connect(self.select_file)
        self.file_group_eng.addButton(self.rd_hdf_eng)
        self.file_group_eng.addButton(self.rd_txt_eng)

        lb_hdf_xanes = QLabel()
        lb_hdf_xanes.setFont(self.font2)
        lb_hdf_xanes.setText('Dataset for XANES:')
        lb_hdf_xanes.setFixedWidth(160)

        lb_hdf_eng = QLabel()
        lb_hdf_eng.setFont(self.font2)
        lb_hdf_eng.setText('Dataset for Energy:')
        lb_hdf_eng.setFixedWidth(160)

        self.chkbox_white_field_corr = QCheckBox('White field corrected')
        self.chkbox_white_field_corr.setFont(self.font2)
        self.chkbox_white_field_corr.setFixedWidth(172)
        self.chkbox_white_field_corr.setChecked(True)
        self.chkbox_white_field_corr.stateChanged.connect(self.check_white_field_normed)

        lb_hdf_bkg = QLabel()
        lb_hdf_bkg.setFont(self.font2)
        lb_hdf_bkg.setText('Dataset for white field:')
        lb_hdf_bkg.setFixedWidth(160)

        lb_hdf_dark = QLabel()
        lb_hdf_dark.setFont(self.font2)
        lb_hdf_dark.setText('Dataset for dark field:')
        lb_hdf_dark.setFixedWidth(160)

        lb_db_xanes = QLabel()
        lb_db_xanes.setFont(self.font2)
        lb_db_xanes.setText('Scan id:')
        lb_db_xanes.setFixedWidth(60)

        self.tx_db_xanes = QLineEdit()
        self.tx_db_xanes.setText('-1')
        self.tx_db_xanes.setFixedWidth(85)
        self.tx_db_xanes.setFont(self.font2)

        self.tx_hdf_xanes = QLineEdit()
        self.tx_hdf_xanes.setText('img_xanes')
        self.tx_hdf_xanes.setFixedWidth(85)
        self.tx_hdf_xanes.setFont(self.font2)

        self.tx_hdf_xanes_bkg = QLineEdit()
        self.tx_hdf_xanes_bkg.setText('img_bkg')
        self.tx_hdf_xanes_bkg.setFixedWidth(85)
        self.tx_hdf_xanes_bkg.setDisabled(True)
        self.tx_hdf_xanes_bkg.setFont(self.font2)

        self.tx_hdf_xanes_dark = QLineEdit()
        self.tx_hdf_xanes_dark.setText('img_dark')
        self.tx_hdf_xanes_dark.setFixedWidth(85)
        self.tx_hdf_xanes_dark.setDisabled(True)
        self.tx_hdf_xanes_dark.setFont(self.font2)

        self.tx_hdf_eng = QLineEdit()
        self.tx_hdf_eng.setText('X_eng')
        self.tx_hdf_eng.setFixedWidth(85)
        self.tx_hdf_eng.setFont(self.font2)

        self.type_group = QButtonGroup()
        self.type_group.setExclusive(True)
        self.rd_absp = QRadioButton('Absorption')
        self.rd_absp.setFont(self.font2)
        self.rd_absp.setFixedWidth(100)
        self.rd_absp.setChecked(True)
        self.rd_flrc = QRadioButton('Fluorescence')
        self.rd_flrc.setFont(self.font2)
        self.rd_flrc.setFixedWidth(120)
        self.rd_flrc.setChecked(False)
        self.type_group.addButton(self.rd_absp)
        self.type_group.addButton(self.rd_flrc)

        lb_fp = QLabel()
        lb_fp.setFont(self.font2)
        lb_fp.setText('')
        lb_fp.setFixedWidth(100)

        self.pb_bin = QPushButton('XANES Binning')
        self.pb_bin.setFont(self.font2)
        self.pb_bin.clicked.connect(self.bin_image)
        self.pb_bin.setEnabled(True)
        self.pb_bin.setFixedWidth(140)

        self.cb_bin = QComboBox()
        self.cb_bin.setFont(self.font2)
        self.cb_bin.addItem('2 x 2')
        self.cb_bin.addItem('4 x 4')
        self.cb_bin.setFixedWidth(70)

        self.tx_bin = QLineEdit()
        self.tx_bin.setText('X_eng')
        self.tx_bin.setFixedWidth(85)
        self.tx_bin.setFont(self.font2)

        self.pb_reverse_image_order = QPushButton('Reverse stack')
        self.pb_reverse_image_order.setFont(self.font2)
        self.pb_reverse_image_order.setFixedWidth(120)
        self.pb_reverse_image_order.setChecked(False)
        self.pb_reverse_image_order.clicked.connect(self.reverse_img_order)

        hbox_bin = QHBoxLayout()
        hbox_bin.addWidget(self.pb_bin)
        hbox_bin.addWidget(self.cb_bin)
        hbox_bin.addWidget(self.pb_reverse_image_order)
        hbox_bin.setAlignment(QtCore.Qt.AlignLeft)

        # gpbox_sys = self.gpbox_system_info()

        hbox1 = QHBoxLayout()
        hbox1.addWidget(lb_ld)
        hbox1.addWidget(self.rd_tif)
        hbox1.addWidget(self.rd_hdf)
        hbox1.addWidget(lb_empty4)
        hbox1.addWidget(lb_hdf_xanes)
        hbox1.addWidget(self.tx_hdf_xanes)
        hbox1.addWidget(self.pb_ld)
        hbox1.addLayout(hbox_bin)
        hbox1.addWidget(lb_empty)
        hbox1.setAlignment(QtCore.Qt.AlignLeft)

        hbox1_ext = QHBoxLayout()
        hbox1_ext.addWidget(lb_empty3)
        hbox1_ext.addWidget(self.chkbox_white_field_corr)
        hbox1_ext.addWidget(lb_hdf_bkg)
        hbox1_ext.addWidget(self.tx_hdf_xanes_bkg)


        #hbox1_ext.addWidget(lb_hdf_dark)
        #hbox1_ext.addWidget(self.tx_hdf_xanes_dark)
        hbox1_ext.addWidget(lb_empty)
        hbox1_ext.setAlignment(QtCore.Qt.AlignLeft)

        hbox1_ext2 = QHBoxLayout()
        hbox1_ext2.addWidget(lb_empty5)
        hbox1_ext2.addWidget(lb_hdf_dark)
        hbox1_ext2.addWidget(self.tx_hdf_xanes_dark)
        hbox1_ext2.addWidget(lb_empty)
        hbox1_ext2.setAlignment(QtCore.Qt.AlignLeft)

        # load fitted file
        self.pb_ld_fitted = QPushButton('Load Fitted')
        self.pb_ld_fitted.setToolTip('File: .h5')
        self.pb_ld_fitted.setFont(self.font2)
        self.pb_ld_fitted.clicked.connect(self.load_fitted_file)
        self.pb_ld_fitted.setFixedWidth(140)


        # databroker
        hbox2 = QHBoxLayout()
        hbox2.addWidget(lb_empty3)
        hbox2.addWidget(lb_empty2)
        hbox2.addWidget(self.pb_ld)
        hbox2.addWidget(self.pb_ld_eng)
        hbox2.addWidget(lb_empty)
        hbox2.setAlignment(QtCore.Qt.AlignLeft)

        hbox3 = QHBoxLayout()
        hbox3.addWidget(lb_ld_eng)
        hbox3.addWidget(self.rd_txt_eng)
        hbox3.addWidget(self.rd_hdf_eng)
        hbox3.addWidget(lb_empty4)
        hbox3.addWidget(lb_hdf_eng)
        hbox3.addWidget(self.tx_hdf_eng)
        hbox3.addWidget(self.pb_ld_eng)
        #hbox3.addWidget(self.pb_ld_fitted)
        hbox3.addWidget(lb_empty)
        hbox3.setAlignment(QtCore.Qt.AlignLeft)

        # XANES energy: no energy data
        hbox_eng = QHBoxLayout()
        hbox_eng.addWidget(lb_eng)
        hbox_eng.addWidget(self.lb_eng1)
        hbox_eng.setAlignment(QtCore.Qt.AlignLeft)

        hbox_manul_input = QHBoxLayout()
        hbox_manul_input.addWidget(self.lb_eng2)
        hbox_manul_input.addWidget(self.tx_eng)
        hbox_manul_input.addWidget(self.pb_eng)
        #hbox_manul_input.addWidget(self.pb_fiji)
        hbox_manul_input.addWidget(self.pb_closeImg)
        hbox_manul_input.setAlignment(QtCore.Qt.AlignLeft)

        vbox = QVBoxLayout()
        vbox.addLayout(hbox1)
        vbox.addLayout(hbox1_ext)
        vbox.addLayout(hbox1_ext2)
        vbox.addLayout(hbox3)
        vbox.addLayout(hbox_eng)
        vbox.addLayout(hbox_manul_input)
        vbox.setAlignment(QtCore.Qt.AlignLeft)

        hbox_tot = QHBoxLayout()
        hbox_tot.addLayout(vbox)
        # hbox_tot.addLayout(gpbox_sys)
        hbox_tot.addWidget(lb_empty)
        hbox_tot.setAlignment(QtCore.Qt.AlignLeft)

        gpbox.setLayout(hbox_tot)
        return gpbox


    def layout_xanes(self):
        lb_empty = QLabel()
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(5)

        h = 600
        w = 450

        gpbox = QGroupBox('XANES fitting')
        gpbox.setFont(self.font1)

        tabs = QTabWidget()
        tab1 = QWidget()
        tab2 = QWidget()
        tab3 = QWidget()
        tab4 = QWidget()
        tab5 = QWidget()
        tab6 = QWidget()
        tab7 = QWidget()

        lay1 = QVBoxLayout()
        lay2 = QVBoxLayout()
        lay3 = QVBoxLayout()
        lay4 = QVBoxLayout()
        lay5 = QVBoxLayout()
        lay6 = QVBoxLayout()
        lay7 = QVBoxLayout()

        scroll1 = QScrollArea()
        scroll1.setWidgetResizable(True)
        scroll1.setFixedHeight(h)
        scroll1.setFixedWidth(w)

        scroll2 = QScrollArea()
        scroll2.setWidgetResizable(True)
        scroll2.setFixedHeight(h)
        scroll2.setFixedWidth(w)

        scroll3 = QScrollArea()
        scroll3.setWidgetResizable(True)
        scroll3.setFixedHeight(h)
        scroll3.setFixedWidth(w)

        scroll4 = QScrollArea()
        scroll4.setWidgetResizable(True)
        scroll4.setFixedHeight(h)
        scroll4.setFixedWidth(w)

        scroll5 = QScrollArea()
        scroll5.setWidgetResizable(True)
        scroll5.setFixedHeight(h)
        scroll5.setFixedWidth(w)

        scroll6 = QScrollArea()
        scroll6.setWidgetResizable(True)
        scroll6.setFixedHeight(h)
        scroll6.setFixedWidth(w)

        scroll7 = QScrollArea()
        scroll7.setWidgetResizable(True)
        scroll7.setFixedHeight(h)
        scroll7.setFixedWidth(w)

        xanes_prep_layout = self.layout_xanes_prep()
        xanes_roi_layout = self.layout_plot_spec
        xanes_roi_norm_layout = self.layout_roi_normalization()
        xanes_fit2d_layout = self.layout_fit2d()
        img_tools_mask_layout = self.layout_img_tools_mask()
        img_tools_colormix_layout = self.layout_colormix()
        canvas_layout = self.layout_canvas()
        analysis_layout = self.layout_analysis()
        multi_elem_layout = self.layout_multi_elem()

        vbox_lay1 = QVBoxLayout()
        vbox_lay2 = QVBoxLayout()
        vbox_lay3 = QVBoxLayout()
        vbox_lay4 = QVBoxLayout()
        vbox_lay5 = QVBoxLayout()
        vbox_lay6 = QVBoxLayout()
        vbox_lay7 = QVBoxLayout()

        vbox_lay1.addLayout(xanes_prep_layout)
        vbox_lay1.setAlignment(QtCore.Qt.AlignTop)
        vbox_lay1.addLayout(xanes_roi_layout)

        vbox_lay2.addLayout(xanes_roi_norm_layout)
        vbox_lay2.setAlignment(QtCore.Qt.AlignTop)

        vbox_lay3.addLayout(xanes_fit2d_layout)
        vbox_lay3.setAlignment(QtCore.Qt.AlignTop)

        vbox_lay4.addLayout(img_tools_mask_layout)
        vbox_lay4.setAlignment(QtCore.Qt.AlignTop)

        vbox_lay5.addLayout(img_tools_colormix_layout)
        vbox_lay5.setAlignment(QtCore.Qt.AlignTop)

        vbox_lay6.addLayout(analysis_layout)
        vbox_lay6.setAlignment(QtCore.Qt.AlignTop)

        vbox_lay7.addLayout(multi_elem_layout)
        vbox_lay7.setAlignment(QtCore.Qt.AlignTop)

        gp_box1 = QGroupBox()
        gp_box2 = QGroupBox()
        gp_box3 = QGroupBox()
        gp_box4 = QGroupBox()
        gp_box5 = QGroupBox()
        gp_box6 = QGroupBox()
        gp_box7 = QGroupBox()

        gp_box1.setLayout(vbox_lay1)
        gp_box2.setLayout(vbox_lay2)
        gp_box3.setLayout(vbox_lay3)
        gp_box4.setLayout(vbox_lay4)
        gp_box5.setLayout(vbox_lay5)
        gp_box6.setLayout(vbox_lay6)
        gp_box7.setLayout(vbox_lay7)

        scroll1.setWidget(gp_box1)
        scroll2.setWidget(gp_box2)
        scroll3.setWidget(gp_box3)
        scroll4.setWidget(gp_box4)
        scroll5.setWidget(gp_box5)
        scroll6.setWidget(gp_box6)
        scroll7.setWidget(gp_box7)

        lay1.addWidget(scroll1)
        lay2.addWidget(scroll2)
        lay3.addWidget(scroll3)
        lay4.addWidget(scroll4)
        lay5.addWidget(scroll5)
        lay6.addWidget(scroll6)
        lay7.addWidget(scroll7)

        tab1.setLayout(lay1)
        tab2.setLayout(lay2)
        tab3.setLayout(lay3)
        tab4.setLayout(lay4)
        tab5.setLayout(lay5)
        tab6.setLayout(lay6)
        tab7.setLayout(lay7)

        tabs.addTab(tab1, 'Prep.')
        tabs.addTab(tab2, 'Norm.')
        tabs.addTab(tab3, '2D XANES')
        tabs.addTab(tab4, 'Mask')
        tabs.addTab(tab5, 'Colormix')
        tabs.addTab(tab6, 'Others')
        tabs.addTab(tab7, 'Multi Elem')

        hbox = QHBoxLayout()
        hbox.addWidget(tabs)
        hbox.addLayout(canvas_layout)
        hbox.setAlignment(QtCore.Qt.AlignLeft)
        gpbox.setLayout(hbox)
        return gpbox

    @property
    def layout_plot_spec(self):
        lb_empty = QLabel()
        lb_empty01 = QLabel()
        lb_empty02 = QLabel()
        lb_empty03 = QLabel()
        lb_empty04 = QLabel()
        w = 100

        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(10)
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(105)
        lb_roi = QLabel()
        lb_roi.setFont(self.font1)
        lb_roi.setText('ROI for Spec.')
        lb_roi.setFixedWidth(100)

        lb_info = QLabel()
        lb_info.setFont(self.font2)
        lb_info.setStyleSheet('color: rgb(200, 50, 50);')
        lb_info.setText('Spectrum calc. based on current image stack')

        '''
        lb_roi_x1 = QLabel()
        lb_roi_x1.setText('Top-left  x:')
        lb_roi_x1.setFont(self.font2)
        lb_roi_x1.setFixedWidth(80)

        lb_roi_y1 = QLabel()
        lb_roi_y1.setText('y:')
        lb_roi_y1.setFont(self.font2)
        lb_roi_y1.setFixedWidth(20)

        lb_roi_x2 = QLabel()
        lb_roi_x2.setText('Bot-right x:')
        lb_roi_x2.setFont(self.font2)
        lb_roi_x2.setFixedWidth(80)

        lb_roi_y2 = QLabel()
        lb_roi_y2.setText('y:')
        lb_roi_y2.setFont(self.font2)
        lb_roi_y2.setFixedWidth(20)

        self.tx_roi_x1 = QLineEdit()
        self.tx_roi_x1.setText('0')
        self.tx_roi_x1.setFont(self.font2)
        self.tx_roi_x1.setFixedWidth(50)

        self.tx_roi_y1 = QLineEdit()
        self.tx_roi_y1.setText('0')
        self.tx_roi_y1.setFont(self.font2)
        self.tx_roi_y1.setFixedWidth(50)

        self.tx_roi_x2 = QLineEdit()
        self.tx_roi_x2.setText('1')
        self.tx_roi_x2.setFont(self.font2)
        self.tx_roi_x2.setFixedWidth(50)

        self.tx_roi_y2 = QLineEdit()
        self.tx_roi_y2.setText('1')
        self.tx_roi_y2.setFont(self.font2)
        self.tx_roi_y2.setFixedWidth(50)
        '''
        self.pb_roi_draw = QPushButton('Draw ROI')
        self.pb_roi_draw.setFont(self.font2)
        self.pb_roi_draw.clicked.connect(self.draw_roi)
        self.pb_roi_draw.setFixedWidth(w)

        self.pb_roi_plot = QPushButton('Plot Spec.')
        self.pb_roi_plot.setFont(self.font1)
        self.pb_roi_plot.clicked.connect(self.plot_spectrum)
        self.pb_roi_plot.setFixedWidth(w)

        self.pb_roi_hide = QPushButton('Hide ROI')
        self.pb_roi_hide.setFont(self.font2)
        self.pb_roi_hide.clicked.connect(self.hide_roi)
        self.pb_roi_hide.setFixedWidth(w)

        self.pb_roi_show = QPushButton('Show ROI')
        self.pb_roi_show.setFont(self.font2)
        self.pb_roi_show.clicked.connect(self.show_roi)
        self.pb_roi_show.setFixedWidth(w)

        self.pb_roi_reset = QPushButton('Reset ROI')
        self.pb_roi_reset.setFont(self.font2)
        self.pb_roi_reset.clicked.connect(self.reset_roi)
        self.pb_roi_reset.setFixedWidth(w)

        self.pb_roi_export = QPushButton('Export Spec.')
        self.pb_roi_export.setFont(self.font2)
        self.pb_roi_export.clicked.connect(self.export_spectrum)
        self.pb_roi_export.setFixedWidth(w)

        self.pb_eval_glitch = QPushButton('Eval. Glitch')
        self.pb_eval_glitch.setFont(self.font2)
        self.pb_eval_glitch.clicked.connect(self.evaluate_glitch)
        self.pb_eval_glitch.setFixedWidth(w)

        self.pb_rm_glitch = QPushButton('Rmv. Glitch')
        self.pb_rm_glitch.setFont(self.font2)
        self.pb_rm_glitch.clicked.connect(self.remove_glitch)
        self.pb_rm_glitch.setFixedWidth(w)

        lb_glitch_thresh = QLabel()
        lb_glitch_thresh.setFont(self.font2)
        lb_glitch_thresh.setText('  Glitch threshold: ')
        lb_glitch_thresh.setFixedWidth(145)

        self.tx_glitch_thresh = QLineEdit(self)
        self.tx_glitch_thresh.setFont(self.font2)
        self.tx_glitch_thresh.setText('<0.8')
        self.tx_glitch_thresh.setFixedWidth(50)

        lb_file_index = QLabel()
        lb_file_index.setFont(self.font2)
        lb_file_index.setText('  File index for export:')
        lb_file_index.setFixedWidth(145)

        self.tx_file_index = QLineEdit()
        self.tx_file_index.setFixedWidth(50)
        self.tx_file_index.setFont(self.font2)
        self.tx_file_index.setText(str(self.roi_file_id))

        self.lst_roi = QListWidget()
        self.lst_roi.setFont(self.font2)
        self.lst_roi.setSelectionMode(QAbstractItemView.MultiSelection)
        self.lst_roi.setFixedWidth(90)
        self.lst_roi.setFixedHeight(170)

        lb_lst_roi = QLabel()
        lb_lst_roi.setFont(self.font2)
        lb_lst_roi.setText('ROI list:')
        lb_lst_roi.setFixedWidth(80)
        lb_lst_roi.setFixedHeight(28)

        self.pb_roi_save = QPushButton('Save ROI')
        self.pb_roi_save.setFont(self.font2)
        self.pb_roi_save.clicked.connect(self.save_roi)
        self.pb_roi_save.setFixedWidth(w)

        self.pb_roi_load = QPushButton('Load ROI')
        self.pb_roi_load.setFont(self.font2)
        self.pb_roi_load.clicked.connect(self.load_roi)
        self.pb_roi_load.setFixedWidth(w)

        self.pb_roi_load_last = QPushButton('Load last')
        self.pb_roi_load_last.setFont(self.font2)
        self.pb_roi_load_last.clicked.connect(self.load_roi_last)
        self.pb_roi_load_last.setFixedWidth(w)

        self.chkbox_multi_selec = QCheckBox('Multi selec')
        self.chkbox_multi_selec.setFont(self.font2)
        self.chkbox_multi_selec.setFixedWidth(w)
        self.chkbox_multi_selec.setChecked(True)
        self.chkbox_multi_selec.stateChanged.connect(self.enable_multi_selection)

        self.pb_roi_sel_all = QPushButton('Select all')
        self.pb_roi_sel_all.setFixedWidth(w)
        self.pb_roi_sel_all.setFont(self.font2)
        self.pb_roi_sel_all.clicked.connect(self.roi_selection_all)

        self.pb_roi_mean_val = QPushButton('ROI average')
        self.pb_roi_mean_val.setFixedWidth(w)
        self.pb_roi_mean_val.setFont(self.font2)
        self.pb_roi_mean_val.clicked.connect(self.get_roi_average)

        # crop image
        lb_crop = QLabel()
        lb_crop.setText('Crop image')
        lb_crop.setFont(self.font1)
        lb_crop.setFixedWidth(100)

        lb_crop_cen_x = QLabel()
        lb_crop_cen_x.setText('X center:')
        lb_crop_cen_x.setFont(self.font2)
        lb_crop_cen_x.setFixedWidth(80)

        lb_crop_cen_y = QLabel()
        lb_crop_cen_y.setText('Y center:')
        lb_crop_cen_y.setFont(self.font2)
        lb_crop_cen_y.setFixedWidth(80)

        lb_crop_size_x = QLabel()
        lb_crop_size_x.setText('  X length:')
        lb_crop_size_x.setFont(self.font2)
        lb_crop_size_x.setFixedWidth(80)

        lb_crop_size_y = QLabel()
        lb_crop_size_y.setText('  Y length:')
        lb_crop_size_y.setFont(self.font2)
        lb_crop_size_y.setFixedWidth(80)

        self.tx_crop_cen_x = QLineEdit()
        self.tx_crop_cen_x.setText('0')
        self.tx_crop_cen_x.setFont(self.font2)
        self.tx_crop_cen_x.setFixedWidth(50)

        self.tx_crop_cen_y = QLineEdit()
        self.tx_crop_cen_y.setText('0')
        self.tx_crop_cen_y.setFont(self.font2)
        self.tx_crop_cen_y.setFixedWidth(50)

        self.tx_crop_size_x = QLineEdit()
        self.tx_crop_size_x.setText('0')
        self.tx_crop_size_x.setFont(self.font2)
        self.tx_crop_size_x.setFixedWidth(50)

        self.tx_crop_size_y = QLineEdit()
        self.tx_crop_size_y.setText('0')
        self.tx_crop_size_y.setFont(self.font2)
        self.tx_crop_size_y.setFixedWidth(50)

        self.pb_crop_display = QPushButton('Display')
        self.pb_crop_display.setFont(self.font2)
        self.pb_crop_display.setFixedWidth(w)
        self.pb_crop_display.clicked.connect(lambda: self.crop_roi_display(self.canvas1))

        self.pb_crop_exec = QPushButton('Crop image')
        self.pb_crop_exec.setFont(self.font2)
        self.pb_crop_exec.setFixedWidth(w)
        self.pb_crop_exec.clicked.connect(lambda:self.crop_roi(self.canvas1))

        hbox_crop_x = QHBoxLayout()
        hbox_crop_x.addWidget(lb_crop_cen_x)
        hbox_crop_x.addWidget(self.tx_crop_cen_x)
        hbox_crop_x.addWidget(lb_crop_size_x)
        hbox_crop_x.addWidget(self.tx_crop_size_x)
        hbox_crop_x.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_crop_y = QHBoxLayout()
        hbox_crop_y.addWidget(lb_crop_cen_y)
        hbox_crop_y.addWidget(self.tx_crop_cen_y)
        hbox_crop_y.addWidget(lb_crop_size_y)
        hbox_crop_y.addWidget(self.tx_crop_size_y)
        hbox_crop_y.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_crop_exec = QHBoxLayout()
        hbox_crop_exec.addWidget(self.pb_crop_display)
        hbox_crop_exec.addWidget(self.pb_crop_exec)
        hbox_crop_exec.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_crop = QVBoxLayout()
        vbox_crop.addWidget(lb_crop)
        vbox_crop.addLayout(hbox_crop_x)
        vbox_crop.addLayout(hbox_crop_y)
        vbox_crop.addLayout(hbox_crop_exec)
        vbox_crop.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_roi_save_load = QVBoxLayout()
        vbox_roi_save_load.addWidget(self.pb_roi_save)
        vbox_roi_save_load.addWidget(self.pb_roi_load)
        vbox_roi_save_load.addWidget(self.pb_roi_load_last)
        vbox_roi_save_load.addWidget(lb_empty1)
        vbox_roi_save_load.addWidget(self.chkbox_multi_selec)
        vbox_roi_save_load.addWidget(self.pb_roi_sel_all)
        vbox_roi_save_load.setAlignment(QtCore.Qt.AlignTop)

        hbox_roi_list_save_load = QHBoxLayout()
        hbox_roi_list_save_load.addWidget(self.lst_roi)
        hbox_roi_list_save_load.addLayout(vbox_roi_save_load)
        hbox_roi_list_save_load.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_roi_list = QVBoxLayout()
        vbox_roi_list.addWidget(lb_lst_roi)
        vbox_roi_list.addLayout(hbox_roi_list_save_load)
        vbox_roi_list.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_roi_button1 = QHBoxLayout()
        hbox_roi_button1.addWidget(self.pb_roi_draw)
        hbox_roi_button1.addWidget(self.pb_roi_reset)
        hbox_roi_button1.setAlignment(QtCore.Qt.AlignLeft)

        hbox_roi_button2 = QHBoxLayout()
        hbox_roi_button2.addWidget(self.pb_roi_show)
        hbox_roi_button2.addWidget(self.pb_roi_hide)
        hbox_roi_button2.setAlignment(QtCore.Qt.AlignLeft)

        '''
        hbox_roi_button3 = QHBoxLayout()
        hbox_roi_button3.addWidget(self.pb_roi_save)
        hbox_roi_button3.addWidget(self.pb_roi_load)
        hbox_roi_button3.setAlignment(QtCore.Qt.AlignLeft)

        hbox_roi_button31 = QHBoxLayout()
        hbox_roi_button31.addWidget(lb_empty2)
        hbox_roi_button31.addWidget(self.pb_roi_load_last)
        hbox_roi_button31.setAlignment(QtCore.Qt.AlignLeft)
        '''
        hbox_roi_button4 = QHBoxLayout()
        hbox_roi_button4.addWidget(self.pb_roi_plot)
        hbox_roi_button4.addWidget(self.pb_roi_export)
        hbox_roi_button4.setAlignment(QtCore.Qt.AlignLeft)

        hbox_roi_button5 = QHBoxLayout()
        hbox_roi_button5.addWidget(self.pb_eval_glitch)
        hbox_roi_button5.addWidget(self.pb_rm_glitch)
        hbox_roi_button5.setAlignment(QtCore.Qt.AlignLeft)

        hbox_roi_button6 = QHBoxLayout()
        hbox_roi_button6.addWidget(lb_glitch_thresh)
        hbox_roi_button6.addWidget(self.tx_glitch_thresh)
        hbox_roi_button6.setAlignment(QtCore.Qt.AlignLeft)

        hbox_roi_button7 = QHBoxLayout()
        hbox_roi_button7.addWidget(lb_file_index)
        hbox_roi_button7.addWidget(self.tx_file_index)
        hbox_roi_button7.setAlignment(QtCore.Qt.AlignLeft)

        vbox_roi = QVBoxLayout()
        vbox_roi.setContentsMargins(0, 0, 0, 0)
        vbox_roi.addLayout(hbox_roi_button1)
        vbox_roi.addLayout(hbox_roi_button2)
        #vbox_roi.addLayout(hbox_roi_button3)
        #vbox_roi.addLayout(hbox_roi_button31)
        vbox_roi.addWidget(lb_empty1)
        vbox_roi.addLayout(hbox_roi_button4)
        #vbox_roi.addWidget(lb_empty)
        vbox_roi.addLayout(hbox_roi_button5)

        vbox_roi.addLayout(hbox_roi_button6)
        #vbox_roi.addLayout(hbox_roi_button7)
        vbox_roi.addWidget(self.pb_roi_mean_val)
        vbox_roi.addWidget(lb_empty03)
        vbox_roi.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)

        '''
        vbox_lst = QVBoxLayout()
        vbox_lst.addWidget(lb_lst_roi, 0, QtCore.Qt.AlignTop)
        vbox_lst.addWidget(self.lst_roi, 0, QtCore.Qt.AlignTop)
        vbox_lst.addWidget(lb_empty)
        vbox_lst.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        '''

        box_roi = QHBoxLayout()
        box_roi.addLayout(vbox_roi)
        #box_roi.addLayout(vbox_lst)
        box_roi.addLayout(vbox_roi_list)
        box_roi.addWidget(lb_empty01)
        box_roi.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)

        box_roi_tot = QVBoxLayout()
        box_roi_tot.addWidget(lb_roi)
        box_roi_tot.addWidget(lb_info)
        box_roi_tot.addLayout(box_roi)
        box_roi_tot.addLayout(vbox_crop)
        box_roi_tot.addWidget(lb_empty02)
        box_roi_tot.setAlignment(QtCore.Qt.AlignLeft)
        return box_roi_tot

    def layout_analysis(self):
        lb_empty = QLabel()
        lb_empty.setFixedHeight(20)
        layout_find_edge = self.layout_find_edge()
        layout_combine_xanes = self.layout_combine_xanes()

        vbox = QVBoxLayout()
        vbox.addLayout(layout_find_edge)
        vbox.addWidget(lb_empty)
        vbox.addLayout(layout_combine_xanes)
        vbox.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)

        return vbox

    def layout_find_edge(self):
        lb_empty = QLabel()
        lb_empty.setFixedWidth(100)
        lb_empty1 = QLabel()
        lb_empty1.setFixedWidth(20)

        lb_edge_peak_note = QLabel()
        lb_edge_peak_note.setFont(self.font2)
        lb_edge_peak_note.setText('''Two methods provided:
        "spline" is slow, can fit edge and peak
        "polynomial" is very fast, can fit peak only''')
        lb_edge_peak_note.setFixedWidth(400)

        lb_find_edge = QLabel()
        lb_find_edge.setFont(self.font1)
        lb_find_edge.setText('Find absorption edge')
        #lb_find_edge.setStyleSheet('color: rgb(200,50,50);')
        lb_find_edge.setFixedWidth(200)

        lb_edge_range = QLabel()
        lb_edge_range.setFont(self.font2)
        lb_edge_range.setText('Energy range:')
        lb_edge_range.setFixedWidth(100)

        lb_edge_range_s = QLabel()
        lb_edge_range_s.setFont(self.font2)
        lb_edge_range_s.setText('start:')
        lb_edge_range_s.setFixedWidth(50)

        lb_edge_range_e = QLabel()
        lb_edge_range_e.setFont(self.font2)
        lb_edge_range_e.setText('end:')
        lb_edge_range_e.setFixedWidth(50)

        self.tx_edge_s = QLineEdit()
        self.tx_edge_s.setFont(self.font2)
        self.tx_edge_s.setFixedWidth(60)
        self.tx_edge_s.setValidator(QDoubleValidator())

        self.tx_edge_e = QLineEdit()
        self.tx_edge_e.setFont(self.font2)
        self.tx_edge_e.setFixedWidth(60)
        self.tx_edge_e.setValidator(QDoubleValidator())

        hbox_edge_range = QHBoxLayout()
        hbox_edge_range.addWidget(lb_edge_range)
        hbox_edge_range.addWidget(lb_edge_range_s)
        hbox_edge_range.addWidget(self.tx_edge_s)
        hbox_edge_range.addWidget(lb_empty1)
        hbox_edge_range.addWidget(lb_edge_range_e)
        hbox_edge_range.addWidget(self.tx_edge_e)
        hbox_edge_range.setAlignment(QtCore.Qt.AlignLeft)

        #
        lb_edge_est = QLabel()
        lb_edge_est.setText('Pre-edge:')
        lb_edge_est.setFont(self.font2)
        lb_edge_est.setFixedWidth(100)

        lb_edge_est_pos = QLabel()
        lb_edge_est_pos.setText('pos.:')
        lb_edge_est_pos.setFont(self.font2)
        lb_edge_est_pos.setFixedWidth(50)

        self.tx_edge_pos = QLineEdit()
        self.tx_edge_pos.setFont(self.font2)
        self.tx_edge_pos.setText('')
        self.tx_edge_pos.setFixedWidth(60)
        self.tx_edge_pos.setValidator(QDoubleValidator())

        lb_pre_edge_wt = QLabel()
        lb_pre_edge_wt.setText('weight:')
        lb_pre_edge_wt.setFont(self.font2)
        lb_pre_edge_wt.setFixedWidth(50)

        self.tx_pre_edge_wt = QLineEdit()
        self.tx_pre_edge_wt.setText('1.0')
        self.tx_pre_edge_wt.setFont(self.font2)
        self.tx_pre_edge_wt.setValidator(QDoubleValidator())
        self.tx_pre_edge_wt.setFixedWidth(60)

        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(20)

        hbox_edge_pos = QHBoxLayout()
        hbox_edge_pos.addWidget(lb_edge_est)
        hbox_edge_pos.addWidget(lb_edge_est_pos)
        hbox_edge_pos.addWidget(self.tx_edge_pos)
        hbox_edge_pos.addWidget(lb_empty2)
        hbox_edge_pos.addWidget(lb_pre_edge_wt)
        hbox_edge_pos.addWidget(self.tx_pre_edge_wt)
        hbox_edge_pos.setAlignment(QtCore.Qt.AlignLeft)

        # fit parameter

        lb_empty3 = QLabel()
        lb_empty3.setFixedWidth(100)

        lb_edge_param = QLabel()
        lb_edge_param.setText('Fit param:')
        lb_edge_param.setFont(self.font2)
        lb_edge_param.setFixedWidth(100)

        lb_edge_smooth = QLabel()
        lb_edge_smooth.setText('smooth:')
        lb_edge_smooth.setFixedWidth(50)
        lb_edge_smooth.setFont(self.font2)

        self.tx_edge_smooth = QLineEdit()
        self.tx_edge_smooth.setText('0.002')
        self.tx_edge_smooth.setFont(self.font2)
        self.tx_edge_smooth.setValidator(QDoubleValidator())
        self.tx_edge_smooth.setFixedWidth(60)

        lb_edge_order = QLabel()
        lb_edge_order.setText('order:')
        lb_edge_order.setFixedWidth(50)
        lb_edge_order.setFont(self.font2)

        self.tx_edge_order = QLineEdit()
        self.tx_edge_order.setText('2')
        self.tx_edge_order.setFont(self.font2)
        self.tx_edge_order.setValidator(QIntValidator())
        self.tx_edge_order.setFixedWidth(60)

        hbox_edge_param = QHBoxLayout()
        hbox_edge_param.addWidget(lb_edge_param)
        hbox_edge_param.addWidget(lb_edge_smooth)
        hbox_edge_param.addWidget(self.tx_edge_smooth)
        hbox_edge_param.addWidget(lb_empty2)
        hbox_edge_param.addWidget(lb_edge_order)
        hbox_edge_param.addWidget(self.tx_edge_order)
        hbox_edge_param.setAlignment(QtCore.Qt.AlignLeft)

        #
        self.chkbox_edge = QCheckBox('Fitting edge')
        self.chkbox_edge.setFont(self.font2)
        self.chkbox_edge.setFixedWidth(105)
        self.chkbox_edge.setChecked(True)

        self.chkbox_peak = QCheckBox('Fitting peak')
        self.chkbox_peak.setFont(self.font2)
        self.chkbox_peak.setFixedWidth(105)
        self.chkbox_peak.setChecked(True)

        self.peak_maxmin_group = QButtonGroup()
        self.peak_maxmin_group.setExclusive(True)
        self.rd_peak_max = QRadioButton('max')
        self.rd_peak_max.setFixedWidth(60)
        self.rd_peak_max.setChecked(True)

        self.rd_peak_min = QRadioButton('min')
        self.rd_peak_min.setFixedWidth(60)
        self.rd_peak_min.setChecked(False)
        self.peak_maxmin_group.addButton(self.rd_peak_max)
        self.peak_maxmin_group.addButton(self.rd_peak_min)

        hbox_fit_peak = QHBoxLayout()
        hbox_fit_peak.addWidget(self.chkbox_peak)
        hbox_fit_peak.addWidget(self.rd_peak_max)
        hbox_fit_peak.addWidget(self.rd_peak_min)
        hbox_fit_peak.setAlignment(QtCore.Qt.AlignLeft)

        lb_fit_method = QLabel()
        lb_fit_method.setFont(self.font2)
        lb_fit_method.setFixedWidth(105)
        lb_fit_method.setText('Fitting use:')

        self.rd_peak_fit_method1 = QRadioButton('Spline curve')
        self.rd_peak_fit_method1.setFixedWidth(105)
        self.rd_peak_fit_method1.setFont(self.font2)
        self.rd_peak_fit_method1.toggled.connect(self.peak_fit_toggled)

        self.rd_peak_fit_method2 = QRadioButton('polynomial')
        self.rd_peak_fit_method2.setFixedWidth(105)
        self.rd_peak_fit_method2.setFont(self.font2)
        self.rd_peak_fit_method2.setChecked(True)
        self.rd_peak_fit_method2.toggled.connect(self.peak_fit_toggled)
        self.peak_fit_toggled()

        self.rdgp_peak_fit = QButtonGroup()
        self.rdgp_peak_fit.setExclusive(True)
        self.rdgp_peak_fit.addButton(self.rd_peak_fit_method1)
        self.rdgp_peak_fit.addButton(self.rd_peak_fit_method2)

        hbox_fit_peak_method = QHBoxLayout()
        hbox_fit_peak_method.addWidget(lb_fit_method)
        hbox_fit_peak_method.addWidget(self.rd_peak_fit_method1)
        hbox_fit_peak_method.addWidget(self.rd_peak_fit_method2)
        hbox_fit_peak_method.setAlignment(QtCore.Qt.AlignLeft)

        vbox_fit_edge_peak = QVBoxLayout()
        vbox_fit_edge_peak.addWidget(self.chkbox_edge)
        vbox_fit_edge_peak.addLayout(hbox_fit_peak)
        vbox_fit_edge_peak.addLayout(hbox_fit_peak_method)
        vbox_fit_edge_peak.setAlignment(QtCore.Qt.AlignTop)

        # scale image
        lb_empty3 = QLabel()
        lb_empty3.setFixedWidth(80)

        lb_scale_img = QLabel()
        lb_scale_img.setText('scale  x')
        lb_scale_img.setFixedWidth(50)
        lb_scale_img.setFont(self.font2)

        self.tx_scale_img = QLineEdit()
        self.tx_scale_img.setText('1.0')
        self.tx_scale_img.setFont(self.font2)
        self.tx_scale_img.setValidator(QDoubleValidator())
        self.tx_scale_img.setFixedWidth(60)

        self.pb_scale_img = QPushButton()
        self.pb_scale_img.setText('Scale Img.')
        self.pb_scale_img.setFont(self.font2)
        self.pb_scale_img.setFixedWidth(100)
        self.pb_scale_img.clicked.connect(self.scale_image)

        lb_overlay_roi = QLabel()
        lb_overlay_roi.setText('ROI #')
        lb_overlay_roi.setFixedWidth(50)
        lb_overlay_roi.setFont(self.font2)

        self.tx_overlay_roi = QLineEdit()
        self.tx_overlay_roi.setText('-1')
        self.tx_overlay_roi.setFont(self.font2)
        self.tx_overlay_roi.setValidator(QIntValidator())
        self.tx_overlay_roi.setFixedWidth(60)

        hbox_scale_img = QHBoxLayout()
        hbox_scale_img.addWidget(self.pb_scale_img)
        hbox_scale_img.addWidget(lb_scale_img)
        hbox_scale_img.addWidget(self.tx_scale_img)
        hbox_scale_img.addWidget(lb_empty2)
        hbox_scale_img.addWidget(lb_overlay_roi)
        hbox_scale_img.addWidget(self.tx_overlay_roi)
        hbox_scale_img.setAlignment(QtCore.Qt.AlignLeft)

        #

        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(5)

        self.pb_load_edge_curve = QPushButton()
        self.pb_load_edge_curve.setText('Load curve')
        self.pb_load_edge_curve.setFont(self.font2)
        self.pb_load_edge_curve.setFixedWidth(100)
        self.pb_load_edge_curve.clicked.connect(self.load_external_spec)

        self.pb_fit_edge_curve = QPushButton()
        self.pb_fit_edge_curve.setText('Fit curve')
        self.pb_fit_edge_curve.setFont(self.font2)
        self.pb_fit_edge_curve.setFixedWidth(100)
        self.pb_fit_edge_curve.clicked.connect(self.fit_edge_curve)

        hbox_fit_edge_curve = QHBoxLayout()
        hbox_fit_edge_curve.addWidget(self.pb_load_edge_curve)
        hbox_fit_edge_curve.addWidget(self.pb_fit_edge_curve)
        hbox_fit_edge_curve.setAlignment(QtCore.Qt.AlignLeft)

        #
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(5)

        self.pb_find_edge = QPushButton()
        self.pb_find_edge.setText('Fit ROI')
        self.pb_find_edge.setFont(self.font2)
        self.pb_find_edge.setFixedWidth(100)
        self.pb_find_edge.clicked.connect(self.find_edge_peak_single)

        self.pb_find_edge_img = QPushButton()
        self.pb_find_edge_img.setText('Fit image')
        self.pb_find_edge_img.setFont(self.font2)
        self.pb_find_edge_img.setFixedWidth(100)
        self.pb_find_edge_img.clicked.connect(self.find_edge_peak_image)

        self.pb_plot_edge_roi = QPushButton()
        self.pb_plot_edge_roi.setText('Plot fit ROI')
        self.pb_plot_edge_roi.setFont(self.font2)
        self.pb_plot_edge_roi.setFixedWidth(100)
        self.pb_plot_edge_roi.clicked.connect(self.plot_fit_edge_peak_roi)

        hbox_find_edge = QHBoxLayout()
        hbox_find_edge.addWidget(self.pb_find_edge)
        hbox_find_edge.addWidget(self.pb_find_edge_img)
        hbox_find_edge.setAlignment(QtCore.Qt.AlignLeft)

        # convert peak position to percentage
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(15)

        self.pb_cvt_percentage = QPushButton()
        self.pb_cvt_percentage.setText('Cvt peak %')
        self.pb_cvt_percentage.setFont(self.font2)
        self.pb_cvt_percentage.setFixedWidth(100)
        self.pb_cvt_percentage.clicked.connect(self.convert_percentage_image)

        lb_cvt_min = QLabel()
        lb_cvt_min.setText('pk_min')
        lb_cvt_min.setFixedWidth(50)
        lb_cvt_min.setFont(self.font2)

        self.tx_cvt_min = QLineEdit()
        self.tx_cvt_min.setText('')
        self.tx_cvt_min.setFont(self.font2)
        self.tx_cvt_min.setValidator(QDoubleValidator())
        self.tx_cvt_min.setFixedWidth(60)

        lb_cvt_max = QLabel()
        lb_cvt_max.setText('pk_max')
        lb_cvt_max.setFixedWidth(55)
        lb_cvt_max.setFont(self.font2)

        self.tx_cvt_max = QLineEdit()
        self.tx_cvt_max.setText('')
        self.tx_cvt_max.setFont(self.font2)
        self.tx_cvt_max.setValidator(QDoubleValidator())
        self.tx_cvt_max.setFixedWidth(60)

        # 2nd method to fit peak only using polynominal

        hbox_cvt_percentage = QHBoxLayout()
        hbox_cvt_percentage.addWidget(self.pb_cvt_percentage)
        hbox_cvt_percentage.addWidget(lb_cvt_min)
        hbox_cvt_percentage.addWidget(self.tx_cvt_min)
        hbox_cvt_percentage.addWidget(lb_empty2)
        hbox_cvt_percentage.addWidget(lb_cvt_max)
        hbox_cvt_percentage.addWidget(self.tx_cvt_max)
        hbox_cvt_percentage.setAlignment(QtCore.Qt.AlignLeft)

        # assemble
        lb_empty4 = QLabel()
        lb_empty4.setFixedHeight(10)
        vbox_find_edge = QVBoxLayout()

        vbox_find_edge.addWidget(lb_edge_peak_note)
        vbox_find_edge.addWidget(lb_empty4)
        vbox_find_edge.addWidget(lb_find_edge)
        vbox_find_edge.addLayout(vbox_fit_edge_peak)
        vbox_find_edge.addLayout(hbox_edge_range)
        vbox_find_edge.addLayout(hbox_edge_pos)
        vbox_find_edge.addLayout(hbox_edge_param)
        vbox_find_edge.addLayout(hbox_scale_img)
        vbox_find_edge.addLayout(hbox_find_edge)
        vbox_find_edge.addLayout(hbox_cvt_percentage)
        vbox_find_edge.addWidget(lb_empty)
        vbox_find_edge.addLayout(hbox_fit_edge_curve)
        vbox_find_edge.setAlignment(QtCore.Qt.AlignTop)

        return vbox_find_edge

    def layout_combine_xanes(self):
        lb_empty = QLabel()
        lb_empty.setFixedWidth(100)
        lb_empty1 = QLabel()
        lb_empty1.setFixedWidth(20)

        lb_comb_xanes = QLabel()
        lb_comb_xanes.setFont(self.font1)
        lb_comb_xanes.setText('Combine xanes image')
        lb_comb_xanes.setFixedWidth(200)
        #lb_comb_xanes.setStyleSheet('color: rgb(200, 50, 50);')

        lb_xanes_img = QLabel()
        lb_xanes_img.setFont(self.font2)
        lb_xanes_img.setText('Image file')
        lb_xanes_img.setFixedWidth(170)

        lb_xanes_eng = QLabel()
        lb_xanes_eng.setFont(self.font2)
        lb_xanes_eng.setText('XEng (.h5, .txt)')
        lb_xanes_eng.setFixedWidth(170)

        self.lst_comb_img = QListWidget()
        self.lst_comb_img.setFont(self.font2)
        self.lst_comb_img.setSelectionMode(QAbstractItemView.SingleSelection)
        self.lst_comb_img.setFixedWidth(170)
        self.lst_comb_img.setFixedHeight(80)

        self.lst_comb_eng = QListWidget()
        self.lst_comb_eng.setFont(self.font2)
        self.lst_comb_eng.setSelectionMode(QAbstractItemView.SingleSelection)
        self.lst_comb_eng.setFixedWidth(170)
        self.lst_comb_eng.setFixedHeight(80)

        self.pb_load_comb_img = QPushButton('Add image')
        self.pb_load_comb_img.setFont(self.font2)
        self.pb_load_comb_img.setFixedWidth(170)
        self.pb_load_comb_img.clicked.connect(self.load_comb_xanes_img)

        self.pb_load_comb_eng = QPushButton('Add XEng')
        self.pb_load_comb_eng.setFont(self.font2)
        self.pb_load_comb_eng.setFixedWidth(170)
        self.pb_load_comb_eng.clicked.connect(self.load_comb_xanes_eng)

        self.pb_del_single_comb_img = QPushButton('Del. img')
        self.pb_del_single_comb_img.setFont(self.font2)
        self.pb_del_single_comb_img.setFixedWidth(122)
        self.pb_del_single_comb_img.clicked.connect(lambda:self.remove_comb_xanes_single('img'))

        self.pb_del_single_comb_eng = QPushButton('Del. XEng')
        self.pb_del_single_comb_eng.setFont(self.font2)
        self.pb_del_single_comb_eng.setFixedWidth(122)
        self.pb_del_single_comb_eng.clicked.connect(lambda:self.remove_comb_xanes_single('eng'))


        self.pb_del_comb = QPushButton('Del. all')
        self.pb_del_comb.setFont(self.font2)
        self.pb_del_comb.setFixedWidth(122)
        self.pb_del_comb.clicked.connect(self.remove_comb_xanes_all)

        self.pb_comb = QPushButton('Combine and save')
        self.pb_comb.setFont(self.font1)
        self.pb_comb.setFixedWidth(250)
        self.pb_comb.clicked.connect(self.combine_xanes)

        lb_comb_h5_img = QLabel()
        lb_comb_h5_img.setFont(self.font2)
        lb_comb_h5_img.setText('h5_attr: img')
        lb_comb_h5_img.setFixedWidth(85)

        self.tx_comb_h5_img = QLineEdit()
        self.tx_comb_h5_img.setFont(self.font2)
        self.tx_comb_h5_img.setFixedWidth(80)
        self.tx_comb_h5_img.setText('img_xanes')

        lb_comb_h5_eng = QLabel()
        lb_comb_h5_eng.setFont(self.font2)
        lb_comb_h5_eng.setText('h5_attr: XEng')
        lb_comb_h5_eng.setFixedWidth(90)

        self.tx_comb_h5_eng = QLineEdit()
        self.tx_comb_h5_eng.setFont(self.font2)
        self.tx_comb_h5_eng.setFixedWidth(75)
        self.tx_comb_h5_eng.setText('X_eng')

        hbox_h5_img = QHBoxLayout()
        hbox_h5_img.addWidget(lb_comb_h5_img)
        hbox_h5_img.addWidget(self.tx_comb_h5_img)
        hbox_h5_img.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_h5_eng = QHBoxLayout()
        hbox_h5_eng.addWidget(lb_comb_h5_eng)
        hbox_h5_eng.addWidget(self.tx_comb_h5_eng)
        hbox_h5_eng.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_pb_img = QVBoxLayout()
        vbox_pb_img.addLayout(hbox_h5_img)
        vbox_pb_img.addWidget(self.pb_load_comb_img)
        vbox_pb_img.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_pb_eng = QVBoxLayout()
        vbox_pb_eng.addLayout(hbox_h5_eng)
        vbox_pb_eng.addWidget(self.pb_load_comb_eng)
        vbox_pb_eng.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_img = QVBoxLayout()
        vbox_img.addWidget(lb_xanes_img)
        vbox_img.addWidget(self.lst_comb_img)
        vbox_img.addLayout(vbox_pb_img)
        vbox_img.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_eng = QVBoxLayout()
        vbox_eng.addWidget(lb_xanes_eng)
        vbox_eng.addWidget(self.lst_comb_eng)
        vbox_eng.addLayout(vbox_pb_eng)
        vbox_eng.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_comb_lst = QHBoxLayout()
        hbox_comb_lst.addLayout(vbox_img)
        hbox_comb_lst.addLayout(vbox_eng)
        hbox_comb_lst.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        hbox_comb_del = QHBoxLayout()
        hbox_comb_del.addWidget(self.pb_del_single_comb_img)
        hbox_comb_del.addWidget(self.pb_del_single_comb_eng)
        hbox_comb_del.addWidget(self.pb_del_comb)
        hbox_comb_del.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_comb_pb = QVBoxLayout()
        vbox_comb_pb.addLayout(hbox_comb_del)
        vbox_comb_pb.addWidget(self.pb_comb)
        vbox_comb_pb.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        vbox_comb = QVBoxLayout()
        vbox_comb.addWidget(lb_comb_xanes)
        vbox_comb.addLayout(hbox_comb_lst)
        vbox_comb.addLayout(vbox_comb_pb)
        vbox_comb.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        return vbox_comb

    def layout_roi_normalization(self):
        lb_empty = QLabel()
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(120)

        lb_fit_edge = QLabel()
        lb_fit_edge.setFont(self.font1)
        lb_fit_edge.setText('ROI normalization')
        lb_fit_edge.setFixedWidth(150)

        lb_fit_pre_s = QLabel()
        lb_fit_pre_s.setText('Pre -edge start:')
        lb_fit_pre_s.setFont(self.font2)
        lb_fit_pre_s.setFixedWidth(120)

        lb_fit_pre_e = QLabel()
        lb_fit_pre_e.setText(' end: ')
        lb_fit_pre_e.setFont(self.font2)
        lb_fit_pre_e.setFixedWidth(50)

        lb_fit_post_s = QLabel()
        lb_fit_post_s.setText('Post-edge start:')
        lb_fit_post_s.setFont(self.font2)
        lb_fit_post_s.setFixedWidth(120)

        lb_fit_post_e = QLabel()
        lb_fit_post_e.setText(' end: ')
        lb_fit_post_e.setFont(self.font2)
        lb_fit_post_e.setFixedWidth(50)

        self.tx_fit_pre_s = QLineEdit()
        self.tx_fit_pre_s.setFont(self.font2)
        self.tx_fit_pre_s.setFixedWidth(60)
        self.tx_fit_pre_s.setValidator(QDoubleValidator())

        self.tx_fit_pre_e = QLineEdit()
        self.tx_fit_pre_e.setFont(self.font2)
        self.tx_fit_pre_e.setFixedWidth(60)
        self.tx_fit_pre_e.setValidator(QDoubleValidator())

        self.tx_fit_post_s = QLineEdit()
        self.tx_fit_post_s.setFont(self.font2)
        self.tx_fit_post_s.setFixedWidth(60)
        self.tx_fit_post_s.setValidator(QDoubleValidator())

        self.tx_fit_post_e = QLineEdit()
        self.tx_fit_post_e.setFont(self.font2)
        self.tx_fit_post_e.setFixedWidth(60)
        self.tx_fit_post_e.setValidator(QDoubleValidator())

        lb_fit_roi = QLabel()
        lb_fit_roi.setFont(self.font2)
        lb_fit_roi.setText('Norm Spec(ROI)')
        lb_fit_roi.setFixedWidth(120)

        self.pb_fit_roi = QPushButton('Norm Spec')
        self.pb_fit_roi.setFont(self.font2)
        self.pb_fit_roi.clicked.connect(self.fit_edge)
        self.pb_fit_roi.setFixedWidth(90)

        self.pb_save_fit_roi = QPushButton('Save Spec')
        self.pb_save_fit_roi.setFont(self.font2)
        self.pb_save_fit_roi.clicked.connect(self.save_normed_roi)
        self.pb_save_fit_roi.setFixedWidth(90)

        lb_fit_img = QLabel()
        lb_fit_img.setFont(self.font2)
        lb_fit_img.setText('Norm Image')
        lb_fit_img.setFixedWidth(120)

        self.pb_fit_img = QPushButton('Norm Image')
        self.pb_fit_img.setFont(self.font2)
        self.pb_fit_img.clicked.connect(self.fit_edge_img)
        self.pb_fit_img.setFixedWidth(90)

        self.chkbox_norm_pre_edge_only = QCheckBox('pre-edge only')
        self.chkbox_norm_pre_edge_only.setFixedWidth(190)
        self.chkbox_norm_pre_edge_only.setFont(self.font2)
        self.chkbox_norm_pre_edge_only.setChecked(False)

        self.norm_group = QButtonGroup()
        self.norm_group.setExclusive(True)
        self.rd_norm1 = QRadioButton('1')
        self.rd_norm1.setFixedWidth(45)

        # self.rd_norm1.toggled.connect(self.select_file)

        self.rd_norm2 = QRadioButton('2')
        self.rd_norm2.setFixedWidth(45)
        # self.rd_norm2.toggled.connect(self.select_file)

        self.norm_group.addButton(self.rd_norm1)
        self.norm_group.addButton(self.rd_norm2)
        self.norm_group = QButtonGroup()
        self.norm_group.setExclusive(True)
        self.rd_norm1.setChecked(True)

        lb_reg_img = QLabel()
        lb_reg_img.setFont(self.font2)
        lb_reg_img.setText('max:')
        lb_reg_img.setFixedWidth(30)

        self.tx_reg_max = QLineEdit()
        self.tx_reg_max.setFont(self.font2)
        self.tx_reg_max.setText('1.65')
        self.tx_reg_max.setValidator(QDoubleValidator())
        self.tx_reg_max.setFixedWidth(60)

        lb_reg_width = QLabel()
        lb_reg_width.setText(' Width:')
        lb_reg_width.setFont(self.font2)
        lb_reg_width.setFixedWidth(50)

        self.tx_reg_width = QLineEdit()
        self.tx_reg_width.setFont(self.font2)
        self.tx_reg_width.setValidator(QDoubleValidator())
        self.tx_reg_width.setText('0.05')
        self.tx_reg_width.setFixedWidth(60)

        self.pb_reg_img = QPushButton('Regulation')
        self.pb_reg_img.setFont(self.font2)
        self.pb_reg_img.clicked.connect(self.regular_edge_img)
        self.pb_reg_img.setFixedWidth(90)

        # load and norm existing spectrum
        lb_alt = QLabel()
        lb_alt.setFont(self.font1)
        lb_alt.setText('External spectrum')
        lb_alt.setFixedWidth(150)

        self.pb_load_exist_spec = QPushButton('Load external Spec.')
        self.pb_load_exist_spec.setFont(self.font2)
        self.pb_load_exist_spec.clicked.connect(self.load_external_spec)
        self.pb_load_exist_spec.setFixedWidth(200)

        self.pb_norm_exist_spec = QPushButton('Norm external Spec.')
        self.pb_norm_exist_spec.setFont(self.font2)
        self.pb_norm_exist_spec.clicked.connect(self.norm_external_spec)
        self.pb_norm_exist_spec.setFixedWidth(200)

        self.pb_save_exist_spec = QPushButton('Save external Spec.')
        self.pb_save_exist_spec.setFont(self.font2)
        self.pb_save_exist_spec.clicked.connect(self.save_external_spec)
        self.pb_save_exist_spec.setFixedWidth(200)

        vbox_exist_spec = QVBoxLayout()
        vbox_exist_spec.addWidget(lb_alt)
        vbox_exist_spec.addWidget(self.pb_load_exist_spec)
        vbox_exist_spec.addWidget(self.pb_norm_exist_spec)
        vbox_exist_spec.addWidget(self.pb_save_exist_spec)
        vbox_exist_spec.setAlignment(QtCore.Qt.AlignTop)


        hbox_fit_pre = QHBoxLayout()
        hbox_fit_pre.addWidget(lb_fit_pre_s)
        hbox_fit_pre.addWidget(self.tx_fit_pre_s)
        hbox_fit_pre.addWidget(lb_fit_pre_e)
        hbox_fit_pre.addWidget(self.tx_fit_pre_e)
        hbox_fit_pre.setAlignment(QtCore.Qt.AlignLeft)

        hbox_fit_post = QHBoxLayout()
        hbox_fit_post.addWidget(lb_fit_post_s)
        hbox_fit_post.addWidget(self.tx_fit_post_s)
        hbox_fit_post.addWidget(lb_fit_post_e)
        hbox_fit_post.addWidget(self.tx_fit_post_e)
        hbox_fit_post.setAlignment(QtCore.Qt.AlignLeft)

        hbox_fit_pb = QHBoxLayout()
        hbox_fit_pb.addWidget(lb_fit_roi)
        hbox_fit_pb.addWidget(self.pb_fit_roi)
        hbox_fit_pb.addWidget(self.pb_save_fit_roi)
        hbox_fit_pb.setAlignment(QtCore.Qt.AlignLeft)

        hbox_fit_pb_img = QHBoxLayout()
        # hbox_fit_pb_img.addWidget(lb_fit_img)
        hbox_fit_pb_img.addWidget(self.pb_fit_img)
        hbox_fit_pb_img.addWidget(self.rd_norm1)
        hbox_fit_pb_img.addWidget(self.rd_norm2)
        hbox_fit_pb_img.addWidget(self.chkbox_norm_pre_edge_only)
        hbox_fit_pb_img.setAlignment(QtCore.Qt.AlignLeft)

        hbox_reg_pb_img = QHBoxLayout()
        hbox_reg_pb_img.addWidget(self.pb_reg_img)
        hbox_reg_pb_img.addWidget(lb_reg_img)
        hbox_reg_pb_img.addWidget(self.tx_reg_max)
        hbox_reg_pb_img.addWidget(lb_reg_width)
        hbox_reg_pb_img.addWidget(self.tx_reg_width)
        hbox_reg_pb_img.setAlignment(QtCore.Qt.AlignLeft)

        hbox_reg_pb_img2 = QHBoxLayout()
        hbox_reg_pb_img2.addWidget(lb_empty2)
        hbox_reg_pb_img2.addWidget(self.pb_reg_img)
        hbox_reg_pb_img2.setAlignment(QtCore.Qt.AlignLeft)

        vbox_fit = QVBoxLayout()
        vbox_fit.addWidget(lb_fit_edge)
        vbox_fit.addLayout(hbox_fit_pre)
        vbox_fit.addLayout(hbox_fit_post)
        vbox_fit.addLayout(hbox_fit_pb)
        vbox_fit.addLayout(hbox_fit_pb_img)
        vbox_fit.addLayout(hbox_reg_pb_img)
        # vbox_fit.addLayout(hbox_reg_pb_img2)
        vbox_fit.addWidget(lb_empty)
        vbox_fit.addLayout(vbox_exist_spec)
        vbox_fit.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_fit


    def layout_fit2d(self):
        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(20)

        lb_empty2 = QLabel()
        lb_empty2.setFixedHeight(20)

        lb_empty3 = QLabel()
        lb_empty3.setFixedHeight(20)

        vbox_load_2d_ref = self.layout_load_2d_ref()
        vbox_fit_2d_method = self.layout_fit_2d_method()
        vbox_plot_2d_roi = self.layout_plot_2d_roi()

        vbox_assemble = QVBoxLayout()
        vbox_assemble.addLayout(vbox_load_2d_ref)
        vbox_assemble.addWidget(lb_empty1)
        vbox_assemble.addLayout(vbox_fit_2d_method)
        vbox_assemble.addWidget(lb_empty2)
        vbox_assemble.addLayout(vbox_plot_2d_roi)
        vbox_assemble.setAlignment(QtCore.Qt.AlignTop)
        vbox_assemble.addStretch()
        return vbox_assemble


    def layout_load_2d_ref(self):
        lb_empty = QLabel()
        lb_load_2d_ref = QLabel()
        lb_load_2d_ref.setFont(self.font1)
        lb_load_2d_ref.setText('Load references')
        lb_load_2d_ref.setFixedWidth(150)

        self.lb_ref_info = QLabel()
        self.lb_ref_info.setFont(self.font2)
        self.lb_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_ref_info.setText('Reference spectrum: ')
        self.lb_ref_info.setFixedWidth(300)

        self.pb_ld_ref = QPushButton('Load Ref.')
        self.pb_ld_ref.setFont(self.font2)
        self.pb_ld_ref.clicked.connect(self.load_xanes_ref)
        self.pb_ld_ref.setEnabled(True)
        self.pb_ld_ref.setFixedWidth(105)

        self.pb_plt_ref = QPushButton('Plot Ref.')
        self.pb_plt_ref.setFont(self.font2)
        self.pb_plt_ref.clicked.connect(self.plot_xanes_ref)
        self.pb_plt_ref.setEnabled(True)
        self.pb_plt_ref.setFixedWidth(105)

        lb_elem = QLabel()
        lb_elem.setFont(self.font2)
        lb_elem.setText(' Elem.: ')
        lb_elem.setFixedWidth(40)

        self.tx_elem = QLineEdit(self)
        self.tx_elem.setFont(self.font2)
        self.tx_elem.setFixedWidth(60)

        hbox_ref = QHBoxLayout()
        hbox_ref.addWidget(self.pb_ld_ref)
        hbox_ref.addWidget(lb_elem)
        hbox_ref.addWidget(self.tx_elem)
        hbox_ref.addWidget(self.pb_plt_ref)
        hbox_ref.setAlignment(QtCore.Qt.AlignTop)

        self.pb_reset_ref = QPushButton('Reset Ref.')
        self.pb_reset_ref.setFont(self.font2)
        self.pb_reset_ref.clicked.connect(self.reset_xanes_ref)
        self.pb_reset_ref.setEnabled(True)
        self.pb_reset_ref.setFixedWidth(105)

        self.pb_reset_fit = QPushButton('Reset All')
        self.pb_reset_fit.setFont(self.font2)
        self.pb_reset_fit.clicked.connect(self.reset_xanes_fit)
        self.pb_reset_fit.setEnabled(True)
        self.pb_reset_fit.setFixedWidth(105)

        hbox_reset_ref = QHBoxLayout()
        hbox_reset_ref.addWidget(self.pb_reset_ref)
        hbox_reset_ref.addWidget(self.pb_reset_fit)
        hbox_reset_ref.setAlignment(QtCore.Qt.AlignLeft)

        ############################
        lb_fit2d_s = QLabel()
        lb_fit2d_s.setText('Fit energy range  start:')
        lb_fit2d_s.setFont(self.font2)
        lb_fit2d_s.setFixedWidth(150)

        lb_fit2d_e = QLabel()
        lb_fit2d_e.setText(' end:')
        lb_fit2d_e.setFont(self.font2)
        lb_fit2d_e.setFixedWidth(40)

        self.tx_fit2d_s = QLineEdit()
        self.tx_fit2d_s.setFont(self.font2)
        self.tx_fit2d_s.setFixedWidth(60)

        self.tx_fit2d_e = QLineEdit()
        self.tx_fit2d_e.setFont(self.font2)
        self.tx_fit2d_e.setFixedWidth(60)

        hbox_fit2d_range = QHBoxLayout()
        hbox_fit2d_range.addWidget(lb_fit2d_s)
        hbox_fit2d_range.addWidget(self.tx_fit2d_s)
        hbox_fit2d_range.addWidget(lb_fit2d_e)
        hbox_fit2d_range.addWidget(self.tx_fit2d_e)
        hbox_fit2d_range.setAlignment(QtCore.Qt.AlignLeft)

        ###########################

        vbox_load_2d_ref = QVBoxLayout()
        vbox_load_2d_ref.addWidget(lb_load_2d_ref)
        vbox_load_2d_ref.addWidget(self.lb_ref_info)
        vbox_load_2d_ref.addLayout(hbox_fit2d_range)
        vbox_load_2d_ref.addLayout(hbox_ref)
        vbox_load_2d_ref.addLayout(hbox_reset_ref)

        return vbox_load_2d_ref


    def layout_fit_2d_method(self):
        lb_empty = QLabel()
        lb_fit_2d = QLabel()
        lb_fit_2d.setFont(self.font1)
        lb_fit_2d.setText('Fit 2D XANES')
        lb_fit_2d.setFixedWidth(150)

        self.pb_fit2d = QPushButton('Fit 2D')
        self.pb_fit2d.setFont(self.font2)
        #self.pb_fit2d.clicked.connect(self.fit_2d_xanes)
        self.pb_fit2d.clicked.connect(self.fit_2d_xanes_wrap)
        self.pb_fit2d.setEnabled(True)
        self.pb_fit2d.setFixedWidth(105)

        self.pb_save2d = QPushButton('Save 2D Fit')
        self.pb_save2d.setFont(self.font2)
        self.pb_save2d.clicked.connect(self.save_2Dfit)
        self.pb_save2d.setEnabled(False)
        self.pb_save2d.setFixedWidth(105)

        hbox_fit2d = QHBoxLayout()
        hbox_fit2d.addWidget(self.pb_fit2d)
        hbox_fit2d.addWidget(self.pb_save2d)
        hbox_fit2d.setAlignment(QtCore.Qt.AlignLeft)

        ##############################################
        lb_fit_method = QLabel()
        lb_fit_method.setText('Method: ')
        lb_fit_method.setFixedWidth(60)
        lb_fit_method.setFont(self.font2)

        self.rd_fit_method1 = QRadioButton('Basic')
        self.rd_fit_method1.setFixedWidth(60)
        self.rd_fit_method1.setFont(self.font2)
        self.rd_fit_method1.setChecked(True)
        self.rd_fit_method1.toggled.connect(self.select_2d_fitting_method)

        self.rd_fit_method2 = QRadioButton('NNLS (slow)')
        self.rd_fit_method2.setFixedWidth(110)
        self.rd_fit_method2.setFont(self.font2)
        self.rd_fit_method2.setChecked(False)
        self.rd_fit_method2.toggled.connect(self.select_2d_fitting_method)

        self.rd_fit_method3 = QRadioButton('NN-ADMM')
        self.rd_fit_method3.setFixedWidth(110)
        self.rd_fit_method3.setFont(self.font2)
        self.rd_fit_method3.setChecked(False)
        self.rd_fit_method3.toggled.connect(self.select_2d_fitting_method)

        self.fit_method_group = QButtonGroup()
        self.fit_method_group.setExclusive(True)
        self.fit_method_group.addButton(self.rd_fit_method1)
        self.fit_method_group.addButton(self.rd_fit_method2)
        self.fit_method_group.addButton(self.rd_fit_method3)

        hbox_fit_method = QHBoxLayout()
        hbox_fit_method.addWidget(lb_fit_method)
        hbox_fit_method.addWidget(self.rd_fit_method1)
        #hbox_fit_method.addWidget(self.rd_fit_method2)
        hbox_fit_method.addWidget(self.rd_fit_method3)
        hbox_fit_method.setAlignment(QtCore.Qt.AlignLeft)

        #############################################
        lb_bkg_poly = QLabel()
        lb_bkg_poly.setFont(self.font2)
        lb_bkg_poly.setText('Bkg. polynomial:')
        lb_bkg_poly.setFixedWidth(120)

        self.chkbox_bkg_poly1 = QCheckBox('1')
        self.chkbox_bkg_poly1.setFixedWidth(45)
        self.chkbox_bkg_poly1.setFont(self.font2)
        self.chkbox_bkg_poly1.setChecked(False)

        self.chkbox_bkg_poly2 = QCheckBox('0')
        self.chkbox_bkg_poly2.setFixedWidth(45)
        self.chkbox_bkg_poly2.setFont(self.font2)
        self.chkbox_bkg_poly2.setChecked(True)

        self.chkbox_bkg_poly3 = QCheckBox('-1')
        self.chkbox_bkg_poly3.setFixedWidth(45)
        self.chkbox_bkg_poly3.setFont(self.font2)
        self.chkbox_bkg_poly3.setChecked(False)

        self.chkbox_bkg_poly4 = QCheckBox('-2')
        self.chkbox_bkg_poly4.setFixedWidth(45)
        self.chkbox_bkg_poly4.setFont(self.font2)
        self.chkbox_bkg_poly4.setChecked(False)

        self.chkbox_bkg_poly5 = QCheckBox('-3')
        self.chkbox_bkg_poly5.setFixedWidth(45)
        self.chkbox_bkg_poly5.setFont(self.font2)
        self.chkbox_bkg_poly5.setChecked(False)

        hbox_bkg_poly = QHBoxLayout()
        hbox_bkg_poly.addWidget(lb_bkg_poly)
        hbox_bkg_poly.addWidget(self.chkbox_bkg_poly1)
        hbox_bkg_poly.addWidget(self.chkbox_bkg_poly2)
        hbox_bkg_poly.addWidget(self.chkbox_bkg_poly3)
        hbox_bkg_poly.addWidget(self.chkbox_bkg_poly4)
        hbox_bkg_poly.addWidget(self.chkbox_bkg_poly5)
        hbox_bkg_poly.setAlignment(QtCore.Qt.AlignLeft)

        #############################################
        lb_iter_num = QLabel()
        lb_iter_num.setFont(self.font2)
        lb_iter_num.setText('Iteration:')
        lb_iter_num.setFixedWidth(105)

        self.tx_iter_num = QLineEdit(self)
        self.tx_iter_num.setFont(self.font2)
        self.tx_iter_num.setText('10')
        self.tx_iter_num.setValidator(QIntValidator())
        self.tx_iter_num.setFixedWidth(105)
        self.tx_iter_num.setEnabled(False)

        hbox_fit_iter_num = QHBoxLayout()
        hbox_fit_iter_num.addWidget(lb_iter_num)
        hbox_fit_iter_num.addWidget(self.tx_iter_num)
        hbox_fit_iter_num.setAlignment(QtCore.Qt.AlignTop)

        ##############################################
        lb_fit_rate = QLabel()
        lb_fit_rate.setFont(self.font2)
        lb_fit_rate.setText('Denoise level:')
        lb_fit_rate.setFixedWidth(105)

        self.tx_fit_rate = QLineEdit(self)
        self.tx_fit_rate.setFont(self.font2)
        self.tx_fit_rate.setText('0.02') # conjugate gradient updating rate
        self.tx_fit_rate.setFixedWidth(105)
        self.tx_fit_rate.setEnabled(False)

        hbox_fit_iter_rate = QHBoxLayout()
        hbox_fit_iter_rate.addWidget(lb_fit_rate)
        hbox_fit_iter_rate.addWidget(self.tx_fit_rate)
        hbox_fit_iter_rate.setAlignment(QtCore.Qt.AlignTop)
        ##############################################

        ##############################################
        lb_fit_iter_method = QLabel()
        lb_fit_iter_method.setFont(self.font2)
        lb_fit_iter_method.setText('DN method:')
        lb_fit_iter_method.setFixedWidth(105)

        self.cb_fit_iter_method = QComboBox()
        self.cb_fit_iter_method.setFont(self.font2)
        self.cb_fit_iter_method.addItem('NL mean')
        self.cb_fit_iter_method.addItem('BM3D')
        self.cb_fit_iter_method.setEnabled(False)
        self.cb_fit_iter_method.setFixedWidth(105)

        lb_fit_iter_sigma = QLabel()
        lb_fit_iter_sigma.setFont(self.font2)
        lb_fit_iter_sigma.setText('Sigma:')
        lb_fit_iter_sigma.setFixedWidth(60)

        self.tx_fit_iter_sigma = QLineEdit(self)
        self.tx_fit_iter_sigma.setFont(self.font2)
        self.tx_fit_iter_sigma.setText('0.1')  # conjugate gradient updating rate
        self.tx_fit_iter_sigma.setFixedWidth(60)
        self.tx_fit_iter_sigma.setValidator(QDoubleValidator())
        self.tx_fit_iter_sigma.setEnabled(False)


        hbox_fit_iter_method = QHBoxLayout()
        hbox_fit_iter_method.addWidget(lb_fit_iter_method)
        hbox_fit_iter_method.addWidget(self.cb_fit_iter_method)
        hbox_fit_iter_method.addWidget(lb_fit_iter_sigma)
        hbox_fit_iter_method.addWidget(self.tx_fit_iter_sigma)
        hbox_fit_iter_method.setAlignment(QtCore.Qt.AlignTop)


        vbox_fit_2d_method = QVBoxLayout()
        vbox_fit_2d_method.addWidget(lb_fit_2d)
        vbox_fit_2d_method.addLayout(hbox_fit2d)
        #vbox_fit_2d_method.addLayout(hbox_fit_select_method)
        vbox_fit_2d_method.addLayout(hbox_fit_method)
        vbox_fit_2d_method.addLayout(hbox_bkg_poly)
        vbox_fit_2d_method.addLayout(hbox_fit_iter_num)
        vbox_fit_2d_method.addLayout(hbox_fit_iter_rate)
        vbox_fit_2d_method.addLayout(hbox_fit_iter_method)
        vbox_fit_2d_method.setAlignment(QtCore.Qt.AlignTop)

        return vbox_fit_2d_method
        #############################################


    def layout_plot_2d_roi(self):
        lb_plot_roi = QLabel()
        lb_plot_roi.setText('Fit ROI average')
        lb_plot_roi.setFont(self.font1)
        lb_plot_roi.setFixedWidth(250)

        self.pb_plot_roi = QPushButton('Fit ROI')
        self.pb_plot_roi.setFont(self.font2)
        #self.pb_plot_roi.clicked.connect(lambda return_flag: self.plot_roi_fit(1))
        self.pb_plot_roi.clicked.connect(lambda: self.plot_roi_fit_new(False))
        self.pb_plot_roi.setEnabled(True)
        self.pb_plot_roi.setFixedWidth(105)

        self.pb_export_roi_fit = QPushButton('Save ROI fit')
        self.pb_export_roi_fit.setFont(self.font2)
        self.pb_export_roi_fit.clicked.connect(self.export_roi_fit)
        self.pb_export_roi_fit.setEnabled(True)
        self.pb_export_roi_fit.setFixedWidth(105)

        hbox_roi_fit = QHBoxLayout()
        hbox_roi_fit.addWidget(self.pb_plot_roi)
        hbox_roi_fit.addWidget(self.pb_export_roi_fit)
        hbox_roi_fit.setAlignment(QtCore.Qt.AlignLeft)

        lb_fit_roi = QLabel()
        lb_fit_roi.setFont(self.font2)
        lb_fit_roi.setText(' ROI #: ')
        lb_fit_roi.setFixedWidth(50)

        self.tx_fit_roi = QLineEdit(self)
        self.tx_fit_roi.setFont(self.font2)
        self.tx_fit_roi.setText('-1')
        # self.tx_fit_roi.setValidator(QIntValidator())
        self.tx_fit_roi.setFixedWidth(50)

        self.pb_export_roi_fit = QPushButton('Save ROI fit')
        self.pb_export_roi_fit.setFont(self.font2)
        self.pb_export_roi_fit.clicked.connect(self.export_roi_fit)
        self.pb_export_roi_fit.setEnabled(False)
        self.pb_export_roi_fit.setFixedWidth(105)

        self.chkbox_overlay_ref = QCheckBox('Overlay references')
        self.chkbox_overlay_ref.setFont(self.font2)
        self.chkbox_overlay_ref.setChecked(True)
        self.chkbox_overlay_ref.setFixedWidth(150)

        hbox_plot = QHBoxLayout()
        #hbox_plot.addWidget(self.pb_plot_roi)
        hbox_plot.addWidget(lb_fit_roi)
        hbox_plot.addWidget(self.tx_fit_roi)
        hbox_plot.addWidget(self.chkbox_overlay_ref)
        hbox_plot.setAlignment(QtCore.Qt.AlignTop)

        ############################################
        lb_roi_note = QLabel()
        lb_roi_note.setFont(self.font2)
        lb_roi_note.setText('Note: will fit use the method selection above')
        lb_roi_note.setFixedWidth(350)

        vbox_roi = QVBoxLayout()
        vbox_roi.addWidget(lb_plot_roi)
        vbox_roi.addLayout(hbox_roi_fit)
        vbox_roi.addLayout(hbox_plot)
        vbox_roi.addWidget(lb_roi_note)
        vbox_roi.setAlignment(QtCore.Qt.AlignTop)

        return vbox_roi
        ##########################


    def layout_thresh_mask(self):
        lb_img = QLabel()
        lb_img.setFont(self.font1)
        lb_img.setText('Threshold Mask')
        lb_img.setFixedWidth(150)

        # mask1
        self.pb_mask1 = QPushButton('Gen. Mask1')
        self.pb_mask1.setFont(self.font2)
        self.pb_mask1.clicked.connect(self.generate_mask1)
        self.pb_mask1.setEnabled(True)
        self.pb_mask1.setFixedWidth(105)

        self.tx_mask1 = QLineEdit(self)
        self.tx_mask1.setFont(self.font2)
        self.tx_mask1.setText('<0.1')
        self.tx_mask1.setFixedWidth(50)

        lb_mask1 = QLabel()
        lb_mask1.setFont(self.font2)
        lb_mask1.setText('Thresh: ')
        lb_mask1.setFixedWidth(50)

        self.pb_mask1_rm = QPushButton('Rmv. Mask1')
        self.pb_mask1_rm.setFont(self.font2)
        self.pb_mask1_rm.clicked.connect(self.rm_mask1)
        self.pb_mask1_rm.setEnabled(True)
        self.pb_mask1_rm.setFixedWidth(105)

        hbox_mask1 = QHBoxLayout()
        hbox_mask1.addWidget(self.pb_mask1)
        hbox_mask1.addWidget(lb_mask1)
        hbox_mask1.addWidget(self.tx_mask1)
        hbox_mask1.addWidget(self.pb_mask1_rm)
        hbox_mask1.setAlignment(QtCore.Qt.AlignLeft)

        # mask2
        self.pb_mask2 = QPushButton('Gen. Mask2')
        self.pb_mask2.setFont(self.font2)
        self.pb_mask2.clicked.connect(self.generate_mask2)
        self.pb_mask2.setEnabled(True)
        self.pb_mask2.setFixedWidth(105)

        self.tx_mask2 = QLineEdit(self)
        self.tx_mask2.setFont(self.font2)
        self.tx_mask2.setText('>0.5')
        self.tx_mask2.setFixedWidth(50)

        lb_mask2 = QLabel()
        lb_mask2.setFont(self.font2)
        lb_mask2.setText('Thresh: ')
        lb_mask2.setFixedWidth(50)

        self.pb_mask2_rm = QPushButton('Rmv. Mask2')
        self.pb_mask2_rm.setFont(self.font2)
        self.pb_mask2_rm.clicked.connect(self.rm_mask2)
        self.pb_mask2_rm.setEnabled(True)
        self.pb_mask2_rm.setFixedWidth(105)

        hbox_mask2 = QHBoxLayout()
        hbox_mask2.addWidget(self.pb_mask2)
        hbox_mask2.addWidget(lb_mask2)
        hbox_mask2.addWidget(self.tx_mask2)
        hbox_mask2.addWidget(self.pb_mask2_rm)
        hbox_mask2.setAlignment(QtCore.Qt.AlignLeft)

        # circular mask
        self.pb_mask3 = QPushButton('Circ. Mask')
        self.pb_mask3.setFont(self.font2)
        self.pb_mask3.clicked.connect(self.generate_mask3)
        self.pb_mask3.setEnabled(True)
        self.pb_mask3.setFixedWidth(105)

        self.tx_mask3 = QLineEdit(self)
        self.tx_mask3.setFont(self.font2)
        self.tx_mask3.setText('1.0')
        self.tx_mask3.setFixedWidth(50)

        lb_mask3 = QLabel()
        lb_mask3.setFont(self.font2)
        lb_mask3.setText('Ratio: ')
        lb_mask3.setFixedWidth(50)

        self.pb_mask3_rm = QPushButton('Rmv. Mask3')
        self.pb_mask3_rm.setFont(self.font2)
        self.pb_mask3_rm.clicked.connect(self.rm_mask3)
        self.pb_mask3_rm.setEnabled(True)
        self.pb_mask3_rm.setFixedWidth(105)

        hbox_mask3 = QHBoxLayout()
        hbox_mask3.addWidget(self.pb_mask3)
        hbox_mask3.addWidget(lb_mask3)
        hbox_mask3.addWidget(self.tx_mask3)
        hbox_mask3.addWidget(self.pb_mask3_rm)
        hbox_mask3.setAlignment(QtCore.Qt.AlignLeft)

        vbox_thresh_mask = QVBoxLayout()
        vbox_thresh_mask.addWidget(lb_img)
        vbox_thresh_mask.addLayout(hbox_mask1)
        vbox_thresh_mask.addLayout(hbox_mask2)
        vbox_thresh_mask.addLayout(hbox_mask3)
        vbox_thresh_mask.setAlignment(QtCore.Qt.AlignTop)
        return vbox_thresh_mask

    # otsu threshold
    def layout_otsu_mask(self):
        lb_otsu_mask = QLabel()
        lb_otsu_mask.setFont(self.font1)
        lb_otsu_mask.setText('Auto threshold')
        lb_otsu_mask.setFixedWidth(120)

        self.pb_mask_otsu = QPushButton('Auto thresh')
        self.pb_mask_otsu.setFont(self.font2)
        self.pb_mask_otsu.clicked.connect(self.generate_otsu_mask)
        self.pb_mask_otsu.setEnabled(True)
        self.pb_mask_otsu.setFixedWidth(105)

        self.pb_mask_otsu_rm = QPushButton('Rmv. Mask')
        self.pb_mask_otsu_rm.setFont(self.font2)
        self.pb_mask_otsu_rm.clicked.connect(self.rm_otsu_mask)
        self.pb_mask_otsu_rm.setEnabled(True)
        self.pb_mask_otsu_rm.setFixedWidth(105)


        self.tx_mask_otsu_bin = QLineEdit(self)
        self.tx_mask_otsu_bin.setFont(self.font2)
        self.tx_mask_otsu_bin.setText('256')
        self.tx_mask_otsu_bin.setFixedWidth(50)

        lb_mask_otsu_bin = QLabel()
        lb_mask_otsu_bin.setFont(self.font2)
        lb_mask_otsu_bin.setText('    Bins: ')
        lb_mask_otsu_bin.setFixedWidth(50)


        self.chkbox_mask_otsu = QCheckBox('Keep high inten.')
        self.chkbox_mask_otsu.setFont(self.font2)
        self.chkbox_mask_otsu.setChecked(True)
        self.chkbox_mask_otsu.setFixedWidth(145)

        self.tx_mask_otsu_fz = QLineEdit(self)
        self.tx_mask_otsu_fz.setFont(self.font2)
        self.tx_mask_otsu_fz.setText('3')
        self.tx_mask_otsu_fz.setFixedWidth(50)

        lb_mask_otsu_fz = QLabel()
        lb_mask_otsu_fz.setFont(self.font2)
        lb_mask_otsu_fz.setText('Filt_sz: ')
        lb_mask_otsu_fz.setFixedWidth(50)

        self.tx_mask_otsu_iter = QLineEdit(self)
        self.tx_mask_otsu_iter.setFont(self.font2)
        self.tx_mask_otsu_iter.setText('2')
        self.tx_mask_otsu_iter.setFixedWidth(50)

        lb_mask_otsu_iter = QLabel()
        lb_mask_otsu_iter.setFont(self.font2)
        lb_mask_otsu_iter.setText('    Iter: ')
        lb_mask_otsu_iter.setFixedWidth(50)

        hbox_otsu1 = QHBoxLayout()
        hbox_otsu1.addWidget(self.pb_mask_otsu)
        hbox_otsu1.addWidget(self.pb_mask_otsu_rm)
        hbox_otsu1.addWidget(self.chkbox_mask_otsu)
        hbox_otsu1.setAlignment(QtCore.Qt.AlignLeft)

        hbox_otsu2 = QHBoxLayout()
        hbox_otsu2.addWidget(lb_mask_otsu_fz)
        hbox_otsu2.addWidget(self.tx_mask_otsu_fz)
        hbox_otsu2.addWidget(lb_mask_otsu_iter)
        hbox_otsu2.addWidget(self.tx_mask_otsu_iter)
        hbox_otsu2.addWidget(lb_mask_otsu_bin)
        hbox_otsu2.addWidget(self.tx_mask_otsu_bin)
        hbox_otsu2.setAlignment(QtCore.Qt.AlignLeft)

        vbox_otsu = QVBoxLayout()
        vbox_otsu.addWidget(lb_otsu_mask)
        vbox_otsu.addLayout(hbox_otsu2)
        vbox_otsu.addLayout(hbox_otsu1)
        vbox_otsu.setAlignment(QtCore.Qt.AlignTop)
        return vbox_otsu

    # smart mask
    def layout_smart_mask(self):
        lb_smart_mask = QLabel()
        lb_smart_mask.setFont(self.font1)
        lb_smart_mask.setText('Clustering Mask')
        lb_smart_mask.setFixedWidth(120)

        self.pb_smart_mask = QPushButton('Gen. Mask')
        self.pb_smart_mask.setFont(self.font2)
        self.pb_smart_mask.clicked.connect(self.generate_smart_mask)
        self.pb_smart_mask.setEnabled(True)
        self.pb_smart_mask.setFixedWidth(105)

        self.pb_rem_smart_mask = QPushButton('Rmv. mask')
        self.pb_rem_smart_mask.setFont(self.font2)
        self.pb_rem_smart_mask.clicked.connect(self.rm_smart_mask)
        self.pb_rem_smart_mask.setEnabled(True)
        self.pb_rem_smart_mask.setFixedWidth(105)

        self.pb_add_smart_mask_roi = QPushButton('Add to ROI')
        self.pb_add_smart_mask_roi.setFont(self.font2)
        self.pb_add_smart_mask_roi.clicked.connect(self.add_smart_mask_toi_roi)
        self.pb_add_smart_mask_roi.setEnabled(True)
        self.pb_add_smart_mask_roi.setFixedWidth(105)

        self.pb_apply_smart_mask = QPushButton('Apply mask')
        self.pb_apply_smart_mask.setFont(self.font2)
        self.pb_apply_smart_mask.clicked.connect(self.apply_smart_mask)
        self.pb_apply_smart_mask.setEnabled(True)
        self.pb_apply_smart_mask.setFixedWidth(105)

        self.chkbox_smask = QCheckBox('Use stack')
        self.chkbox_smask.setFont(self.font2)
        self.chkbox_smask.stateChanged.connect(self.smart_mask_use_img_stack)
        self.chkbox_smask.setFixedWidth(105)

        lb_smart_mask_comp = QLabel()
        lb_smart_mask_comp.setFont(self.font2)
        lb_smart_mask_comp.setText('comp #')
        lb_smart_mask_comp.setFixedWidth(50)

        self.tx_smart_mask_comp  = QLineEdit(self)
        self.tx_smart_mask_comp.setFont(self.font2)
        self.tx_smart_mask_comp.setText('2')
        self.tx_smart_mask_comp.setFixedWidth(50)
        self.tx_smart_mask_comp.setValidator(QIntValidator())

        lb_smart_mask_start = QLabel()
        lb_smart_mask_start.setFont(self.font2)
        lb_smart_mask_start.setText('start: ')
        lb_smart_mask_start.setFixedWidth(50)

        self.tx_smart_mask_start = QLineEdit(self)
        self.tx_smart_mask_start.setFont(self.font2)
        self.tx_smart_mask_start.setFixedWidth(50)
        self.tx_smart_mask_start.setValidator(QIntValidator())

        lb_smart_mask_end = QLabel()
        lb_smart_mask_end.setFont(self.font2)
        lb_smart_mask_end.setText('  end: ')
        lb_smart_mask_end.setFixedWidth(50)

        self.tx_smart_mask_end = QLineEdit(self)
        self.tx_smart_mask_end.setFont(self.font2)
        self.tx_smart_mask_end.setFixedWidth(50)
        self.tx_smart_mask_end.setValidator(QIntValidator())

        self.pb_update_img_label = QPushButton('Update Label')
        self.pb_update_img_label.setFont(self.font2)
        self.pb_update_img_label.clicked.connect(self.smart_mask_update_label)
        self.pb_update_img_label.setEnabled(True)
        self.pb_update_img_label.setFixedWidth(105)

        lb_update_img_label = QLabel()
        lb_update_img_label.setFont(self.font2)
        lb_update_img_label.setText('  Label value:')
        lb_update_img_label.setFixedWidth(105)

        self.tx_update_img_label = QLineEdit(self)
        self.tx_update_img_label.setFont(self.font2)
        self.tx_update_img_label.setFixedWidth(105)

        hbox_smart_mask1 = QHBoxLayout()
        # hbox_smart_mask1.addWidget(self.pb_smart_mask)
        hbox_smart_mask1.addWidget(self.chkbox_smask)
        hbox_smart_mask1.addWidget(lb_smart_mask_start)
        hbox_smart_mask1.addWidget(self.tx_smart_mask_start)
        hbox_smart_mask1.addWidget(lb_smart_mask_end)
        hbox_smart_mask1.addWidget(self.tx_smart_mask_end)
        hbox_smart_mask1.setAlignment(QtCore.Qt.AlignLeft)

        hbox_smart_mask2 = QHBoxLayout()
        hbox_smart_mask2.addWidget(self.pb_smart_mask)
        hbox_smart_mask2.addWidget(lb_smart_mask_comp)
        hbox_smart_mask2.addWidget(self.tx_smart_mask_comp)
        hbox_smart_mask2.setAlignment(QtCore.Qt.AlignLeft)

        hbox_smart_mask3 = QHBoxLayout()
        hbox_smart_mask3.addWidget(self.pb_update_img_label)
        hbox_smart_mask3.addWidget(lb_update_img_label)
        hbox_smart_mask3.addWidget(self.tx_update_img_label)
        hbox_smart_mask3.setAlignment(QtCore.Qt.AlignLeft)

        hbox_smart_mask4 = QHBoxLayout()
        #hbox_smart_mask4.addWidget(self.pb_add_smart_mask_roi)
        hbox_smart_mask4.addWidget(self.pb_apply_smart_mask)
        hbox_smart_mask4.addWidget(self.pb_rem_smart_mask)
        hbox_smart_mask4.setAlignment(QtCore.Qt.AlignLeft)

        vbox_smart_mask = QVBoxLayout()
        vbox_smart_mask.addWidget(lb_smart_mask)
        vbox_smart_mask.addLayout(hbox_smart_mask1)
        vbox_smart_mask.addLayout(hbox_smart_mask2)
        vbox_smart_mask.addLayout(hbox_smart_mask3)
        vbox_smart_mask.addLayout(hbox_smart_mask4)
        vbox_smart_mask.setAlignment(QtCore.Qt.AlignTop)

        return vbox_smart_mask

    ## img denoise
    def layout_img_denoise(self):
        lb_img_denoise = QLabel()
        lb_img_denoise.setFont(self.font1)
        lb_img_denoise.setText('Image Denoise')
        lb_img_denoise.setFixedWidth(150)

        # median filter
        self.pb_filt = QPushButton('Median Filter')
        self.pb_filt.setFont(self.font2)
        self.pb_filt.clicked.connect(self.xanes_img_smooth)
        self.pb_filt.setFixedWidth(105)

        lb_filt = QLabel()
        lb_filt.setFont(self.font2)
        lb_filt.setText(' Kernal: ')
        lb_filt.setFixedWidth(50)

        self.tx_filt = QLineEdit(self)
        self.tx_filt.setFont(self.font2)
        self.tx_filt.setText('1')
        self.tx_filt.setValidator(QIntValidator())
        self.tx_filt.setFixedWidth(50)

        hbox_filt = QHBoxLayout()
        hbox_filt.addWidget(self.pb_filt)
        hbox_filt.addWidget(lb_filt)
        hbox_filt.addWidget(self.tx_filt)
        hbox_filt.setAlignment(QtCore.Qt.AlignLeft)

        # noise removal similar to median filter
        self.pb_rm_noise = QPushButton('Median Filter2')
        self.pb_rm_noise.setFont(self.font2)
        self.pb_rm_noise.clicked.connect(self.noise_removal)
        self.pb_rm_noise.setEnabled(True)
        self.pb_rm_noise.setFixedWidth(105)

        self.tx_rm_noise_level = QLineEdit(self)
        self.tx_rm_noise_level.setFont(self.font2)
        self.tx_rm_noise_level.setText('0.02')
        self.tx_rm_noise_level.setFixedWidth(50)
        self.tx_rm_noise_level.setValidator(QDoubleValidator())

        lb_rm_noise_level = QLabel()
        lb_rm_noise_level.setFont(self.font2)
        lb_rm_noise_level.setText('Thresh: ')
        lb_rm_noise_level.setFixedWidth(50)

        self.tx_rm_noise_size = QLineEdit(self)
        self.tx_rm_noise_size.setFont(self.font2)
        self.tx_rm_noise_size.setText('5')
        self.tx_rm_noise_size.setValidator(QIntValidator())
        self.tx_rm_noise_size.setFixedWidth(50)

        lb_rm_noise_size = QLabel()
        lb_rm_noise_size.setFont(self.font2)
        lb_rm_noise_size.setText('Filt_sz: ')
        lb_rm_noise_size.setFixedWidth(50)

        hbox_rm_noise = QHBoxLayout()
        hbox_rm_noise.addWidget(self.pb_rm_noise)
        hbox_rm_noise.addWidget(lb_rm_noise_level)
        hbox_rm_noise.addWidget(self.tx_rm_noise_level)
        hbox_rm_noise.addWidget(lb_rm_noise_size)
        hbox_rm_noise.addWidget(self.tx_rm_noise_size)
        hbox_rm_noise.setAlignment(QtCore.Qt.AlignLeft)

        # non-local mean denoise
        self.pb_rm_noise_nl = QPushButton('Non-local')
        self.pb_rm_noise_nl.setFont(self.font2)
        self.pb_rm_noise_nl.clicked.connect(self.noise_removal_nl)
        self.pb_rm_noise_nl.setEnabled(True)
        self.pb_rm_noise_nl.setFixedWidth(105)

        lb_rm_noise_nl_patch_size = QLabel()
        lb_rm_noise_nl_patch_size.setFont(self.font2)
        lb_rm_noise_nl_patch_size.setText('Filt_sz: ')
        lb_rm_noise_nl_patch_size.setFixedWidth(50)

        self.tx_rm_noise_nl_patch_size = QLineEdit(self)
        self.tx_rm_noise_nl_patch_size.setFont(self.font2)
        self.tx_rm_noise_nl_patch_size.setText('5')
        self.tx_rm_noise_nl_patch_size.setFixedWidth(50)
        self.tx_rm_noise_nl_patch_size.setValidator(QIntValidator())

        lb_rm_noise_size_nl_patch_dis = QLabel()
        lb_rm_noise_size_nl_patch_dis.setFont(self.font2)
        lb_rm_noise_size_nl_patch_dis.setText('Filt_dis: ')
        lb_rm_noise_size_nl_patch_dis.setFixedWidth(50)

        self.tx_rm_noise_nl_patch_dis = QLineEdit(self)
        self.tx_rm_noise_nl_patch_dis.setFont(self.font2)
        self.tx_rm_noise_nl_patch_dis.setText('6')
        self.tx_rm_noise_nl_patch_dis.setValidator(QIntValidator())
        self.tx_rm_noise_nl_patch_dis.setFixedWidth(50)

        hbox_rm_noise_nl = QHBoxLayout()
        hbox_rm_noise_nl.addWidget(self.pb_rm_noise_nl)
        hbox_rm_noise_nl.addWidget(lb_rm_noise_size_nl_patch_dis)
        hbox_rm_noise_nl.addWidget(self.tx_rm_noise_nl_patch_dis)
        hbox_rm_noise_nl.addWidget(lb_rm_noise_nl_patch_size)
        hbox_rm_noise_nl.addWidget(self.tx_rm_noise_nl_patch_size)
        hbox_rm_noise_nl.setAlignment(QtCore.Qt.AlignLeft)

        vbox_denoise = QVBoxLayout()
        vbox_denoise.addWidget(lb_img_denoise)
        vbox_denoise.addLayout(hbox_filt)
        vbox_denoise.addLayout(hbox_rm_noise)
        vbox_denoise.addLayout(hbox_rm_noise_nl)
        return vbox_denoise

    # binary morphology
    def layout_binary_morpholog(self):
        lb_binary = QLabel()
        lb_binary.setFont(self.font1)
        lb_binary.setText('Binary morphology')
        lb_binary.setFixedWidth(150)
        # dilation
        lb_dilation = QLabel()
        lb_dilation.setFont(self.font2)
        lb_dilation.setText(' Mask Dilation: ')
        lb_dilation.setFixedWidth(105)

        lb_dilation_iter = QLabel()
        lb_dilation_iter.setFont(self.font2)
        lb_dilation_iter.setText('Iter(s): ')
        lb_dilation_iter.setFixedWidth(50)

        self.tx_dilation_iter = QLineEdit(self)
        self.tx_dilation_iter.setFont(self.font2)
        self.tx_dilation_iter.setText('2')
        self.tx_dilation_iter.setValidator(QIntValidator())
        self.tx_dilation_iter.setFixedWidth(50)

        self.pb_dilation = QPushButton('Dilation')
        self.pb_dilation.setFont(self.font2)
        self.pb_dilation.clicked.connect(self.mask_dilation)
        self.pb_dilation.setEnabled(True)
        self.pb_dilation.setFixedWidth(105)

        hbox_dilation = QHBoxLayout()
        hbox_dilation.addWidget(lb_dilation)
        hbox_dilation.addWidget(lb_dilation_iter)
        hbox_dilation.addWidget(self.tx_dilation_iter)
        hbox_dilation.addWidget(self.pb_dilation)
        hbox_dilation.setAlignment(QtCore.Qt.AlignTop)

        # erosion
        lb_erosion = QLabel()
        lb_erosion.setFont(self.font2)
        lb_erosion.setText(' Mask Erosion: ')
        lb_erosion.setFixedWidth(105)

        lb_erosion_iter = QLabel()
        lb_erosion_iter.setFont(self.font2)
        lb_erosion_iter.setText('Iter(s): ')
        lb_erosion_iter.setFixedWidth(50)

        self.tx_erosion_iter = QLineEdit(self)
        self.tx_erosion_iter.setFont(self.font2)
        self.tx_erosion_iter.setText('2')
        self.tx_erosion_iter.setValidator(QIntValidator())
        self.tx_erosion_iter.setFixedWidth(50)

        self.pb_erosion = QPushButton('Erosion')
        self.pb_erosion.setFont(self.font2)
        self.pb_erosion.clicked.connect(self.mask_erosion)
        self.pb_erosion.setEnabled(True)
        self.pb_erosion.setFixedWidth(105)

        hbox_erosion = QHBoxLayout()
        hbox_erosion.addWidget(lb_erosion)
        hbox_erosion.addWidget(lb_erosion_iter)
        hbox_erosion.addWidget(self.tx_erosion_iter)
        hbox_erosion.addWidget(self.pb_erosion)
        hbox_erosion.setAlignment(QtCore.Qt.AlignTop)

        # fill hole
        lb_fhole = QLabel()
        lb_fhole.setFont(self.font2)
        lb_fhole.setText(' Mask fill-hole: ')
        lb_fhole.setFixedWidth(105)

        lb_fhole_iter = QLabel()
        lb_fhole_iter.setFont(self.font2)
        lb_fhole_iter.setText('Iter(s): ')
        lb_fhole_iter.setFixedWidth(50)

        self.tx_fhole_iter_iter = QLineEdit(self)
        self.tx_fhole_iter_iter.setFont(self.font2)
        self.tx_fhole_iter_iter.setText('2')
        self.tx_fhole_iter_iter.setValidator(QIntValidator())
        self.tx_fhole_iter_iter.setFixedWidth(50)

        self.pb_fhole = QPushButton('Fill-hole')
        self.pb_fhole.setFont(self.font2)
        self.pb_fhole.clicked.connect(self.mask_fillhole)
        self.pb_fhole.setEnabled(True)
        self.pb_fhole.setFixedWidth(105)

        hbox_fhole = QHBoxLayout()
        hbox_fhole.addWidget(lb_fhole)
        hbox_fhole.addWidget(lb_fhole_iter)
        hbox_fhole.addWidget(self.tx_fhole_iter_iter)
        hbox_fhole.addWidget(self.pb_fhole)
        hbox_fhole.setAlignment(QtCore.Qt.AlignTop)

        vbox_binary_morphology = QVBoxLayout()
        vbox_binary_morphology.addWidget(lb_binary)
        vbox_binary_morphology.addLayout(hbox_dilation)
        vbox_binary_morphology.addLayout(hbox_erosion)
        vbox_binary_morphology.addLayout(hbox_fhole)
        vbox_binary_morphology.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_binary_morphology

    def layout_img_tools_mask(self):
        lb_empty = QLabel()

        vbox_thresh_mask = self.layout_thresh_mask()
        vbox_otsu_mask = self.layout_otsu_mask()
        vbox_smart_mask = self.layout_smart_mask()
        vbox_img_denoise = self.layout_img_denoise()
        vbox_binary_morphology = self.layout_binary_morpholog()
        #vbox_colormix = self.layout_colormix()

        # assemble
        vbox_img_assemble = QVBoxLayout()
        vbox_img_assemble.addLayout(vbox_otsu_mask)
        vbox_img_assemble.addWidget(lb_empty)
        vbox_img_assemble.addLayout(vbox_thresh_mask)
        vbox_img_assemble.addWidget(lb_empty)
        vbox_img_assemble.addLayout(vbox_smart_mask)
        vbox_img_assemble.addWidget(lb_empty)
        vbox_img_assemble.addLayout(vbox_img_denoise)
        vbox_img_assemble.addWidget(lb_empty)
        vbox_img_assemble.addLayout(vbox_binary_morphology)
        vbox_img_assemble.addWidget(lb_empty)

        #vbox_img_assemble.addLayout(vbox_colormix)

        #vbox_img_assemble.addWidget(lb_empty)
        vbox_img_assemble.setAlignment(QtCore.Qt.AlignTop)
        return vbox_img_assemble

    def layout_colormix(self):
        lb_empty = QLabel()
        # colormix
        lb_img_colormix = QLabel()
        lb_img_colormix.setFont(self.font1)
        lb_img_colormix.setText('Colormix')
        lb_img_colormix.setFixedWidth(150)

        lb_colormix = QLabel()
        lb_colormix.setFont(self.font2)
        lb_colormix.setText(' Color Mix: ')
        lb_colormix.setFixedWidth(105)

        self.pb_colormix = QPushButton('Color Mix')
        self.pb_colormix.setFont(self.font2)
        self.pb_colormix.clicked.connect(self.xanes_colormix)
        self.pb_colormix.setEnabled(True)
        self.pb_colormix.setFixedWidth(105)

        lb_fit_color = QLabel()
        lb_fit_color.setFont(self.font2)
        lb_fit_color.setText('Color: ')
        lb_fit_color.setFixedWidth(50)

        self.tx_fit_color = QLineEdit(self)
        self.tx_fit_color.setFont(self.font2)
        self.tx_fit_color.setText('r, g, b')
        self.tx_fit_color.setFixedWidth(50)

        hbox_colormix = QHBoxLayout()
        hbox_colormix.addWidget(lb_colormix)
        hbox_colormix.addWidget(lb_fit_color)
        hbox_colormix.addWidget(self.tx_fit_color)
        hbox_colormix.addWidget(self.pb_colormix)
        hbox_colormix.setAlignment(QtCore.Qt.AlignTop)

        # color channel
        lb_color_channel = QLabel()
        lb_color_channel.setFont(self.font2)
        lb_color_channel.setText(' Color Channel:')
        lb_color_channel.setFixedWidth(105)

        self.cb_color_channel = QComboBox()
        self.cb_color_channel.setFont(self.font2)
        self.cb_color_channel.setFixedWidth(50)

        self.tx_color_scale = QLineEdit(self)
        self.tx_color_scale.setFont(self.font2)
        self.tx_color_scale.setText('1.0')
        self.tx_color_scale.setFixedWidth(50)

        self.pb_color_scale = QPushButton('Apply')
        self.pb_color_scale.setFont(self.font2)
        self.pb_color_scale.clicked.connect(self.xanes_colormix)
        self.pb_color_scale.setFixedWidth(55)

        self.pb_color_scale_up = QPushButton('>')
        self.pb_color_scale_up.setFont(self.font2)
        self.pb_color_scale_up.clicked.connect(self.xanes_color_scale_up)
        self.pb_color_scale_up.setFixedWidth(20)

        self.pb_color_scale_down = QPushButton('<')
        self.pb_color_scale_down.setFont(self.font2)
        self.pb_color_scale_down.clicked.connect(self.xanes_color_scale_down)
        self.pb_color_scale_down.setFixedWidth(20)

        hbox_color_channel = QHBoxLayout()
        hbox_color_channel.addWidget(lb_color_channel)
        hbox_color_channel.addWidget(self.cb_color_channel)
        hbox_color_channel.addWidget(self.pb_color_scale_down)
        hbox_color_channel.addWidget(self.tx_color_scale)
        hbox_color_channel.addWidget(self.pb_color_scale_up)
        hbox_color_channel.addWidget(self.pb_color_scale)
        hbox_color_channel.setAlignment(QtCore.Qt.AlignTop)

        vbox_batch_color = self.layout_colormix_batch()

        vbox_color = QVBoxLayout()
        vbox_color.addWidget(lb_img_colormix)
        vbox_color.addLayout(hbox_colormix)
        vbox_color.addLayout(hbox_color_channel)
        vbox_color.addWidget(lb_empty)
        vbox_color.addLayout(vbox_batch_color)
        vbox_color.setAlignment(QtCore.Qt.AlignTop)
        return vbox_color

    def layout_colormix_batch(self):
        lb_colormix_batch = QLabel()
        lb_colormix_batch.setFont(self.font1)
        lb_colormix_batch.setText('Batch colormix ')
        lb_colormix_batch.setFixedWidth(120)

        lb_file = QLabel()
        lb_file.setText('File path:')
        lb_file.setFixedWidth(60)
        lb_file.setFont(self.font2)

        self.tx_batch_color_folder = QLineEdit()
        self.tx_batch_color_folder.setFixedWidth(230)
        self.tx_batch_color_folder.setFont(self.font2)

        self.pb_batch_color_open = QPushButton('Open')
        self.pb_batch_color_open.setFont(self.font2)
        self.pb_batch_color_open.setFixedWidth(80)
        self.pb_batch_color_open.clicked.connect(self.batch_colormix_open_file)

        hbox_batch_color_open = QHBoxLayout()
        hbox_batch_color_open.addWidget(lb_file)
        hbox_batch_color_open.addWidget(self.tx_batch_color_folder)
        hbox_batch_color_open.addWidget(self.pb_batch_color_open)
        hbox_batch_color_open.setAlignment(QtCore.Qt.AlignLeft)

        lb_batch_color = QLabel()
        lb_batch_color.setFont(self.font2)
        lb_batch_color.setText('   Colors:')
        lb_batch_color.setFixedWidth(60)

        self.tx_batch_color = QLineEdit(self)
        self.tx_batch_color.setFont(self.font2)
        self.tx_batch_color.setText('r, g, b')
        self.tx_batch_color.setFixedWidth(80)

        lb_batch_color_cmin = QLabel()
        lb_batch_color_cmin.setFont(self.font2)
        lb_batch_color_cmin.setText('CMin:')
        lb_batch_color_cmin.setFixedWidth(60)

        self.tx_batch_color_cmin = QLineEdit(self)
        self.tx_batch_color_cmin.setFont(self.font2)
        self.tx_batch_color_cmin.setText('0')
        self.tx_batch_color_cmin.setFixedWidth(50)
        self.tx_batch_color_cmin.setValidator(QDoubleValidator())

        lb_batch_color_cmax = QLabel()
        lb_batch_color_cmax.setFont(self.font2)
        lb_batch_color_cmax.setText('  CMax:')
        lb_batch_color_cmax.setFixedWidth(50)

        self.tx_batch_color_cmax = QLineEdit(self)
        self.tx_batch_color_cmax.setFont(self.font2)
        self.tx_batch_color_cmax.setText('1')
        self.tx_batch_color_cmax.setFixedWidth(50)
        self.tx_batch_color_cmax.setValidator(QDoubleValidator())

        hbox_batch_color = QHBoxLayout()
        hbox_batch_color.addWidget(lb_batch_color_cmin)
        hbox_batch_color.addWidget(self.tx_batch_color_cmin)
        hbox_batch_color.addWidget(lb_batch_color_cmax)
        hbox_batch_color.addWidget(self.tx_batch_color_cmax)
        hbox_batch_color.addWidget(lb_batch_color)
        hbox_batch_color.addWidget(self.tx_batch_color)
        hbox_batch_color.setAlignment(QtCore.Qt.AlignLeft)

        self.pb_batch_color = QPushButton('Batch colormix (Tiff only)')
        self.pb_batch_color.setFixedWidth(200)
        self.pb_batch_color.setFont(self.font2)
        self.pb_batch_color.clicked.connect(self.batch_colormix)

        self.lb_batch_color_msg = QLabel()
        self.lb_batch_color_msg.setFont(self.font2)
        self.lb_batch_color_msg.setStyleSheet('color: rgb(200, 50, 50);')

        vbox_batch_color = QVBoxLayout()
        vbox_batch_color.addWidget(lb_colormix_batch)
        vbox_batch_color.addLayout(hbox_batch_color_open)
        vbox_batch_color.addLayout(hbox_batch_color)
        vbox_batch_color.addWidget(self.pb_batch_color)
        vbox_batch_color.addWidget(self.lb_batch_color_msg)
        vbox_batch_color.setAlignment(QtCore.Qt.AlignTop)

        return vbox_batch_color

    def layout_multi_elem(self):
        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(15)
        multi_elem_2D = self.layout_multi_elem_2D()
        multi_elem_batch = self.layout_multi_elem_batch()
        vbox = QVBoxLayout()
        vbox.addLayout(multi_elem_2D)
        vbox.addWidget(lb_empty1)
        vbox.addLayout(multi_elem_batch)
        vbox.setAlignment(QtCore.Qt.AlignTop)
        return vbox


    def layout_multi_elem_2D(self):
        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(5)

        lb_empty2 = QLabel()
        lb_empty2.setFixedHeight(5)

        lb_empty3 = QLabel()
        lb_empty3.setFixedHeight(5)

        lb_empty4 = QLabel()
        lb_empty4.setFixedHeight(5)

        lb_multi_eng = QLabel()
        lb_multi_eng.setFont(self.font1)
        lb_multi_eng.setText('Fit thickness')
        lb_multi_eng.setFixedWidth(300)

        lb_multi_elem = QLabel()
        lb_multi_elem.setFont(self.font2)
        lb_multi_elem.setText('Elements to fit (e.g., Ni, Co, Mn)')
        lb_multi_elem.setFixedWidth(300)

        lb_multi_elem_rho = QLabel()
        lb_multi_elem_rho.setFont(self.font2)
        lb_multi_elem_rho.setText('Elements density (g/cm3, e.g., 5.7, 8.9)')
        lb_multi_elem_rho.setFixedWidth(300)

        lb_multi_exclude_eng = QLabel()
        lb_multi_exclude_eng.setFont(self.font2)
        lb_multi_exclude_eng.setText('Exclude energy (e.g., [6.5, 6.8], [8.3, 8.4])')
        lb_multi_exclude_eng.setFixedWidth(300)

        self.tx_multi_elem = QLineEdit()
        self.tx_multi_elem.setFont(self.font2)
        self.tx_multi_elem.setFixedWidth(340)

        self.tx_multi_elem_rho = QLineEdit()
        self.tx_multi_elem_rho.setFont(self.font2)
        self.tx_multi_elem_rho.setFixedWidth(340)

        self.tx_multi_exclude_eng = QLineEdit()
        self.tx_multi_exclude_eng.setFont(self.font2)
        self.tx_multi_exclude_eng.setFixedWidth(340)

        self.pb_multi_elem_fit = QPushButton('Fit thickness')
        self.pb_multi_elem_fit.setFont(self.font2)
        self.pb_multi_elem_fit.setFixedWidth(120)
        self.pb_multi_elem_fit.clicked.connect(self.fit_multi_elem_thickness)

        self.pb_multi_elem_save = QPushButton('Save fit results')
        self.pb_multi_elem_save.setFont(self.font2)
        self.pb_multi_elem_save.setFixedWidth(120)
        self.pb_multi_elem_save.clicked.connect(self.save_multi_elem_thickness)

        # method
        lb_multi_param_fit_method = QLabel()
        lb_multi_param_fit_method.setText('Fitting method: ')
        lb_multi_param_fit_method.setFixedWidth(120)
        lb_multi_param_fit_method.setFont(self.font1)

        self.rd_multi_param_fit_method1 = QRadioButton('Basic')
        self.rd_multi_param_fit_method1.setFixedWidth(120)
        self.rd_multi_param_fit_method1.setFont(self.font2)
        self.rd_multi_param_fit_method1.setChecked(True)

        self.rd_multi_param_fit_method3 = QRadioButton('NN-ADMM')
        self.rd_multi_param_fit_method3.setFixedWidth(120)
        self.rd_multi_param_fit_method3.setFont(self.font2)
        self.rd_multi_param_fit_method3.setChecked(False)
        self.rd_multi_param_fit_method3.toggled.connect(self.select_2d_multi_elem_fitting_method)

        hbox_multi_fit_method = QHBoxLayout()
        hbox_multi_fit_method.addWidget(lb_multi_param_fit_method)
        hbox_multi_fit_method.addWidget(self.rd_multi_param_fit_method1)
        hbox_multi_fit_method.addWidget(self.rd_multi_param_fit_method3)
        hbox_multi_fit_method.setAlignment(QtCore.Qt.AlignLeft)
        #############################################
        lb_multi_iter_num = QLabel()
        lb_multi_iter_num.setFont(self.font2)
        lb_multi_iter_num.setText('Maximum iteration:')
        lb_multi_iter_num.setFixedWidth(140)

        self.tx_multi_iter_num = QLineEdit(self)
        self.tx_multi_iter_num.setFont(self.font2)
        self.tx_multi_iter_num.setText('100')
        self.tx_multi_iter_num.setValidator(QIntValidator())
        self.tx_multi_iter_num.setFixedWidth(100)
        self.tx_multi_iter_num.setEnabled(False)

        hbox_multi_fit_iter_num = QHBoxLayout()
        hbox_multi_fit_iter_num.addWidget(lb_multi_iter_num)
        hbox_multi_fit_iter_num.addWidget(self.tx_multi_iter_num)
        hbox_multi_fit_iter_num.setAlignment(QtCore.Qt.AlignTop)

        ##############################################
        lb_multi_fit_rate = QLabel()
        lb_multi_fit_rate.setFont(self.font2)
        lb_multi_fit_rate.setText('Denoise level:')
        lb_multi_fit_rate.setFixedWidth(140)

        self.tx_multi_fit_rate = QLineEdit(self)
        self.tx_multi_fit_rate.setFont(self.font2)
        self.tx_multi_fit_rate.setText('0.2')  # conjugate gradient updating rate
        self.tx_multi_fit_rate.setValidator(QDoubleValidator())
        self.tx_multi_fit_rate.setFixedWidth(100)
        self.tx_multi_fit_rate.setEnabled(False)

        hbox_multi_fit_iter_rate = QHBoxLayout()
        hbox_multi_fit_iter_rate.addWidget(lb_multi_fit_rate)
        hbox_multi_fit_iter_rate.addWidget(self.tx_multi_fit_rate)
        hbox_multi_fit_iter_rate.setAlignment(QtCore.Qt.AlignTop)
        ########################

        lb_multi_fit_sigma = QLabel()
        lb_multi_fit_sigma.setFont(self.font2)
        lb_multi_fit_sigma.setText('Sigma:')
        lb_multi_fit_sigma.setFixedWidth(140)

        self.tx_multi_fit_sigma = QLineEdit(self)
        self.tx_multi_fit_sigma.setFont(self.font2)
        self.tx_multi_fit_sigma.setText('0.1')  # conjugate gradient updating rate
        self.tx_multi_fit_sigma.setValidator(QDoubleValidator())
        self.tx_multi_fit_sigma.setFixedWidth(100)
        self.tx_multi_fit_sigma.setEnabled(False)

        hbox_multi_fit_iter_sigma = QHBoxLayout()
        hbox_multi_fit_iter_sigma.addWidget(lb_multi_fit_sigma)
        hbox_multi_fit_iter_sigma.addWidget(self.tx_multi_fit_sigma)
        hbox_multi_fit_iter_sigma.setAlignment(QtCore.Qt.AlignTop)
        ########################

        # elem
        self.pb_multi_elem_ni = QPushButton('Ni')
        self.pb_multi_elem_ni.setFont(self.font2)
        self.pb_multi_elem_ni.setFixedWidth(60)
        self.pb_multi_elem_ni.clicked.connect(lambda: self.add_multi_elem('Ni'))

        self.pb_multi_elem_co = QPushButton('Co')
        self.pb_multi_elem_co.setFont(self.font2)
        self.pb_multi_elem_co.setFixedWidth(60)
        self.pb_multi_elem_co.clicked.connect(lambda: self.add_multi_elem('Co'))

        self.pb_multi_elem_mn = QPushButton('Mn')
        self.pb_multi_elem_mn.setFont(self.font2)
        self.pb_multi_elem_mn.setFixedWidth(60)
        self.pb_multi_elem_mn.clicked.connect(lambda: self.add_multi_elem('Mn'))

        self.pb_multi_elem_fe = QPushButton('Fe')
        self.pb_multi_elem_fe.setFont(self.font2)
        self.pb_multi_elem_fe.setFixedWidth(60)
        self.pb_multi_elem_fe.clicked.connect(lambda: self.add_multi_elem('Fe'))


        hbox_fit_elem = QHBoxLayout()
        hbox_fit_elem.addWidget(self.pb_multi_elem_mn)
        hbox_fit_elem.addWidget(self.pb_multi_elem_fe)
        hbox_fit_elem.addWidget(self.pb_multi_elem_co)
        hbox_fit_elem.addWidget(self.pb_multi_elem_ni)
        hbox_fit_elem.setAlignment(QtCore.Qt.AlignLeft)

        self.pb_multi_range_ni = QPushButton('[8.3, 8.5]')
        self.pb_multi_range_ni.setFont(self.font2)
        self.pb_multi_range_ni.setFixedWidth(80)
        self.pb_multi_range_ni.clicked.connect(lambda: self.add_multi_range('[8.3, 8.5]'))

        self.pb_multi_range_co = QPushButton('[7.7, 7.9]')
        self.pb_multi_range_co.setFont(self.font2)
        self.pb_multi_range_co.setFixedWidth(80)
        self.pb_multi_range_co.clicked.connect(lambda: self.add_multi_range('[7.7, 7.9]'))

        self.pb_multi_range_fe = QPushButton('[7.1, 7.3]')
        self.pb_multi_range_fe.setFont(self.font2)
        self.pb_multi_range_fe.setFixedWidth(80)
        self.pb_multi_range_fe.clicked.connect(lambda: self.add_multi_range('[7.1, 7.3]'))

        self.pb_multi_range_mn = QPushButton('[6.5, 6.7]')
        self.pb_multi_range_mn.setFont(self.font2)
        self.pb_multi_range_mn.setFixedWidth(80)
        self.pb_multi_range_mn.clicked.connect(lambda: self.add_multi_range('[6.5, 6.7]'))

        hbox_multi_elem_add = QHBoxLayout()
        hbox_multi_elem_add.addWidget(self.pb_multi_range_mn)
        hbox_multi_elem_add.addWidget(self.pb_multi_range_fe)
        hbox_multi_elem_add.addWidget(self.pb_multi_range_co)
        hbox_multi_elem_add.addWidget(self.pb_multi_range_ni)
        hbox_multi_elem_add.setAlignment(QtCore.Qt.AlignLeft)

        hbox_multi_elem_range = self.layout_multi_elem_eng_range()
        layout_multi_elem_bkg = self.layout_multi_elem_bkg()
        layout_multi_elem_roi = self.layout_multi_elem_roi()

        hbox = QHBoxLayout()
        hbox.addWidget(self.pb_multi_elem_fit)
        hbox.addWidget(self.pb_multi_elem_save)
        hbox.setAlignment(QtCore.Qt.AlignLeft)

        vbox = QVBoxLayout()

        vbox.addLayout(hbox_multi_fit_method)
        vbox.addLayout(hbox_multi_fit_iter_num)
        vbox.addLayout(hbox_multi_fit_iter_rate)
        vbox.addLayout(hbox_multi_fit_iter_sigma)
        vbox.addLayout(hbox)
        vbox.setAlignment(QtCore.Qt.AlignTop)

        vbox_multi_elem = QVBoxLayout()
        vbox_multi_elem.addWidget(lb_multi_eng)
        vbox_multi_elem.addLayout(hbox_multi_elem_range)
        vbox_multi_elem.addWidget(lb_empty1)
        vbox_multi_elem.addWidget(lb_multi_elem)
        vbox_multi_elem.addWidget(self.tx_multi_elem)
        #vbox_multi_elem.addWidget(lb_multi_elem_rho)
        #vbox_multi_elem.addWidget(self.tx_multi_elem_rho)
        vbox_multi_elem.addLayout(hbox_fit_elem)
        vbox_multi_elem.addWidget(lb_empty2)
        vbox_multi_elem.addWidget(lb_multi_exclude_eng)
        vbox_multi_elem.addWidget(self.tx_multi_exclude_eng)
        vbox_multi_elem.addLayout(hbox_multi_elem_add)
        vbox_multi_elem.addWidget(lb_empty3)
        vbox_multi_elem.addLayout(layout_multi_elem_bkg)
        vbox_multi_elem.addWidget(lb_empty4)
        vbox_multi_elem.addLayout(vbox)
        vbox_multi_elem.addLayout(layout_multi_elem_roi)
        vbox_multi_elem.setAlignment(QtCore.Qt.AlignTop)

        return vbox_multi_elem


    def layout_multi_elem_batch(self):
        # open file
        lb_batch = QLabel()
        lb_batch.setText('Batch fit')
        lb_batch.setFixedWidth(80)
        lb_batch.setFont(self.font1)

        lb_file = QLabel()
        lb_file.setText('File path:')
        lb_file.setFixedWidth(70)
        lb_file.setFont(self.font2)

        self.tx_multi_elem_folder = QLineEdit()
        self.tx_multi_elem_folder.setFixedWidth(230)
        self.tx_multi_elem_folder.setFont(self.font2)

        self.pb_mulit_elem_open = QPushButton('Open')
        self.pb_mulit_elem_open.setFont(self.font2)
        self.pb_mulit_elem_open.setFixedWidth(80)
        self.pb_mulit_elem_open.clicked.connect(self.open_file_multi_elem)

        hbox_multi_elem_open = QHBoxLayout()
        hbox_multi_elem_open.addWidget(lb_file)
        hbox_multi_elem_open.addWidget(self.tx_multi_elem_folder)
        hbox_multi_elem_open.addWidget(self.pb_mulit_elem_open)
        hbox_multi_elem_open.setAlignment(QtCore.Qt.AlignLeft)

        # align image
        self.chkbox_multi_elem_align = QCheckBox('Align:')
        self.chkbox_multi_elem_align.setFixedWidth(75)
        self.chkbox_multi_elem_align.setFont(self.font2)
        self.chkbox_multi_elem_align.setChecked(False)

        self.cb_multi_elem_ali = QComboBox()
        self.cb_multi_elem_ali.setFont(self.font2)
        self.cb_multi_elem_ali.addItem('T')
        self.cb_multi_elem_ali.addItem('R')
        self.cb_multi_elem_ali.setFixedWidth(40)

        lb_multi_elem_align_roi = QLabel()
        lb_multi_elem_align_roi.setFont(self.font2)
        lb_multi_elem_align_roi.setText('ROI ID:')
        lb_multi_elem_align_roi.setFixedWidth(60)

        self.tx_multi_elem_align_roi = QLineEdit()
        self.tx_multi_elem_align_roi.setText('-1')
        self.tx_multi_elem_align_roi.setFont(self.font2)
        self.tx_multi_elem_align_roi.setFixedWidth(50)
        self.tx_multi_elem_align_roi.setValidator(QIntValidator())

        lb_multi_elem_align_ref = QLabel()
        lb_multi_elem_align_ref.setFont(self.font2)
        lb_multi_elem_align_ref.setText('Ref. ID:')
        lb_multi_elem_align_ref.setFixedWidth(60)

        self.tx_multi_elem_align_ref = QLineEdit()
        self.tx_multi_elem_align_ref.setText('-1')
        self.tx_multi_elem_align_ref.setFont(self.font2)
        self.tx_multi_elem_align_ref.setFixedWidth(50)
        self.tx_multi_elem_align_ref.setValidator(QIntValidator())

        hbox_multi_elem_align = QHBoxLayout()
        hbox_multi_elem_align.addWidget(self.chkbox_multi_elem_align)
        hbox_multi_elem_align.addWidget(self.cb_multi_elem_ali)
        hbox_multi_elem_align.addWidget(lb_multi_elem_align_roi)
        hbox_multi_elem_align.addWidget(self.tx_multi_elem_align_roi)
        hbox_multi_elem_align.addWidget(lb_multi_elem_align_ref)
        hbox_multi_elem_align.addWidget(self.tx_multi_elem_align_ref)
        hbox_multi_elem_align.setAlignment(QtCore.Qt.AlignLeft)

        # Non-local mean denoise
        self.chkbox_multi_elem_denoise = QCheckBox('NL Denoise:')
        self.chkbox_multi_elem_denoise.setFixedWidth(120)
        self.chkbox_multi_elem_denoise.setFont(self.font2)
        self.chkbox_multi_elem_denoise.setChecked(False)

        lb_mulit_elem_nl_patch_size = QLabel()
        lb_mulit_elem_nl_patch_size.setFont(self.font2)
        lb_mulit_elem_nl_patch_size.setText('Filt_sz: ')
        lb_mulit_elem_nl_patch_size.setFixedWidth(60)

        self.tx_mulit_elem_nl_patch_size = QLineEdit(self)
        self.tx_mulit_elem_nl_patch_size.setFont(self.font2)
        self.tx_mulit_elem_nl_patch_size.setText('5')
        self.tx_mulit_elem_nl_patch_size.setFixedWidth(50)
        self.tx_mulit_elem_nl_patch_size.setValidator(QIntValidator())

        lb_multi_elem_nl_patch_dis = QLabel()
        lb_multi_elem_nl_patch_dis.setFont(self.font2)
        lb_multi_elem_nl_patch_dis.setText('Filt_dis: ')
        lb_multi_elem_nl_patch_dis.setFixedWidth(60)

        self.tx_multi_elem_nl_patch_dis = QLineEdit(self)
        self.tx_multi_elem_nl_patch_dis.setFont(self.font2)
        self.tx_multi_elem_nl_patch_dis.setText('6')
        self.tx_multi_elem_nl_patch_dis.setValidator(QIntValidator())
        self.tx_multi_elem_nl_patch_dis.setFixedWidth(50)

        hbox_multi_elem_nl = QHBoxLayout()
        hbox_multi_elem_nl.addWidget(self.chkbox_multi_elem_denoise)
        hbox_multi_elem_nl.addWidget(lb_mulit_elem_nl_patch_size)
        hbox_multi_elem_nl.addWidget(self.tx_mulit_elem_nl_patch_size)
        hbox_multi_elem_nl.addWidget(lb_multi_elem_nl_patch_dis)
        hbox_multi_elem_nl.addWidget(self.tx_multi_elem_nl_patch_dis)
        hbox_multi_elem_nl.setAlignment(QtCore.Qt.AlignLeft)

        ##########
        # median filter
        self.chkbox_multi_elem_mf = QCheckBox('Median filter:')
        self.chkbox_multi_elem_mf.setFixedWidth(120)
        self.chkbox_multi_elem_mf.setFont(self.font2)
        self.chkbox_multi_elem_mf.setChecked(False)

        lb_mulit_elem_ml_size = QLabel()
        lb_mulit_elem_ml_size.setFont(self.font2)
        lb_mulit_elem_ml_size.setText('Filt_sz: ')
        lb_mulit_elem_ml_size.setFixedWidth(60)

        self.tx_mulit_elem_ml_size = QLineEdit(self)
        self.tx_mulit_elem_ml_size.setFont(self.font2)
        self.tx_mulit_elem_ml_size.setText('5')
        self.tx_mulit_elem_ml_size.setFixedWidth(50)
        self.tx_mulit_elem_ml_size.setValidator(QIntValidator())


        hbox_multi_elem_mf = QHBoxLayout()
        hbox_multi_elem_mf.addWidget(self.chkbox_multi_elem_mf)
        hbox_multi_elem_mf.addWidget(lb_mulit_elem_ml_size)
        hbox_multi_elem_mf.addWidget(self.tx_mulit_elem_ml_size)
        hbox_multi_elem_mf.addWidget(lb_multi_elem_nl_patch_dis)
        hbox_multi_elem_mf.setAlignment(QtCore.Qt.AlignLeft)


        ##########


        # cluster mask
        self.chkbox_multi_elem_cmask = QCheckBox('Cluster Mask:')
        self.chkbox_multi_elem_cmask.setFixedWidth(120)
        self.chkbox_multi_elem_cmask.setFont(self.font2)
        self.chkbox_multi_elem_cmask.setChecked(False)

        lb_mulit_elem_cmask_roi = QLabel()
        lb_mulit_elem_cmask_roi.setFont(self.font2)
        lb_mulit_elem_cmask_roi.setText('ROI ID: ')
        lb_mulit_elem_cmask_roi.setFixedWidth(60)

        self.tx_mulit_elem_cmask_roi = QLineEdit(self)
        self.tx_mulit_elem_cmask_roi.setFont(self.font2)
        self.tx_mulit_elem_cmask_roi.setText('-1')
        self.tx_mulit_elem_cmask_roi.setFixedWidth(50)
        self.tx_mulit_elem_cmask_roi.setValidator(QIntValidator())

        lb_mulit_elem_cmask = QLabel()
        lb_mulit_elem_cmask.setFont(self.font2)
        lb_mulit_elem_cmask.setText('Comp. #: ')
        lb_mulit_elem_cmask.setFixedWidth(60)

        self.tx_mulit_elem_cmask = QLineEdit(self)
        self.tx_mulit_elem_cmask.setFont(self.font2)
        self.tx_mulit_elem_cmask.setText('2')
        self.tx_mulit_elem_cmask.setFixedWidth(50)
        self.tx_mulit_elem_cmask.setValidator(QIntValidator())

        hbox_multi_elem_cmask = QHBoxLayout()
        hbox_multi_elem_cmask.addWidget(self.chkbox_multi_elem_cmask)
        hbox_multi_elem_cmask.addWidget(lb_mulit_elem_cmask_roi)
        hbox_multi_elem_cmask.addWidget(self.tx_mulit_elem_cmask_roi)
        hbox_multi_elem_cmask.addWidget(lb_mulit_elem_cmask)
        hbox_multi_elem_cmask.addWidget(self.tx_mulit_elem_cmask)
        hbox_multi_elem_cmask.setAlignment(QtCore.Qt.AlignLeft)

        # colormix
        self.chkbox_multi_elem_color = QCheckBox('Colormix:')
        self.chkbox_multi_elem_color.setFixedWidth(120)
        self.chkbox_multi_elem_color.setFont(self.font2)
        self.chkbox_multi_elem_color.setChecked(False)

        lb_mulit_elem_color = QLabel()
        lb_mulit_elem_color.setFont(self.font2)
        lb_mulit_elem_color.setText('Colors: ')
        lb_mulit_elem_color.setFixedWidth(60)

        self.tx_mulit_elem_color = QLineEdit(self)
        self.tx_mulit_elem_color.setFont(self.font2)
        self.tx_mulit_elem_color.setText('r, g, b')
        self.tx_mulit_elem_color.setFixedWidth(80)

        lb_mulit_elem_color_clim = QLabel()
        lb_mulit_elem_color_clim.setFont(self.font2)
        lb_mulit_elem_color_clim.setText('CLim: ')
        lb_mulit_elem_color_clim.setFixedWidth(60)

        self.tx_mulit_elem_color_clim = QLineEdit(self)
        self.tx_mulit_elem_color_clim.setFont(self.font2)
        self.tx_mulit_elem_color_clim.setText('0, 1')
        self.tx_mulit_elem_color_clim.setFixedWidth(50)

        hbox_multi_elem_color = QHBoxLayout()
        hbox_multi_elem_color.addWidget(self.chkbox_multi_elem_color)
        hbox_multi_elem_color.addWidget(lb_mulit_elem_color_clim)
        hbox_multi_elem_color.addWidget(self.tx_mulit_elem_color_clim)
        hbox_multi_elem_color.addWidget(lb_mulit_elem_color)
        hbox_multi_elem_color.addWidget(self.tx_mulit_elem_color)
        hbox_multi_elem_color.setAlignment(QtCore.Qt.AlignLeft)

        # batch fit button
        self.pb_multi_elem_fit_batch = QPushButton('Batch fit')
        self.pb_multi_elem_fit_batch.setFixedWidth(240)
        self.pb_multi_elem_fit_batch.setFont(self.font2)
        self.pb_multi_elem_fit_batch.clicked.connect(self.fit_multi_elem_thickness_batch)

        lb_multi_elem_batch_cpu = QLabel()
        max_cpu = np.floor(self.system_cpu*0.8)
        lb_multi_elem_batch_cpu.setText(f'cpu ({int(max_cpu)}):')
        lb_multi_elem_batch_cpu.setFont(self.font2)
        lb_multi_elem_batch_cpu.setFixedWidth(60)

        self.tx_multi_elem_batch_cpu = QLineEdit('8')
        self.tx_multi_elem_batch_cpu.setFont(self.font2)
        self.tx_multi_elem_batch_cpu.setFixedWidth(50)
        self.tx_multi_elem_batch_cpu.setValidator(QIntValidator())

        hbox_cpu = QHBoxLayout()
        hbox_cpu.addWidget(self.pb_multi_elem_fit_batch)
        hbox_cpu.addWidget(lb_multi_elem_batch_cpu)
        hbox_cpu.addWidget(self.tx_multi_elem_batch_cpu)
        hbox_cpu.setAlignment(QtCore.Qt.AlignLeft)

        # assemble together
        vbox_multi_elem_batch = QVBoxLayout()
        vbox_multi_elem_batch.addWidget(lb_batch)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_open)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_align)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_nl)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_mf)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_cmask)
        vbox_multi_elem_batch.addLayout(hbox_multi_elem_color)
        vbox_multi_elem_batch.addLayout(hbox_cpu)
        #vbox_multi_elem_batch.addWidget(self.pb_multi_elem_fit_batch)
        vbox_multi_elem_batch.setAlignment(QtCore.Qt.AlignTop)

        return vbox_multi_elem_batch


    def layout_multi_elem_eng_range(self):
        lb_eng_s = QLabel()
        lb_eng_s.setFont(self.font2)
        lb_eng_s.setText('Energy range  start:')
        lb_eng_s.setFixedWidth(150)

        lb_eng_e = QLabel()
        lb_eng_e.setFont(self.font2)
        lb_eng_e.setText('end:')
        lb_eng_e.setFixedWidth(40)

        self.tx_multi_elem_s = QLineEdit()
        self.tx_multi_elem_s.setFont(self.font2)
        self.tx_multi_elem_s.setFixedWidth(60)

        self.tx_multi_elem_e = QLineEdit()
        self.tx_multi_elem_e.setFont(self.font2)
        self.tx_multi_elem_e.setFixedWidth(60)

        hbox_multi_elem_range = QHBoxLayout()
        hbox_multi_elem_range.addWidget(lb_eng_s)
        hbox_multi_elem_range.addWidget(self.tx_multi_elem_s)
        hbox_multi_elem_range.addWidget(lb_eng_e)
        hbox_multi_elem_range.addWidget(self.tx_multi_elem_e)
        hbox_multi_elem_range.setAlignment(QtCore.Qt.AlignLeft)

        return hbox_multi_elem_range


    def layout_multi_elem_bkg(self):
        lb_bkg_poly = QLabel()
        lb_bkg_poly.setFont(self.font2)
        lb_bkg_poly.setText('Bkg. polynomial:')
        lb_bkg_poly.setFixedWidth(120)

        self.chkbox_multi_bkg_poly1 = QCheckBox('1')
        self.chkbox_multi_bkg_poly1.setFixedWidth(45)
        self.chkbox_multi_bkg_poly1.setFont(self.font2)
        self.chkbox_multi_bkg_poly1.setChecked(False)

        self.chkbox_multi_bkg_poly2 = QCheckBox('0')
        self.chkbox_multi_bkg_poly2.setFixedWidth(45)
        self.chkbox_multi_bkg_poly2.setFont(self.font2)
        self.chkbox_multi_bkg_poly2.setChecked(True)

        self.chkbox_multi_bkg_poly3 = QCheckBox('-1')
        self.chkbox_multi_bkg_poly3.setFixedWidth(45)
        self.chkbox_multi_bkg_poly3.setFont(self.font2)
        self.chkbox_multi_bkg_poly3.setChecked(False)

        self.chkbox_multi_bkg_poly4 = QCheckBox('-2')
        self.chkbox_multi_bkg_poly4.setFixedWidth(45)
        self.chkbox_multi_bkg_poly4.setFont(self.font2)
        self.chkbox_multi_bkg_poly4.setChecked(False)

        self.chkbox_multi_bkg_poly5 = QCheckBox('-3')
        self.chkbox_multi_bkg_poly5.setFixedWidth(45)
        self.chkbox_multi_bkg_poly5.setFont(self.font2)
        self.chkbox_multi_bkg_poly5.setChecked(True)

        hbox_bkg_multi_poly = QHBoxLayout()
        hbox_bkg_multi_poly.addWidget(lb_bkg_poly)
        hbox_bkg_multi_poly.addWidget(self.chkbox_multi_bkg_poly1)
        hbox_bkg_multi_poly.addWidget(self.chkbox_multi_bkg_poly2)
        hbox_bkg_multi_poly.addWidget(self.chkbox_multi_bkg_poly3)
        hbox_bkg_multi_poly.addWidget(self.chkbox_multi_bkg_poly4)
        hbox_bkg_multi_poly.addWidget(self.chkbox_multi_bkg_poly5)
        hbox_bkg_multi_poly.setAlignment(QtCore.Qt.AlignLeft)
        return hbox_bkg_multi_poly


    def layout_multi_elem_roi(self):
        lb_roi = QLabel()
        lb_roi.setFont(self.font1)
        lb_roi.setText('ROI profile')
        lb_roi.setVisible(False)

        self.pb_multi_roi = QPushButton()
        self.pb_multi_roi.setText('Fit ROI')
        self.pb_multi_roi.setFont(self.font2)
        self.pb_multi_roi.setFixedWidth(120)
        self.pb_multi_roi.clicked.connect(self.fit_multi_elem_roi)

        self.pb_multi_roi_save = QPushButton()
        self.pb_multi_roi_save.setText('Save ROI Fit')
        self.pb_multi_roi_save.setFont(self.font2)
        self.pb_multi_roi_save.setFixedWidth(120)
        self.pb_multi_roi_save.clicked.connect(self.save_multi_elem_roi)

        lb_multi_roi = QLabel()
        lb_multi_roi.setFont(self.font2)
        lb_multi_roi.setText(' ROI #: ')
        lb_multi_roi.setFixedWidth(50)

        self.tx_multi_roi = QLineEdit(self)
        self.tx_multi_roi.setFont(self.font2)
        self.tx_multi_roi.setText('-1')
        # self.tx_fit_roi.setValidator(QIntValidator())
        self.tx_multi_roi.setFixedWidth(60)

        hbox = QHBoxLayout()
        hbox.addWidget(self.pb_multi_roi)
        hbox.addWidget(lb_multi_roi)
        hbox.addWidget(self.tx_multi_roi)
        hbox.addWidget(self.pb_multi_roi_save)
        hbox.setAlignment(QtCore.Qt.AlignLeft)

        vbox = QVBoxLayout()
        vbox.addWidget(lb_roi)
        vbox.addLayout(hbox)
        vbox.setAlignment(QtCore.Qt.AlignTop)

        return vbox

    def layout_xanes_prep(self):
        lb_empty = QLabel()
        lb_prep = QLabel()
        lb_prep.setFont(self.font1)
        lb_prep.setText('Preparation')
        lb_prep.setFixedWidth(150)

        self.pb_norm_txm = QPushButton('Norm. TMX (-log)')
        self.pb_norm_txm.setFont(self.font2)
        self.pb_norm_txm.clicked.connect(self.norm_txm)
        self.pb_norm_txm.setFixedWidth(150)

        self.pb_align = QPushButton('Align Img')
        self.pb_align.setFont(self.font2)
        self.pb_align.clicked.connect(self.xanes_align_img)
        self.pb_align.setFixedWidth(150)

        self.pb_align_roi = QPushButton('Align Img (ROI)')
        self.pb_align_roi.setFont(self.font2)
        self.pb_align_roi.clicked.connect(self.xanes_align_img_roi)
        self.pb_align_roi.setFixedWidth(150)

        self.pb_rmbg = QPushButton('Remove Bkg. (ROI)')
        self.pb_rmbg.setFont(self.font2)
        self.pb_rmbg.clicked.connect(self.remove_bkg)
        self.pb_rmbg.setFixedWidth(150)

        self.chkbox_rmbg = QCheckBox('devide')
        self.chkbox_rmbg.setFixedWidth(80)
        self.chkbox_rmbg.setFont(self.font2)
        self.chkbox_rmbg.setChecked(True)

        self.align_group = QButtonGroup()
        self.align_group.setExclusive(True)
        self.rd_ali1 = QRadioButton('StackReg')
        self.rd_ali1.setFixedWidth(150)
        self.rd_ali1.setChecked(True)
        # self.rd_norm1.toggled.connect(self.select_file)

        self.cb_ali = QComboBox()
        self.cb_ali.setFont(self.font2)
        self.cb_ali.addItem('  translation')
        self.cb_ali.addItem('  rigid')
        self.cb_ali.addItem('  scaled rotation')
        self.cb_ali.setFixedWidth(150)

        self.rd_ali2 = QRadioButton('Cross-Correlation')
        self.rd_ali2.setFixedWidth(160)
        self.rd_ali2.setChecked(False)
        # self.rd_norm2.toggled.connect(self.select_file)

        self.align_group.addButton(self.rd_ali1)
        self.align_group.addButton(self.rd_ali2)
        self.align_group = QButtonGroup()
        self.align_group.setExclusive(True)

        lb_ali_method = QLabel()
        lb_ali_method.setText('Align method:')
        lb_ali_method.setFont(self.font2)

        self.pb_apply_shft = QPushButton('Apply shift')
        self.pb_apply_shft.setFont(self.font2)
        self.pb_apply_shft.clicked.connect(self.apply_shift)
        self.pb_apply_shft.setFixedWidth(150)

        self.pb_save_shft = QPushButton('Save shift list')
        self.pb_save_shft.setFont(self.font2)
        self.pb_save_shft.clicked.connect(self.save_shift)
        self.pb_save_shft.setFixedWidth(150)

        self.pb_load_shft = QPushButton('Load shift list')
        self.pb_load_shft.setFont(self.font2)
        self.pb_load_shft.clicked.connect(self.load_shift)
        self.pb_load_shft.setFixedWidth(150)

        self.lb_shift = QLabel()
        self.lb_shift.setFont(self.font2)
        self.lb_shift.setText('  Shift list: None')
        self.lb_shift.setFixedWidth(150)

        lb_ali_ref = QLabel()
        lb_ali_ref.setFont(self.font2)
        lb_ali_ref.setText('  Ref. Image: ')
        lb_ali_ref.setFixedWidth(90)

        lb_ali_roi = QLabel()
        lb_ali_roi.setFont(self.font2)
        lb_ali_roi.setText('  ROI Index: ')
        lb_ali_roi.setFixedWidth(90)

        self.tx_ali_ref = QLineEdit(self)
        self.tx_ali_ref.setFont(self.font2)
        self.tx_ali_ref.setText('-1')
        self.tx_ali_ref.setValidator(QIntValidator())
        self.tx_ali_ref.setFixedWidth(50)

        self.tx_ali_roi = QLineEdit(self)
        self.tx_ali_roi.setFont(self.font2)
        self.tx_ali_roi.setText('-1')
        self.tx_ali_roi.setValidator(QIntValidator())
        self.tx_ali_roi.setFixedWidth(50)

        hbox_prep = QHBoxLayout()
        hbox_prep.addWidget(self.pb_norm_txm)
        hbox_prep.addWidget(self.pb_rmbg)
        hbox_prep.addWidget(self.chkbox_rmbg)
        hbox_prep.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali = QHBoxLayout()
        hbox_ali.addWidget(self.pb_align)
        hbox_ali.addWidget(lb_ali_ref)
        hbox_ali.addWidget(self.tx_ali_ref)
        hbox_ali.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali_roi = QHBoxLayout()
        hbox_ali_roi.addWidget(self.pb_align_roi)
        hbox_ali_roi.addWidget(lb_ali_roi)
        hbox_ali_roi.addWidget(self.tx_ali_roi)
        hbox_ali_roi.setAlignment(QtCore.Qt.AlignLeft)


        hbox_ali_stackreg = QHBoxLayout()
        hbox_ali_stackreg.addWidget(self.rd_ali1)
        hbox_ali_stackreg.addWidget(self.cb_ali)
        hbox_ali_stackreg.setAlignment(QtCore.Qt.AlignLeft)

        vbox_ali_method = QVBoxLayout()
        # hbox_ali_method.addWidget(lb_ali_method)
        vbox_ali_method.addLayout(hbox_ali_stackreg)
        vbox_ali_method.addWidget(self.rd_ali2)
        vbox_ali_method.setAlignment(QtCore.Qt.AlignTop)

        hbox_shft = QHBoxLayout()
        hbox_shft.addWidget(self.pb_save_shft)
        hbox_shft.addWidget(self.pb_load_shft)
        hbox_shft.setAlignment(QtCore.Qt.AlignLeft)

        hbox_shft1 = QHBoxLayout()
        hbox_shft1.addWidget(self.pb_apply_shft)
        hbox_shft1.addWidget(self.lb_shift)
        hbox_shft1.setAlignment(QtCore.Qt.AlignLeft)

        vbox_prep = QVBoxLayout()
        vbox_prep.addWidget(lb_prep)
        vbox_prep.addLayout(hbox_prep)
        vbox_prep.addLayout(hbox_ali)
        vbox_prep.addLayout(hbox_ali_roi)
        vbox_prep.addLayout(vbox_ali_method)
        vbox_prep.addLayout(hbox_shft)
        vbox_prep.addLayout(hbox_shft1)
        vbox_prep.addWidget(lb_empty)
        return vbox_prep


    def layout_canvas(self):
        from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
        lb_empty = QLabel()
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(10)
        self.canvas1 = MyCanvas(obj=self)
        self.toolbar = NavigationToolbar(self.canvas1, self)
        self.sl1 = QScrollBar(QtCore.Qt.Horizontal)
        self.sl1.setMaximum(0)
        self.sl1.setMinimum(0)
        self.sl1.valueChanged.connect(lambda:self.sliderval(self.canvas1))

        self.cb1 = QComboBox()
        self.cb1.setFont(self.font2)
        self.cb1.addItem('Raw image')
        self.cb1.setFixedWidth(307)
        self.cb1.currentIndexChanged.connect(self.update_canvas_img)

        self.pb_del = QPushButton('Del. single image')
        self.pb_del.setToolTip('Delete single image, it will delete the same slice in other images (e.g., "raw image", "aligned image", "background removed" ')
        self.pb_del.setFont(self.font2)
        self.pb_del.clicked.connect(self.delete_single_img)
        self.pb_del.setEnabled(False)
        self.pb_del.setFixedWidth(150)

        if self.torch_installed:
            self.pb_move_img_stack = QPushButton('Move to ML')
            self.pb_move_img_stack.setFont(self.font2)
            self.pb_move_img_stack.clicked.connect(lambda: self.move_canvas_img_stack(self.canvas1, self.canvas_ml))
            self.pb_move_img_stack.setFixedWidth(150)

        self.pb_save_img_stack = QPushButton('Save image stack')
        self.pb_save_img_stack.setFont(self.font2)
        self.pb_save_img_stack.clicked.connect(lambda:self.save_img_stack(self.canvas1))
        self.pb_save_img_stack.setFixedWidth(150)

        self.pb_save_img_single = QPushButton('Save current image')
        self.pb_save_img_single.setFont(self.font2)
        self.pb_save_img_single.clicked.connect(self.save_img_single)
        self.pb_save_img_single.setFixedWidth(150)

        hbox_can_l = QHBoxLayout()
        hbox_can_l.addWidget(self.cb1)
        hbox_can_l.addWidget(self.pb_del)
        if self.torch_installed:
            hbox_can_l.addWidget(self.pb_move_img_stack)
        hbox_can_l.setAlignment(QtCore.Qt.AlignLeft)

        hbox_can_save = QHBoxLayout()
        hbox_can_save.addWidget(self.cb1)
        hbox_can_save.addWidget(self.pb_save_img_single)
        hbox_can_save.addWidget(self.pb_save_img_stack)
        hbox_can_save.setAlignment(QtCore.Qt.AlignLeft)

        self.lb_x_l = QLabel()
        self.lb_x_l.setFont(self.font2)
        self.lb_x_l.setText('x: ')
        self.lb_x_l.setFixedWidth(80)

        self.lb_y_l = QLabel()
        self.lb_y_l.setFont(self.font2)
        self.lb_y_l.setText('y: ')
        self.lb_y_l.setFixedWidth(80)

        self.lb_z_l = QLabel()
        self.lb_z_l.setFont(self.font2)
        self.lb_z_l.setText('intensity: ')
        self.lb_z_l.setFixedWidth(120)

        lb_cmap = QLabel()
        lb_cmap.setFont(self.font2)
        lb_cmap.setText('colormap: ')
        lb_cmap.setFixedWidth(80)

        cmap = ['gray', 'bone', 'viridis', 'terrain', 'gnuplot', 'bwr', 'plasma', 'PuBu', 'summer',
                'rainbow', 'jet', 'Spectral_r', 'Pastel1', 'Set2', 'tab20', 'tab20c', 'GnBu', 'YlOrRd',
                'inferno', 'BuPu']
        self.cb_cmap = QComboBox()
        self.cb_cmap.setFont(self.font2)
        for i in cmap:
            self.cb_cmap.addItem(i)
        self.cb_cmap.setCurrentText('viridis')
        self.cb_cmap.currentIndexChanged.connect(lambda:self.change_colormap(self.canvas1))
        self.cb_cmap.setFixedWidth(80)

        self.pb_adj_cmap = QPushButton('Auto Contrast')
        self.pb_adj_cmap.setFont(self.font2)
        self.pb_adj_cmap.clicked.connect(lambda:self.auto_contrast(self.canvas1))
        self.pb_adj_cmap.setEnabled(True)
        self.pb_adj_cmap.setFixedWidth(120)

        lb_cmax = QLabel()
        lb_cmax.setFont(self.font2)
        lb_cmax.setText('cmax: ')
        lb_cmax.setFixedWidth(40)
        lb_cmin = QLabel()
        lb_cmin.setFont(self.font2)
        lb_cmin.setText('cmin: ')
        lb_cmin.setFixedWidth(40)

        self.tx_cmax = QLineEdit(self)
        self.tx_cmax.setFont(self.font2)
        self.tx_cmax.setFixedWidth(80)
        self.tx_cmax.setText('1.')
        self.tx_cmax.setValidator(QDoubleValidator())
        self.tx_cmax.returnPressed.connect(self.cmin_cmax_pressed1)
        self.tx_cmax.setEnabled(True)

        self.tx_cmin = QLineEdit(self)
        self.tx_cmin.setFont(self.font2)
        self.tx_cmin.setFixedWidth(80)
        self.tx_cmin.setText('0.')
        self.tx_cmin.setValidator(QDoubleValidator())
        self.tx_cmin.returnPressed.connect(self.cmin_cmax_pressed2)
        self.tx_cmin.setEnabled(True)

        self.pb_set_cmap = QPushButton('Set')
        self.pb_set_cmap.setFont(self.font2)
        self.pb_set_cmap.clicked.connect(lambda:self.set_contrast(self.canvas1))
        self.pb_set_cmap.setEnabled(True)
        self.pb_set_cmap.setFixedWidth(60)

        hbox_chbx_l = QHBoxLayout()
        hbox_chbx_l.addWidget(self.lb_x_l)
        hbox_chbx_l.addWidget(self.lb_y_l)
        hbox_chbx_l.addWidget(self.lb_z_l)
        hbox_chbx_l.addWidget(lb_empty)
        hbox_chbx_l.addWidget(self.pb_save_img_single)
        hbox_chbx_l.addWidget(self.pb_save_img_stack)
        hbox_chbx_l.setAlignment(QtCore.Qt.AlignLeft)

        hbox_cmap = QHBoxLayout()
        hbox_cmap.addWidget(lb_cmap)
        hbox_cmap.addWidget(self.cb_cmap)
        hbox_cmap.addWidget(self.pb_adj_cmap)
        hbox_cmap.addWidget(lb_cmin)
        hbox_cmap.addWidget(self.tx_cmin)
        hbox_cmap.addWidget(lb_cmax)
        hbox_cmap.addWidget(self.tx_cmax)
        hbox_cmap.addWidget(self.pb_set_cmap)
        hbox_chbx_l.addWidget(lb_empty)
        hbox_cmap.setAlignment(QtCore.Qt.AlignLeft)

        vbox_can1 = QVBoxLayout()
        vbox_can1.addWidget(self.toolbar)
        vbox_can1.addWidget(self.canvas1)
        vbox_can1.addWidget(self.sl1)
        vbox_can1.addLayout(hbox_can_l)
        vbox_can1.addLayout(hbox_chbx_l)
        vbox_can1.addLayout(hbox_cmap)
        vbox_can1.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_can1

    '''
    def check_xanes_fit_requirement(self, img_stack):
        n_ref = len(self.spectrum_ref)
        n_eng = len(self.xanes_eng)
        return_flag = 1
        if n_ref < 2:
            self.msg += ';   # of reference spectrum need to be larger than 2, fitting fails ...'
            return_flag = 0
        elif img_stack.shape[0] != n_eng:
            self.msg += ';   # of stack image is not equal to energies, fitting fails ...'
            return_flag = 0
        return return_flag
    '''

    def check_xanes_fit_requirement(self, img_stack):
        n_eng = len(self.xanes_eng)
        return_flag = 1
        if img_stack.shape[0] != n_eng:
            self.msg += ';   # of stack image is not equal to energies, fitting fails ...'
            return_flag = 0
        return return_flag


    def load_xanes_ref(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                fn_ref = fn.split('/')[-1]
                print(f'selected reference: {fn_ref}')
                self.lb_ref_info.setText(self.lb_ref_info.text() + '\n' + f'ref #{self.num_ref}: ' + fn_ref)
                self.lb_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
                QApplication.processEvents()

                # update 3D fitting
                self.lb_param_ref_info.setText(self.lb_param_ref_info.text() + '\n' + f'ref #{self.num_ref}: ' + fn_ref)
                self.load_reference_successful = 1
                QApplication.processEvents()

                ref = np.loadtxt(fn)
                ref = pyxas.rm_duplicate(ref)
                self.spectrum_ref[f'ref{self.num_ref}'] = ref
                self.num_ref += 1
            except Exception as err:
                self.msg = str(err)
                self.update_msg()
                # update 3D fitting
                self.load_reference_successful = 0
                print(f'un-supported xanes reference format. Error: {str(err)}')


    def reset_xanes_ref(self):
        self.num_ref = 0
        self.lb_ref_info.setText('Reference spectrum:')
        self.lb_param_ref_info.setText('Reference spectrum:')
        self.spectrum_ref = {}
        self.load_reference_successful = 0
        self.xanes_fit_cost = 0
        self.tx_elem.setText('')
        self.elem_label = []


    def select_2d_fitting_method(self):
        if self.rd_fit_method1.isChecked():
            self.fitting_method = 'basic'
            self.tx_iter_num.setEnabled(False)
            self.tx_fit_rate.setEnabled(False)
            self.chkbox_bkg_poly1.setChecked(False) # order = 1
            self.chkbox_bkg_poly2.setChecked(True)  # order = 0
            self.chkbox_bkg_poly3.setChecked(False)  # order = -1
            self.chkbox_bkg_poly4.setChecked(False)  # order = -2
            self.chkbox_bkg_poly5.setChecked(False)  # order = -3
            self.tx_iter_num.setEnabled(False)
            self.tx_fit_rate.setEnabled(False)
            self.cb_fit_iter_method.setEnabled(False)
            self.tx_fit_iter_sigma.setEnabled(False)
        if self.rd_fit_method2.isChecked():
            self.fitting_method = 'nnls'
            self.tx_iter_num.setEnabled(True)
            self.tx_fit_rate.setEnabled(False)
            self.chkbox_bkg_poly1.setChecked(False) # order = 1
            self.chkbox_bkg_poly2.setChecked(True)  # order = 0
            self.chkbox_bkg_poly3.setChecked(False)  # order = -1
            self.chkbox_bkg_poly4.setChecked(False)  # order = -2
            self.chkbox_bkg_poly5.setChecked(False)  # order = -3
            self.tx_iter_num.setEnabled(True)
            self.tx_fit_rate.setEnabled(False)
        if self.rd_fit_method3.isChecked():
            self.fitting_method = 'admm'
            self.tx_iter_num.setEnabled(True)
            self.tx_fit_rate.setEnabled(True)
            self.chkbox_bkg_poly1.setChecked(True) # order = 1
            self.chkbox_bkg_poly2.setChecked(True)  # order = 0
            self.chkbox_bkg_poly3.setChecked(False)  # order = -1
            self.chkbox_bkg_poly4.setChecked(False)  # order = -2
            self.chkbox_bkg_poly5.setChecked(False)  # order = -3
            self.tx_iter_num.setEnabled(True)
            self.tx_fit_rate.setEnabled(True)
            self.cb_fit_iter_method.setEnabled(True)
            self.tx_fit_iter_sigma.setEnabled(True)


    def choose_image_for_fittting(self):
        canvas = self.canvas1
        img_stack = canvas.img_stack
        self.msg = f'Fit image: using "{self.cb1.currentText()}"'
        return_flag = self.check_xanes_fit_requirement(img_stack)

        if not return_flag:
            if self.dataset_used_for_fitting <= 0:
                img_stack = self.img_xanes
                self.msg = 'Fit 2D xanes: using "Image Raw"'
                self.dataset_used_for_fitting = 0
                return_flag = 1
            elif self.dataset_used_for_fitting == 1:
                img_stack = self.img_update
                self.msg = 'Fit 2D xanes: using "Image update"'
                self.dataset_used_for_fitting = 1
                return_flag = 1
            elif self.dataset_used_for_fitting == 2:
                img_stack = self.img_regulation
                self.msg = 'Fit 2D xanes: using "Image regulation"'
                self.dataset_used_for_fitting = 2
                return_flag = 1
        else:
            if "raw" in self.msg.lower():
                self.dataset_used_for_fitting = 0
            elif "update" in self.msg.lower():
                self.dataset_used_for_fitting = 1
            elif "regulation" in self.msg.lower():
                self.dataset_used_for_fitting = 2
            else:
                self.dataset_used_for_fitting = -1
        self.update_msg()
        return return_flag, img_stack


    def fit_2d_xanes_wrap(self):
        try:
            if len(self.spectrum_ref) < 2:
                raise Exception('Number of reference spectrum < 2!')
            n_iter = int(self.tx_iter_num.text())
            learning_rate = float(self.tx_fit_rate.text())
            bkg_polynomial_order = self.get_bkg_poly_order()
            num_ref = len(self.spectrum_ref)
            self.pb_fit2d.setDisabled(True)
            QApplication.processEvents()
            return_flag, img_stack = self.choose_image_for_fittting()
            img_stack = self.smooth(img_stack * self.mask)
            if return_flag:
                fit_eng_range = self._get_fit_eng_range()
                img_stack_s = img_stack[fit_eng_range]
                img_stack_s[np.isnan(img_stack_s)] = 0
                eng_s = self.xanes_eng[fit_eng_range]
                fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = self.fit_2d_xanes_core(img_stack_s, eng_s,
                                                                                                     bkg_polynomial_order,
                                                                                                     n_iter, learning_rate)
                self.xanes_2d_fit = fit_coef
                self.xanes_fit_cost = cost
                self.xanes_2d_fit_offset = y_offset
                self.xanes_2d_fit_var = var[:num_ref]
                #self.xanes_img_minus_offset = img_stack - y_offset

            self.save_2D_fitting_to_summary()
            self.postprocess_2D_fitting()

        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
        finally:
            self.pb_fit2d.setEnabled(True)


    def fit_2d_xanes_core(self, img_stack_s, eng_s, bkg_polynomial_order, n_iter, learning_rate):
        if self.rd_fit_method1.isChecked():
            fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = pyxas.fit_2D_xanes_basic(img_stack_s, eng_s,
                                                                                                   self.spectrum_ref,
                                                                                                   bkg_polynomial_order)
        elif self.rd_fit_method2.isChecked():
            fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = pyxas.fit_2D_xanes_nnls(img_stack_s, eng_s,
                                                                                                  self.spectrum_ref,
                                                                                                  n_iter)
        elif self.rd_fit_method3.isChecked():
            if 'NL' in self.cb_fit_iter_method.currentText():
                method = 'nl'
            else:
                method = 'bm3d'
            sigma = float(self.tx_fit_iter_sigma.text())
            fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = pyxas.fit_2D_xanes_admm_denoise(img_stack_s, eng_s,
                                                                                                  self.spectrum_ref,
                                                                                                  learning_rate, n_iter,
                                                                                                  [0, 1e10],
                                                                                                  bkg_polynomial_order,
                                                                                                  method,
                                                                                                  sigma)
        return fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp


    def get_bkg_poly_order(self):
        bkg_polynomial_order = []
        if self.chkbox_bkg_poly1.isChecked():
            bkg_polynomial_order.append(1)
        if self.chkbox_bkg_poly2.isChecked():
            bkg_polynomial_order.append(0)
        if self.chkbox_bkg_poly3.isChecked():
            bkg_polynomial_order.append(-1)
        if self.chkbox_bkg_poly4.isChecked():
            bkg_polynomial_order.append(-2)
        if self.chkbox_bkg_poly5.isChecked():
            bkg_polynomial_order.append(-3)
        bkg_polynomial_order = list(np.sort(bkg_polynomial_order))
        return bkg_polynomial_order


    def _get_fit_eng_range(self):
        try:
            eng_s = float(self.tx_fit2d_s.text())
            eng_e = float(self.tx_fit2d_e.text())
        except:
            eng_s = self.xanes_eng[0]
            eng_e = self.xanes_eng[-1]
        finally:
            fit_eng_s, fit_eng_e = pyxas.find_nearest(self.xanes_eng, eng_s), pyxas.find_nearest(self.xanes_eng, eng_e)
            if fit_eng_e == len(self.xanes_eng) - 1:
                fit_eng_e += 1
            tmp = np.ones(len(self.xanes_eng[fit_eng_s:fit_eng_e]))
            for i in range(len(self.spectrum_ref)):
                tmp = np.array(self.xanes_eng[fit_eng_s: fit_eng_e] >= self.spectrum_ref[f'ref{i}'][0, 0]) * np.array(
                self.xanes_eng[fit_eng_s: fit_eng_e] <= self.spectrum_ref[f'ref{i}'][-1, 0]) * tmp
            fit_eng_range = np.arange(fit_eng_s, fit_eng_e)[np.bool8(tmp)]
            return fit_eng_range


    def save_2D_fitting_to_summary(self):
        img = self.xanes_2d_fit
        img_sum = np.sum(img, axis=0, keepdims=True)
        img_sum[np.abs(img_sum) < 1e-6] = 1e-6
        img = img / img_sum
        img = pyxas.rm_abnormal(img)
        thickness = np.sum(self.xanes_2d_fit, axis=0)
        self.img_pre_edge_sub_mean = thickness

        if self.cb1.findText('XANES Fit (ratio, summed to 1)') < 0:
            self.cb1.addItem('XANES Fit (ratio, summed to 1)')
        if self.cb1.findText('XANES Fit (Elem. concentration)') < 0:
            self.cb1.addItem('XANES Fit (Elem. concentration)')
        if self.cb1.findText('XANES Fit (thickness)') < 0:
            self.cb1.addItem('XANES Fit (thickness)')
        if self.cb1.findText('XANES Fit error') < 0:
            self.cb1.addItem('XANES Fit error')
        if self.cb1.findText('XANES Fit offset') < 0:
            self.cb1.addItem('XANES Fit offset')
        if self.cb1.findText('XANES Fit variance') < 0:
            self.cb1.addItem('XANES Fit variance')
        #if self.cb1.findText('Image Minus Offset') < 0:
        #    self.cb1.addItem('Image Minus Offset')

        self.data_summary['XANES Fit (ratio, summed to 1)'] = self.smooth(img) * self.mask
        # 2: xanes_fit concentration:
        img = img * self.img_pre_edge_sub_mean
        img = pyxas.rm_abnormal(img)
        self.data_summary['XANES Fit (Elem. concentration)'] = self.smooth(img) * self.mask
        # 3: xanes_fit error:
        self.data_summary['XANES Fit error'] = self.xanes_fit_cost.copy()
        # 4: xanes_fit offset:
        self.data_summary['XANES Fit offset'] = self.xanes_2d_fit_offset.copy()
        # 5: fitting variance
        self.data_summary['XANES Fit variance'] = self.xanes_2d_fit.copy()
        # finish saving to data_summary


    def postprocess_2D_fitting(self):
        self.cb1.setCurrentText('XANES Fit (ratio, summed to 1)')
        elem = self.tx_elem.text()
        elem = elem.replace(' ', '')
        elem = elem.replace(';', ',')
        elem = elem.split(',')
        if elem[0] == '':
            elem = []
        self.elem_label = elem
        self.update_canvas_img()
        self.msg = '2D fitting finished. "XANES Fit" has been added for imshow'
        self.pb_plot_roi.setEnabled(True)
        self.pb_export_roi_fit.setEnabled(True)
        self.pb_colormix.setEnabled(True)
        self.pb_save2d.setEnabled(True)
        num_ref = len(self.spectrum_ref)
        self.cb_color_channel.clear()
        for i in range(num_ref):
            if self.cb_color_channel.findText(f'{i}') < 0:
                self.cb_color_channel.addItem(f'{i}')


    def reset_xanes_fit(self):
        self.reset_xanes_ref()
        self.xanes_2d_fit = None
        self.img_pre_edge_sub_mean = np.array([1])
        #self.pb_plot_roi.setDisabled(True)


    def fit_2d_xanes_iter(self):
        self.pb_fit2d_iter.setEnabled(False)
        QApplication.processEvents()
        return_flag, img_stack = self.choose_image_for_fittting()
        img_stack = self.smooth(img_stack * self.mask)
        if return_flag:
            if self.chkbox_bound.isChecked():
                bounds = [0, 1]
            else:
                bounds = []
            eng_s = float(self.tx_fit2d_s.text())
            eng_e = float(self.tx_fit2d_e.text())
            fit_eng_s, fit_eng_e = pyxas.find_nearest(self.xanes_eng, eng_s), pyxas.find_nearest(self.xanes_eng, eng_e)
            tmp = np.array(self.xanes_eng[fit_eng_s: fit_eng_e] >= self.spectrum_ref['ref0'][0, 0]) * np.array(self.xanes_eng[fit_eng_s: fit_eng_e] <= self.spectrum_ref['ref0'][-1, 0])
            fit_region = np.arange(fit_eng_s, fit_eng_e)[tmp]
            try:
                num_iter = int(self.tx_iter_num.text())
                if self.chkbox_fit.isChecked(): # initializing using existing fitting results
                    coef0 = self.xanes_2d_fit
                    offset = self.xanes_2d_fit_offset
                else:
                    coef0 = None
                    offset = None

                if coef0 is None:
                    self.msg = 'Using random initial guess. It may take few minutes ...'
                else:
                    self.msg = 'Using existing fitting as initial guess'
                self. update_msg()

                self.pb_fit2d_iter.setEnabled(False)

                if self.fitting_method == 1:
                    learning_rate = float(self.tx_method1.text())
                    fit_iter_lambda = float(self.tx_method2.text())
                    self.xanes_2d_fit, self.xanes_2d_fit_offset, self.xanes_fit_cost = \
                        pyxas.fit_2D_xanes_iter(img_stack[fit_region], self.xanes_eng[fit_region], self.spectrum_ref,
                                          coef0, offset, learning_rate, num_iter, bounds=bounds, fit_iter_lambda=fit_iter_lambda)
                elif self.fitting_method == 2 or self.fitting_method == 3:
                    fit_iter_lambda = float(self.tx_method2.text())
                    rho = float(self.tx_method3.text())
                    self.xanes_2d_fit, self.xanes_2d_fit_offset, self.xanes_fit_cost = \
                        pyxas.fit_2D_xanes_iter2(img_stack[fit_region], self.xanes_eng[fit_region], self.spectrum_ref,
                                           coef0, offset, fit_iter_lambda, rho, num_iter, bounds=bounds, method=self.fitting_method-1)
                self.pb_fit2d_iter.setEnabled(True)
                QApplication.processEvents()
                if self.cb1.findText('XANES Fit (ratio, summed to 1)') < 0:
                    self.cb1.addItem('XANES Fit (ratio, summed to 1)')
                if self.cb1.findText('XANES Fit (Elem. concentration)') < 0:
                    self.cb1.addItem('XANES Fit (Elem. concentration)')
                if self.cb1.findText('XANES Fit (thickness)') < 0:
                    self.img_pre_edge_sub_mean = img_stack[fit_region][-1]
                    self.cb1.addItem('XANES Fit (thickness)')
                if self.cb1.findText('XANES Fit error') < 0:
                    self.cb1.addItem('XANES Fit error')
                self.cb1.setCurrentText('XANES Fit (ratio, summed to 1)')
                self.update_canvas_img()
                self.msg = 'Iterative fitting finished'
                self.pb_export_roi_fit.setEnabled(True)
                self.pb_colormix.setEnabled(True)
                self.pb_plot_roi.setEnabled(True)
                self.pb_save.setEnabled(True)
                num_ref = len(self.spectrum_ref)
                for i in range(num_ref):
                    if self.cb_color_channel.findText(f'{i}') < 0:
                        self.cb_color_channel.addItem(f'{i}')
            except Exception as err:
                self.msg = f'iterative fitting fails. Error: {str(err)}'
                print(self.msg)
            finally:
                self.update_msg()
        self.pb_fit2d_iter.setEnabled(True)


    def plot_xanes_ref(self):
        plt.figure()
        legend = []
        elem = self.tx_elem.text()
        elem = elem.replace(' ','')
        elem = elem.replace(';', ',')
        elem = elem.split(',')
        if elem[0] == '':
            elem = []
        try:
            for i in range(self.num_ref):
                try:
                    plot_label = elem[i]
                except Exception as err:
                    print(err)
                    plot_label = f'ref_{i}'
                self.elem_label.append(plot_label)
                spec = self.spectrum_ref[f'ref{i}']
                line, = plt.plot(spec[:,0], spec[:,1], label=plot_label)
                legend.append(line)
            print(legend)
            plt.legend(handles=legend)
            plt.show()
        except Exception as err:
            self.msg = f'un-recognized reference spectrum format. Error: {str(err)}'
            self.update_msg()



    def select_2d_multi_elem_fitting_method(self):
        if self.rd_multi_param_fit_method1.isChecked():
            self.multi_elem_fitting_method = 'basic'
            self.tx_multi_iter_num.setEnabled(False)
            self.tx_multi_fit_rate.setEnabled(False)
            self.tx_multi_fit_sigma.setEnabled(False)
            self.chkbox_multi_bkg_poly1.setChecked(False) # order = 1
            self.chkbox_multi_bkg_poly2.setChecked(True)  # order = 0
            self.chkbox_multi_bkg_poly3.setChecked(False)  # order = -1
            self.chkbox_multi_bkg_poly4.setChecked(False)  # order = -2
            self.chkbox_multi_bkg_poly5.setChecked(True)  # order = -3
        if self.rd_multi_param_fit_method3.isChecked():
            self.multi_elem_fitting_method = 'admm'
            self.tx_multi_iter_num.setEnabled(True)
            self.tx_multi_fit_rate.setEnabled(True)
            self.tx_multi_fit_sigma.setEnabled(True)
            self.chkbox_multi_bkg_poly1.setChecked(False) # order = 1
            self.chkbox_multi_bkg_poly2.setChecked(True)  # order = 0
            self.chkbox_multi_bkg_poly3.setChecked(False)  # order = -1
            self.chkbox_multi_bkg_poly4.setChecked(False)  # order = -2
            self.chkbox_multi_bkg_poly5.setChecked(True)  # order = -3


    def fit_multi_elem_thickness(self):
        try:
            self.pb_multi_elem_fit.setEnabled(False)
            self.pb_multi_elem_fit.setText('wait ...')
            QApplication.processEvents()
            return_flag, img_stack = self.choose_image_for_fittting()
            img_stack = self.smooth(img_stack * self.mask)
            fit_eng_range = self._get_multi_elem_eng_range()
            img_stack = img_stack[fit_eng_range]
            x_eng = self.xanes_eng[fit_eng_range]

            bkg_polynomial_order = self.get_mulit_elem_bkg_poly_order()
            fit_elem, eng_exclude = self._get_multi_elem()
            #self.select_2d_multi_elem_fitting_method()
            admm_iter = int(self.tx_multi_iter_num.text())
            admm_rate = float(self.tx_multi_fit_rate.text())
            admm_sigma = float(self.tx_multi_fit_sigma.text())
            method = self.multi_elem_fitting_method
            res = pyxas.fit_2D_multi_elem_thick(img_stack, x_eng, fit_elem, eng_exclude,
                                                bkg_polynomial_order, method, admm_iter, admm_rate, admm_sigma)
            self.multi_elem_fit_result = res.copy()
            self.multi_elem_thickness = res['thickness']
            self.multi_elem_fit_err = res['y_fit_err']
            self.save_multi_elem_to_summary()
            self.postprocess_multi_elem()
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
        finally:
            self.pb_multi_elem_fit.setEnabled(True)
            self.pb_multi_elem_fit.setText('Fit thickness')
            QApplication.processEvents()

    def add_multi_elem(self, elem):
        txt = self.tx_multi_elem.text()
        if not elem in txt:
            txt += f', {elem}'
        if txt[:2] == ', ':
            txt = txt[2:]
        self.tx_multi_elem.setText(txt)
        QApplication.processEvents()

    def add_multi_range(self, elem):
        txt = self.tx_multi_exclude_eng.text()
        if not elem in txt:
            txt += f', {elem}'
        if txt[:2] == ', ':
            txt = txt[2:]
        self.tx_multi_exclude_eng.setText(txt)
        QApplication.processEvents()

    def get_mulit_elem_bkg_poly_order(self):
        bkg_polynomial_order = []
        if self.chkbox_multi_bkg_poly1.isChecked():
            bkg_polynomial_order.append(1)
        if self.chkbox_multi_bkg_poly2.isChecked():
            bkg_polynomial_order.append(0)
        if self.chkbox_multi_bkg_poly3.isChecked():
            bkg_polynomial_order.append(-1)
        if self.chkbox_multi_bkg_poly4.isChecked():
            bkg_polynomial_order.append(-2)
        if self.chkbox_multi_bkg_poly5.isChecked():
            bkg_polynomial_order.append(-3)
        bkg_polynomial_order = list(np.sort(bkg_polynomial_order))
        return bkg_polynomial_order

    def _get_multi_elem_eng_range(self):
        try:
            eng_s = float(self.tx_multi_elem_s.text())
            eng_e = float(self.tx_multi_elem_e.text())
        except:
            eng_s = self.xanes_eng[0]
            eng_e = self.xanes_eng[-1]
        finally:
            fit_eng_s, fit_eng_e = pyxas.find_nearest(self.xanes_eng, eng_s), pyxas.find_nearest(self.xanes_eng, eng_e)
            if fit_eng_e == len(self.xanes_eng) - 1:
                fit_eng_e += 1
            fit_eng_range = np.arange(fit_eng_s, fit_eng_e)
        return fit_eng_range

    def _get_multi_elem(self):
        tx_elem = self.tx_multi_elem.text()
        tx_elem = tx_elem.split(',')
        elem = [k.strip() for k in tx_elem]

        tx_exclude = self.tx_multi_exclude_eng.text()
        tx_exclude = tx_exclude.replace('[', '')
        tx_exclude = tx_exclude.replace(']', '')
        try:
            tmp = tx_exclude.split(',')
            eng_exclude = [float(k.strip()) for k in tmp]
        except:
            eng_exclude = [0, 0]
            self.tx_multi_exclude_eng.setText('[0, 0]')
            QApplication.processEvents()
        return elem, eng_exclude

    def _get_multi_roi_selection(self):
        try:
            n = self.tx_multi_roi.text()
            roi_selected = 'roi_' + n
        except Exception as err:
            print(err)
            print(f'{roi_selected} not exist')
            n = '-1'
            roi_selected = 'roi_-1'
        return roi_selected

    def save_multi_elem_to_summary(self):
        img_thick = self.smooth(self.multi_elem_thickness) * self.mask
        img_thick[img_thick<0] = 0
        img_err = self.multi_elem_fit_err * self.mask
        img_sum = np.sum(img_thick, axis=0) * self.mask
        img_ratio = pyxas.rm_abnormal(img_thick / img_sum) * self.mask

        if self.cb1.findText('Multi-elem fit (ratio)') < 0:
            self.cb1.addItem('Multi-elem fit (ratio)')
        if self.cb1.findText('Multi-elem fit (concentration)') < 0:
            self.cb1.addItem('Multi-elem fit (concentration)')
        if self.cb1.findText('Multi-elem fit error') < 0:
            self.cb1.addItem('Multi-elem fit error')
        self.data_summary['Multi-elem fit (ratio)'] = img_ratio
        self.data_summary['Multi-elem fit (concentration)'] = img_thick
        self.data_summary['Multi-elem fit error'] = img_err

    def save_multi_elem_thickness(self):
        if not 'Multi-elem fit (ratio)' in self.data_summary.keys():
            self.msg = 'Fit results not found'
            self.update_msg()
            return 0
        try:
            mask = self.canvas1.mask
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'h5 File (*.h5)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save thickness fit', "", file_type, options=options)
            if not fn[-3:] == '.h5':
                fn = fn + '.h5'
            keys = self.data_summary.keys()
            hf = h5py.File(fn, 'w')
            for k in keys:
                if 'Multi-elem' in k or '':
                    img = self.data_summary[k] * mask
                    if len(img.shape) == 2:
                        img = np.expand_dims(img, 0)
                    hf.create_dataset(k, data=img.astype(np.float32))
            hf.close()
            self.msg = f'file saved to {fn}'
        except Exception as err:
            print(err)
            self.msg = str(err)
        finally:
            self.update_msg()


    def postprocess_multi_elem(self):
        self.cb1.setCurrentText('Multi-elem fit (ratio)')
        fit_elem, eng_exclude = self._get_multi_elem()
        self.elem_label = fit_elem
        self.update_canvas_img()
        self.msg = 'Multi-element fitting finished'
        self.pb_colormix.setEnabled(True)
        num_elem = len(fit_elem)
        self.cb_color_channel.clear()
        for i in range(num_elem):
            if self.cb_color_channel.findText(fit_elem[i]) < 0:
                self.cb_color_channel.addItem(fit_elem[i])

    def fit_multi_elem_roi(self):
        try:
            self.pb_multi_roi.setEnabled(False)
            self.pb_multi_roi.setText('wait ...')
            QApplication.processEvents()
            return_flag, img_stack = self.choose_image_for_fittting()
            img_stack = self.smooth(img_stack * self.mask)
            fit_eng_range = self._get_multi_elem_eng_range()
            img_stack = img_stack[fit_eng_range]
            x_eng = self.xanes_eng[fit_eng_range]

            bkg_polynomial_order = self.get_mulit_elem_bkg_poly_order()
            fit_elem, eng_exclude = self._get_multi_elem()

            roi_selected = self._get_multi_roi_selection()

            img_stack = self._get_roi_image(img_stack, roi_selected)
            img_stack_s = np.mean(np.mean(img_stack, axis=-1), axis=-1)
            img_stack_s = img_stack_s.reshape((len(x_eng), 1, 1))
            #self.select_2d_multi_elem_fitting_method()
            method = self.multi_elem_fitting_method
            admm_iter = int(self.tx_multi_iter_num.text())
            admm_rate = float(self.tx_multi_fit_rate.text())
            admm_sigma = float(self.tx_multi_fit_sigma.text())
            '''
            res = pyxas.fit_2D_multi_elem_thick(img_stack_s, x_eng, fit_elem, eng_exclude,
                                                bkg_polynomial_order, method, admm_iter, admm_rate, admm_sigma)
            '''
            res = pyxas.fit_2D_multi_elem_thick(img_stack, x_eng, fit_elem, eng_exclude,
                                                bkg_polynomial_order, method, admm_iter, admm_rate, admm_sigma)
            self.multi_elem_fit_result_roi = res.copy()
            self.multi_elem_fit_result_roi['elem'] = fit_elem
            self.multi_elem_fit_result_roi['roi'] = roi_selected
            x0 = res['x_eng_all']
            y0 = np.mean(res['Y_all'], axis=-1)

            x1 = res['x_eng_all']
            y1 = np.mean(res['Y_fit_all'], axis=-1)

            x2 = res['x_eng']
            y2 = np.mean(res['Y'], axis=-1)

            n = len(fit_elem)
            fit_avg = np.mean(res['X'][:n], axis=-1)
            fit_avg_r = fit_avg / np.sum(fit_avg)
            title = ''
            for i in range(n):
                title += f'{fit_elem[i]}: {fit_avg_r[i]:2.3f}  '
            title = title[:-2]
            plt.figure(figsize=(8, 6))
            plt.plot(x0, y0, label='Data')
            plt.plot(x1, y1, color=[1,0.5,0], linewidth=2, alpha=0.8, label='Fitted')
            plt.plot(x2, y2, 'o', color=[1,0.1,0],  alpha=0.8, markersize=4, label='Selected for Fit')
            plt.legend()
            plt.title(title)
            plt.show()
            self.multi_elem_fit_roi_success = 1
            QApplication.processEvents()
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
        finally:
            self.pb_multi_roi.setEnabled(True)
            self.pb_multi_roi.setText('Fit ROI')
            QApplication.processEvents()

    def save_multi_elem_roi(self):
        if not self.multi_elem_fit_roi_success:
            return 0
        try:
            res = self.multi_elem_fit_result_roi.copy()
            roi_selected = res['roi']
            x0 = res['x_eng_all']
            y0 = np.squeeze(res['Y_all'])

            x1 = res['x_eng_all']
            y1 = np.squeeze(res['Y_fit_all'])

            x2 = res['x_eng']
            y2 = np.squeeze(res['Y'])

            fit_elem = self.multi_elem_fit_result_roi['elem']
            n = len(fit_elem)
            fit_avg = np.squeeze(res['X'][:n])
            fit_avg_r = fit_avg / np.sum(fit_avg)
            title = ''
            for i in range(n):
                title += f'{fit_elem[i]}: {fit_avg_r[i]:2.3f}  '
            title = title[:-2]
            n_eng_all = len(x0)
            n_eng = len(x2)
            data = np.ones([n_eng_all+1, 6]) * -1 # fill empty data as -1
            data[1:, 0] = x0
            data[1:, 1] = y0
            data[1:, 2] = x1
            data[1:, 3] = y1
            data[1:n_eng+1, 4] = x2
            data[1:n_eng+1, 5] = y2
            data[0, :n] = fit_avg_r
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'txt File (*.txt)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save thickness fit', "", file_type, options=options)
            if fn[-4:] == '.txt':
                fn = fn[:-4]
            fn_elem = '_'.join(i for i in fit_elem)
            fn = f'{fn}_{fn_elem}.txt'
            np.savetxt(fn, data, fmt='%2.6f')
            self.msg = f'ROI saved to {fn}'
        except Exception as err:
            print(err)
            self.msg = str(err)
        finally:
            self.update_msg()


    def open_file_multi_elem(self):
        try:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = '*.*'
            fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", '*', options=options)
            if fn:
                fn_tmp = fn.split('/')
                fn_short = fn_tmp[-1]
                file_type = fn_short.split('.')[-1]
                file_prefix = fn_short.split('_')[0]
                if len(file_prefix) > 4:
                    file_prefix = file_prefix[:4]
                self.mulit_elem_file_path = '/'.join(t for t in fn_tmp[:-1])
                self.tx_multi_elem_folder.setText(self.mulit_elem_file_path)
                self.multi_elem_batch_files =  pyxas.retrieve_file_type(self.mulit_elem_file_path, file_prefix, file_type)
                n_file = len(self.multi_elem_batch_files)
                self.msg = f'{n_file} files loaded:   {self.multi_elem_batch_files[0].split("/")[-1]}  ...  ' \
                           f'{self.multi_elem_batch_files[-1].split("/")[-1]}'
                self.update_msg()
                self.load_file_multi_elem_batch_successfull = 1
            else:
                self.multi_elem_files = []
                self.load_file_multi_elem_batch_successfull = 0
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
            self.multi_elem_files = []
            self.load_file_multi_elem_batch_successfull = 0


    def fit_multi_elem_thickness_batch(self):
        align_flag = 1 if self.chkbox_multi_elem_align.isChecked() else 0
        align_roi_index = int(self.tx_multi_elem_align_roi.text())
        align_ref_index = int(self.tx_multi_elem_align_ref.text())
        if 'T' in self.cb_multi_elem_ali.currentText():
            align_method = 'translation'
        else:
            align_method = 'rigid'

        nl_flag = 1 if self.chkbox_multi_elem_denoise.isChecked() else 0
        nl_filt_sz = int(self.tx_mulit_elem_nl_patch_size.text())
        nl_filt_dis = int(self.tx_multi_elem_nl_patch_dis.text())

        mf_flag = 1 if self.chkbox_multi_elem_mf.isChecked() else 0
        mf_filt_sz = int(self.tx_mulit_elem_ml_size.text())

        mask_flag = 1 if self.chkbox_multi_elem_cmask.isChecked() else 0
        mask_comp = int(self.tx_mulit_elem_cmask.text())
        mask_roi_index = int(self.tx_mulit_elem_cmask_roi.text())

        color_flag = 1 if self.chkbox_multi_elem_color.isChecked() else 0
        try:
            n_cpu = int(self.tx_multi_elem_batch_cpu.text())
            roi_selected = f'roi_{align_roi_index}'
            if self.load_file_multi_elem_batch_successfull:
                self.pb_multi_elem_fit_batch.setEnabled(False)
                fn = self.multi_elem_batch_files[0]
                fn_root = fn.split('/')
                fsave_root = '/'.join(x for x in fn_root[:-1])
                n = len(self.multi_elem_batch_files)
                ts = time.time()
                for i in range(n):
                    te = time.time()
                    fn_current = self.multi_elem_batch_files[i]
                    fn_current = fn_current.split('/')[-1]
                    msg_current_file = f'processing {fn_current} [{i+1}/{n}]: '
                    txt_title = f'[{te-ts:4.1f} sec] [{i+1}/{n}]: '
                    fn = self.multi_elem_batch_files[i]
                    img = io.imread(fn)
                    img = pyxas.rm_abnormal(img)
                    img_stack = img.copy()
                    n_img = len(img_stack)
                    if align_flag:
                        txt = txt_title + 'align...'
                        self.pb_multi_elem_fit_batch.setText(txt)
                        self.msg = msg_current_file + 'aligning ...'
                        self.update_msg()
                        QApplication.processEvents()
                        img_roi = self._get_roi_image(img_stack, roi_selected)
                        img_stack = pyxas.align_img_stack_stackreg2_mpi(img_stack, align_ref_index, img_roi, n_cpu, align_method)
                        '''
                        for j in range(n_img):
                            self.msg = msg_current_file + f'aligning {j+1}/{n_img}'
                            self.update_msg()
                            QApplication.processEvents()
                            rsft, csft, sr = pyxas.align_img_stackreg(img_roi[align_ref_index], img_roi[j],
                                                                      align_flag=0, method='translation')
                            img_stack[j] = sr.transform(img_stack[j])
                        '''
                    if nl_flag:
                        txt = txt_title + 'denoise...'
                        self.msg = msg_current_file + 'denoise ...'
                        self.pb_multi_elem_fit_batch.setText(txt)
                        self.update_msg()
                        QApplication.processEvents()
                        '''
                        for j in range(n_img):
                            self.msg = msg_current_file + f'non-local mean denoising {j + 1}/{n_img}'
                            self.update_msg()
                            QApplication.processEvents()
                            img_stack[j] = pyxas.img_denoise_nl(img_stack[i], nl_filt_sz, nl_filt_dis)[0]
                        '''
                        img_stack = pyxas.img_denoise_nl_mpi(img_stack, nl_filt_sz, nl_filt_dis, n_cpu)

                    if mf_flag:
                        txt = txt_title + 'mf denoising ...'
                        self.msg = msg_current_file + 'mf denoise ...'
                        self.pb_multi_elem_fit_batch.setText(txt)
                        self.update_msg()
                        QApplication.processEvents()
                        img_stack = pyxas.img_smooth(img_stack, mf_filt_sz, axis=0)

                    if mask_flag:
                        txt = txt_title + 'mask...'
                        self.pb_multi_elem_fit_batch.setText(txt)
                        self.msg = msg_current_file + f'generate cluster mask'
                        self.update_msg()
                        QApplication.processEvents()
                        mask_roi = f'roi_{mask_roi_index}'
                        img_roi = self._get_roi_image(img_stack, mask_roi)
                        roi_cord = self._get_roi_cord(mask_roi)
                        smart_mask, img_labels = pyxas.kmean_mask(img_roi, mask_comp)
                        if roi_cord is None: # e.g. -1, the whole image
                            mask = smart_mask[0]
                        else:
                            mask = np.zeros((img_stack.shape[1], img_stack.shape[2]))
                            mask[roi_cord[2]:roi_cord[3], roi_cord[0]:roi_cord[1]] = smart_mask[0]
                    else:
                        mask = 1

                    # start fitting
                    txt = txt_title + 'fitting...'
                    self.pb_multi_elem_fit_batch.setText(txt)
                    self.msg = msg_current_file + f'fitting ...'
                    self.update_msg()
                    QApplication.processEvents()
                    fit_eng_range = self._get_multi_elem_eng_range()
                    img_stack = img_stack[fit_eng_range]
                    x_eng = self.xanes_eng[fit_eng_range]
                    bkg_polynomial_order = self.get_mulit_elem_bkg_poly_order()
                    fit_elem, eng_exclude = self._get_multi_elem()
                    #self.select_2d_multi_elem_fitting_method()
                    method = self.multi_elem_fitting_method
                    admm_iter = int(self.tx_multi_iter_num.text())
                    admm_rate = float(self.tx_multi_fit_rate.text())
                    admm_sigma = float(self.tx_multi_fit_sigma.text())
                    res = pyxas.fit_2D_multi_elem_thick(img_stack, x_eng, fit_elem, eng_exclude,
                                                        bkg_polynomial_order, method, admm_iter, admm_rate, admm_sigma)
                    res['mask'] = mask
                    self.save_multi_elem_batch_fit(fsave_root, fn, res, color_flag)
                print('saving element_thickness fitting ... ')
                self.group_multi_elem_batch_fit(fsave_root, fit_elem)
                if mask_flag:
                    print('save clustering mask ...')
                    self.group_multi_elem_batch_fit_mask(fsave_root)
            self.msg = 'batch fitting finished'
        except Exception as err:
            print(err)
            self.msg = str(err)
        finally:
            self.pb_multi_elem_fit_batch.setEnabled(True)
            self.pb_multi_elem_fit_batch.setText('Batch fit')
            self.update_msg()

    def group_multi_elem_batch_fit_mask(self, fsave_root):
        fpath_fit = f'{fsave_root}/multi_elem_fit'
        fpath_mask = f'{fpath_fit}/cluster_mask'
        fn_all_mask = np.sort(glob.glob(f'{fpath_mask}/mask*'))
        n = len(fn_all_mask)
        img = io.imread(fn_all_mask[0])
        s = img.shape

        mask = np.zeros((n, *s))
        mask_fill_hole = np.zeros((n, *s))

        for i in trange(n):
            fn = fn_all_mask[i]
            mask[i] = io.imread(fn)
            mask_fill_hole[i], _ = pyxas.img_fillhole(mask[i])
        fsave1 = f'{fpath_fit}/cluster_mask.tiff'
        fsave2 = f'{fpath_fit}/cluster_mask_fill_hole.tiff'

        io.imsave(fsave1, mask.astype(np.float32))
        io.imsave(fsave2, mask_fill_hole.astype(np.float32))





    def group_multi_elem_batch_fit(self, fsave_root, fit_elem):
        fsave_multi_img = f'{fsave_root}/multi_elem_fit/thickness'
        fsave_multi_img_ratio = f'{fsave_root}/multi_elem_fit/thickness_ratio'

        fn_all_ratio = np.sort(glob.glob(f'{fsave_multi_img_ratio}/ratio_fit_thick*'))
        fn_all = np.sort(glob.glob(f'{fsave_multi_img}/fit_thick*'))

        img_ratio = self.group_elem(fn_all_ratio)
        img = self.group_elem(fn_all)

        n_elem = len(img)
        for i in range(n_elem):
            fsave = f'{fsave_root}/multi_elem_fit/{fit_elem[i]}_thickness.tiff'
            io.imsave(fsave, img[i])
            fsave_ratio = f'{fsave_root}/multi_elem_fit/{fit_elem[i]}_thickness_ratio.tiff'
            io.imsave(fsave_ratio, img_ratio[i])

    def group_elem(self, fn_all):
        n = len(fn_all)
        img = io.imread(fn_all[0])
        s = img.shape  # e.g., s = (3, 600, 800), or (600, 800, 3)

        swap_axis = False
        if s[-1] < s[0]:  # in case s=(600, 800, 3), we need to swap the axis
            swap_axis = True
            s = (s[2], s[0], s[1])

        img_elem = np.zeros((n, s[0], s[1], s[2]))
        for i in trange(n):
            fn = fn_all[i]
            img = io.imread(fn)
            if swap_axis:
                img = np.swapaxes(img, 2, 1)
                img = np.swapaxes(img, 1, 0)
            img_elem[i] = img

        img_elem = np.swapaxes(img_elem, 0, 1)
        return img_elem


    def save_multi_elem_batch_fit(self, fsave_root, fn, res, color_flag):
        fn_short = fn.split('/')[-1]
        fn_short = fn_short.split('.')[0]
        fn_short = fn_short.split('_')[-1]
        img_thick = res['thickness']
        img_err = res['y_fit_err']
        mask = res['mask']
        img_thick[img_thick < 0] = 0
        img_err = img_err * mask
        img_sum = np.sum(img_thick, axis=0)
        img_ratio = pyxas.rm_abnormal(img_thick / img_sum) * mask
        fsave_multi_img = f'{fsave_root}/multi_elem_fit/thickness'
        fsave_multi_img_ratio = f'{fsave_root}/multi_elem_fit/thickness_ratio'
        fsave_multi_err = f'{fsave_root}/multi_elem_fit/fit_error'
        fsave_multi_mask = f'{fsave_root}/multi_elem_fit/cluster_mask'
        pyxas.create_directory(fsave_multi_img)
        pyxas.create_directory(fsave_multi_img_ratio)
        pyxas.create_directory(fsave_multi_err)
        pyxas.create_directory(fsave_multi_mask)

        fsave_img = f'{fsave_multi_img}/fit_thick_{fn_short}.tiff'
        fsave_img_ratio = f'{fsave_multi_img_ratio}/ratio_fit_thick_{fn_short}.tiff'
        fsave_err = f'{fsave_multi_err}/fit_thick_error_{fn_short}.tiff'
        fsave_mask = f'{fsave_multi_mask}/mask_{fn_short}.tiff'


        io.imsave(fsave_img, img_thick.astype(np.float32))
        io.imsave(fsave_img_ratio, img_ratio.astype(np.float32))
        io.imsave(fsave_err, img_err.astype(np.float32))
        if not (isinstance(mask, int)):
            io.imsave(fsave_mask, mask.astype(np.float32))

        if color_flag:
            fsave_multi_color = f'{fsave_root}/multi_elem_fit/colormix'
            color = self.tx_mulit_elem_color.text()
            #color = pyxas.convert_color_string(color)
            clim_txt = self.tx_mulit_elem_color_clim.text()
            clim_txt = clim_txt.split(',')
            cmin = float(clim_txt[0])
            cmax = float(clim_txt[1])
            self.colormix_and_save(img_ratio, color, clim=[cmin, cmax],
                                   fsave_root=fsave_multi_color,
                                   fn_save=f'ratio_colormix_{fn_short}')



    def colormix_and_save(self, img, color, clim=[0,1], fsave_root='.', fn_save='colormix'):
        img_color = pyxas.colormix(img, color=color, clim=clim)
        cmin, cmax = clim
        fsave_color = f'{fsave_root}/{fn_save}.jpg'
        pyxas.create_directory(fsave_root)
        pyxas.toimage(img_color[:, :, :3], cmin=cmin, cmax=cmax).save(fsave_color)



    def bin_image(self):
        try:
            img = self.img_xanes
            s = img.shape
            tmp = self.cb_bin.currentText()
            if tmp == '2 x 2':
                b = 2
            elif tmp == '4 x 4':
                b = 4
            else:
                b = 1
            if s[1]%b or s[2]%b:
                ss = [s[0], s[1]//b*b, s[2]//b*b]
                img = img[:, :ss[1], :ss[2]]
            self.img_xanes = pyxas.bin_ndarray(img, (s[0], s[1]//b, s[2]//b), 'mean')
            self.msg = 'image shape: {0}'.format(self.img_xanes.shape)
            self.update_msg()
            self.update_canvas_img()
        except Exception as err:
            self.msg = f'xanes image not exist. Error: {str(err)}'
            self.update_msg()


    def scale_image(self):
        try:
            tmp = deepcopy(self.canvas1.img_stack)
            scale = float(self.tx_scale_img.text())
            tmp *= scale
            self.img_update = tmp.copy()
            self.update_canvas_img()
            self.msg = f'scale the current image by {scale}'
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            self.cb1.setCurrentText('Image updated')
        except Exception as err:
            self.msg = f'fail to scale image. Error: {str(err)}'
        finally:
            self.update_msg()


    def peak_fit_toggled(self):
        if self.rd_peak_fit_method2.isChecked(): # using polynomial
            self.chkbox_edge.setDisabled(True)
            self.tx_edge_pos.setDisabled(True)
            self.tx_pre_edge_wt.setDisabled(True)
            self.tx_edge_smooth.setDisabled(True)
            self.fit_peak_method = 2
        else:                                    # using spline
            self.chkbox_edge.setEnabled(True)
            self.tx_edge_pos.setEnabled(True)
            self.tx_pre_edge_wt.setEnabled(True)
            self.tx_edge_smooth.setEnabled(True)
            self.fit_peak_method = 1
        QApplication.processEvents()


    def generate_mask1(self):
        try:
            tmp = np.squeeze(self.canvas1.current_img)
            mask = np.ones(tmp.shape)

            tmp1 = self.tx_mask1.text()
            if tmp1[0] == '<':
                thresh = float(tmp1[1:])
                mask[tmp < thresh] = 0
            elif tmp1[0] == '>':
                thresh = float(tmp1[1:])
                mask[tmp > thresh] = 0
            else:
                thresh = float(tmp1)
                mask[tmp > thresh] = 0
            self.canvas1.mask = self.canvas1.mask * mask
            self.mask1 = mask
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            if self.cb1.findText('Mask') < 0:
                self.cb1.addItem('Mask')
            self.pb_mask1.setStyleSheet('color: rgb(200, 50, 50);')
        except Exception as err:
            self.msg = f'invalid mask. Error: {str(err)} '
            self.update_msg()
            self.pb_mask1.setStyleSheet('color: rgb(0,0,0);')


    def generate_mask2(self):
        try:
            tmp = deepcopy(self.canvas1.current_img)
            mask = np.ones(tmp.shape)
            tmp1 = self.tx_mask2.text()
            if tmp1[0] == '<':
                thresh = float(tmp1[1:])
                mask[tmp < thresh] = 0
            elif tmp1[0] == '>':
                thresh = float(tmp1[1:])
                mask[tmp > thresh] = 0
            else:
                thresh = float(tmp1)
                mask[tmp > thresh] = 0
            self.canvas1.mask = self.canvas1.mask * mask
            self.mask2 = mask
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            if self.cb1.findText('Mask') < 0:
                self.cb1.addItem('Mask')
            self.pb_mask2.setStyleSheet('color: rgb(200, 50, 50);')
        except Exception as err:
            self.msg = f'invalid mask. Error: {str(err)} '
            self.update_msg()
            self.pb_mask2.setStyleSheet('color: rgb(0,0,0);')


    def generate_mask3(self):
        try:
            tmp = self.canvas1.current_img
            ratio = float(self.tx_mask3.text())
            s = np.squeeze(tmp).shape
            x = np.arange(s[0])
            y = np.arange(s[1])
            X, Y = np.meshgrid(y, x)
            X = X / s[1]
            Y = Y / s[0]
            mask = np.float32(((X-0.5)**2 + (Y-0.5)**2)<(ratio/2)**2)
            self.canvas1.mask = self.canvas1.mask * mask
            self.mask3 = mask
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            if self.cb1.findText('Mask') < 0:
                self.cb1.addItem('Mask')
            self.pb_mask3.setStyleSheet('color: rgb(200,50,50);')
        except Exception as err:
            self.msg = f'invalid mask. Error: {str(err)} '
            self.update_msg()


    def generate_otsu_mask(self):
        try:
            tmp = self.canvas1.current_img
            filt_sz = int(self.tx_mask_otsu_fz.text())
            iters = int(self.tx_mask_otsu_iter.text())
            bins = int(self.tx_mask_otsu_bin.text())
            reverse = 1 if self.chkbox_mask_otsu.isChecked() else 0
            mask = pyxas.otsu_mask(tmp, filt_sz, iters, bins)
            if reverse:
                mask = 1 - mask
            self.canvas1.mask = self.canvas1.mask * mask
            self.mask_auto = mask
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            if self.cb1.findText('Mask') < 0:
                self.cb1.addItem('Mask')
            self.pb_mask_otsu.setStyleSheet('color: rgb(200,50,50);')
        except Exception as err:
            self.msg = f'invalid mask. Error: {str(err)} '
            self.update_msg()

    def generate_smart_mask(self):
        try:
            self.pb_smart_mask.setEnabled(False)
            self.pb_smart_mask.setText('Wait ...')
            self.pb_smart_mask.setStyleSheet('color: rgb(200, 200, 200);')
            n = int(self.tx_smart_mask_comp.text())
            self.smart_mask_comp = max(n, 2)
            self.tx_smart_mask_comp.setText(str(self.smart_mask_comp))
            QApplication.processEvents()
            canvas = self.canvas1
            if self.chkbox_smask.isChecked():
                st = int(self.tx_smart_mask_start.text())
                en = int(self.tx_smart_mask_end.text())
                img_stack = canvas.img_stack[st:en] * self.mask

                self.smart_mask, self.img_labels = pyxas.kmean_mask(img_stack, self.smart_mask_comp)
            else:
                img_stack = np.squeeze(canvas.current_img * self.mask)
                self.smart_mask, self.img_labels, self.img_compress = pyxas.kmean_mask(img_stack, self.smart_mask_comp)
                if self.cb1.findText('Image compress') < 0:
                    self.cb1.addItem('Image compress')
            if self.cb1.findText('Smart Mask') < 0:
                self.cb1.addItem('Smart Mask')
            if self.cb1.findText('Image Labels') < 0:
                self.cb1.addItem('Image Labels')
            self.cb1.setCurrentText('Smart Mask')
            self.msg = 'Smart Mask generated'
            self.update_canvas_img()

            n_smart_mask = len(self.smart_mask)
            for i in range(n_smart_mask):
                roi_name = f'roi_SM_{i}'
                self.canvas1.roi_add_to_list(roi_name = roi_name)
                #self.msg += f'; {roi_name} added to the ROI list'
            #self.pb_smart_mask.setStyleSheet('color: rgb(200,50,50);')
        except Exception as err:
            self.msg = f'invalid mask. Error: {str(err)} '
            #self.pb_smart_mask.setStyleSheet('color: rgb(0,0,0);')
        finally:
            self.update_msg()
            self.pb_smart_mask.setStyleSheet('color: rgb(0,0,0);')
            self.pb_smart_mask.setText('Gen. Mask')
            self.pb_smart_mask.setEnabled(True)
            QApplication.processEvents()


    def smart_mask_use_img_stack(self):
        if self.chkbox_smask.isChecked():
            s = self.canvas1.img_stack.shape
            if not len(s) == 3:
                st, en = 0, 0
            else:
                st, en = 0, s[0]
            self.tx_smart_mask_start.setText(str(st))
            self.tx_smart_mask_end.setText(str(en))


    def add_smart_mask_toi_roi(self):
        if self.cb1.currentText() == 'Smart Mask':
            self.smart_mask_current = self.smart_mask[self.sl1.value()]
            roi_name = f'roi_SM_{self.sl1.value()}'
            self.canvas1.roi_add_to_list(roi_name = roi_name)
            self.msg = f'{roi_name} has been added to the ROI list'
            self.update_msg()


    def apply_smart_mask(self):
        if self.cb1.currentText() == 'Smart Mask':
            self.smart_mask_current = self.smart_mask[self.sl1.value()]
            self.canvas1.mask = self.canvas1.mask * self.smart_mask_current
            self.mask = self.canvas1.mask
            if self.cb1.findText('Mask') < 0:
                self.cb1.addItem('Mask')
            self.cb1.setCurrentText('Mask')
            self.update_canvas_img()
            roi_name = f'roi_SM_{self.sl1.value()}'
            self.msg = f'{roi_name} has been set to the "Mask"'


    def smart_mask_update_label(self):
        val = np.int8(self.tx_update_img_label.text().split(','))
        img_label = np.zeros(self.img_labels.shape)
        try:
            assert (len(val) == self.smart_mask_comp), 'number of value no equals to number of smart mask component'
            for i in range(self.smart_mask_comp):
                mask = self.smart_mask[i]
                img_label += mask * val[i]

            self.img_labels = img_label.copy()
            self.update_canvas_img()
            del img_label
        except Exception as err:
            self.msg = 'fails to update image label. Error: {str(err)}'
            self.update_msg()


    def rm_mask1(self):
        try:
            self.canvas1.mask = self.mask2 * self.mask3 * self.smart_mask_current * self.mask_auto
            self.mask1 = np.array([1])
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            self.pb_mask1.setStyleSheet('color: rgb(0,0,0);')
        except Exception as err:
            self.msg = f'something wrong in removing mask1. Error: {str(err)}'
            self.update_msg()


    def rm_mask2(self):
        try:
            self.canvas1.mask = self.mask1 * self.mask3 * self.smart_mask_current * self.mask_auto
            self.mask2 = np.array([1])
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            self.pb_mask2.setStyleSheet('color: rgb(0,0,0);')
        except Exception as err:
            self.msg = f'something wrong in removing mask2. Error: {str(err)}'
            self.update_msg()


    def rm_mask3(self):
        try:
            self.canvas1.mask = self.mask1 * self.mask2 * self.smart_mask_current * self.maskauto
            self.mask3 = np.array([1])
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            self.pb_mask3.setStyleSheet('color: rgb(0,0,0);')
        except Exception as err:
            self.msg = f'something wrong in removing mask3. Error: {str(err)}'
            self.update_msg()

    def rm_otsu_mask(self):
        try:
            self.canvas1.mask = self.mask1 * self.mask2 * self.mask3 * self.smart_mask_current
            self.mask_auto = np.array([1])
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            self.pb_mask_otsu.setStyleSheet('color: rgb(0,0,0);')
        except Exception as err:
            self.msg = f'something wrong in removing auto mask. Error: {str(err)}'
            self.update_msg()

    def rm_smart_mask(self):
        try:
            self.canvas1.mask = self.mask1 * self.mask2 * self.mask3
            self.smart_mask_current = np.array([1])
            self.mask = self.canvas1.mask
            self.update_canvas_img()
            self.pb_smart_mask.setStyleSheet('color: rgb(0,0,0);')
        except Exception as err:
            self.msg = f'something wrong in removing smart mask. Error: {str(err)}'
            self.update_msg()


    def mask_dilation(self):
        s = int(self.tx_dilation_iter.text())
        struct = ndimage.generate_binary_structure(2, 1)
        struct = ndimage.iterate_structure(struct, s).astype(int)
        if self.cb1.currentText() == 'Smart Mask':
            try:
                img_index = self.canvas1.current_img_index
                img = self.canvas1.img_stack[img_index]
                self.smart_mask[img_index] = ndimage.binary_dilation(img, structure=struct).astype(img.dtype)
                self.mask = self.mask * self.smart_mask[img_index]
                self.canvas1.mask = self.mask
                self.update_canvas_img()
                #self.canvas1.update_img_one(self.smart_mask[img_index], img_index)
            except Exception as err:
                self.msg = f'fails to perform dilation on "Smart Mask". Error: {str(err)}'
                self.update_msg()
        else:
            try:
                img = np.squeeze(self.canvas1.mask)
                self.mask = ndimage.binary_dilation(img, structure=struct).astype(img.dtype)
                self.canvas1.mask = self.mask
                self.update_canvas_img()
            except Exception as err:
                self.msg = f'fails to perform dilation on "mask". Error:{str(err)}'
                self.update_msg()


    def mask_erosion(self):
        s = int(self.tx_dilation_iter.text())
        struct = ndimage.generate_binary_structure(2, 1)
        struct = ndimage.iterate_structure(struct, s).astype(int)
        if self.cb1.currentText() == 'Smart Mask':
            try:
                img_index = self.canvas1.current_img_index
                img = self.canvas1.img_stack[img_index]
                self.smart_mask[img_index] = ndimage.binary_erosion(img, structure=struct).astype(img.dtype)
                self.mask = self.mask * self.smart_mask[img_index]
                self.canvas1.mask = self.mask
                self.update_canvas_img()
            except Exception as err:
                self.msg = f'fails to perform dilation on "Smart Mask". Error: {str(err)}'
                self.update_msg()
        else:
            try:
                img = np.squeeze(self.canvas1.mask)
                self.mask = ndimage.binary_erosion(img, structure=struct).astype(img.dtype)
                self.canvas1.mask = self.mask
                self.update_canvas_img()
            except Exception as err:
                self.msg = f'fails to perform dilation on "mask". Error: {str(err)}'
                self.update_msg()


    def mask_fillhole(self):
        s = int(self.tx_dilation_iter.text())
        struct = ndimage.generate_binary_structure(2, 1)
        struct = ndimage.iterate_structure(struct, s).astype(int)
        if self.cb1.currentText() == 'Smart Mask':
            try:
                img_index = self.canvas1.current_img_index
                img = self.canvas1.img_stack[img_index]
                self.smart_mask[img_index] = ndimage.binary_fill_holes(img, structure=struct).astype(img.dtype)
                self.mask = self.mask * self.smart_mask[img_index]
                self.canvas1.mask = self.mask
                self.update_canvas_img()
            except Exception as err:
                self.msg = f'fails to perform fill_holes on "Smart Mask". Error: {str(err)}'
                self.update_msg()
        else:
            try:
                img = np.squeeze(self.canvas1.mask)
                self.mask = ndimage.binary_fill_holes(img, structure=struct).astype(img.dtype)
                self.canvas1.mask = self.mask
                self.update_canvas_img()
            except Exception as err:
                self.msg = f'fails to perform dilation on "mask". Error: {str(err)}'
                self.update_msg()


    def _select_xanes_fit_img(self):
        return_flag, img = self.choose_image_for_fittting()
        '''
        if self.dataset_used_for_fitting == 0:
            img = self.img_xanes
        elif self.dataset_used_for_fitting == 1:
            img = self.img_update
        elif self.dataset_used_for_fitting == 2:
            img = self.img_regulation
        else:
            img = []
        '''
        return img


    def _get_roi_selection(self):
        try:
            n = self.tx_fit_roi.text()
            roi_selected = 'roi_' + n

        except Exception as err:
            print(err)
            print(f'{roi_selected} not exist')
            n = '-1'
            roi_selected = 'roi_-1'
        return roi_selected


    def _get_roi_image(self, img, roi_selected):
        try:
            canvas = self.canvas1
            roi_list = canvas.roi_list
            if (type(roi_selected) is str) and ('roi_' in roi_selected) and (not 'SM' in roi_selected) and not (
                    '-1' in roi_selected):
                roi_cord = np.int32(np.array(roi_list[roi_selected][:4]))
                print(f'{roi_cord}')
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                cord = [x1, x2, y1, y2]
                img_stack = img[:, y1:y2, x1:x2]
            else:
                if 'SM' in roi_selected:
                    sm_index = int(roi_selected.split('_')[-1])
                    mask = self.smart_mask[sm_index]
                elif '-1' in roi_selected:
                    mask = self.mask * np.ones((img.shape[1], img.shape[2]))
                else:
                    raise IndexError
                img_stack = img * mask
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
            raise Exception('ROI not exist')
            #img_stack = img.copy()
        return img_stack

    def _get_roi_cord(self, roi_selected):
        canvas = self.canvas1
        roi_list = canvas.roi_list
        if (type(roi_selected) is str) and ('roi_' in roi_selected) and (not 'SM' in roi_selected) and not (
                '-1' in roi_selected):
            roi_cord = np.int32(np.array(roi_list[roi_selected][:4]))
            print(f'{roi_cord}')
            a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
            x1 = min(a, c)
            x2 = max(a, c)
            y1 = min(b, d)
            y2 = max(b, d)
            cord = [x1, x2, y1, y2]
            return cord
        else:
            return None

    def _get_elem(self):
        elem = self.tx_elem.text()
        elem = elem.replace(' ', '')
        elem = elem.replace(';', ',')
        elem = elem.split(',')
        if elem[0] == '':
            elem = []
        return elem


    def _get_roi_fit_title(self, fit_coef, roi_selected, elem):
        fit_coef_sum = np.sum(fit_coef)
        title = f'{roi_selected}:  '
        for i in range(len(fit_coef)):
            try:
                plot_label = elem[i]
            except Exception as err:
                plot_label = f'ref#{i}'
            self.elem_label.append(plot_label)
            title += plot_label + f': {fit_coef[i] / fit_coef_sum:.3f}, '
        return title


    def plot_roi_fit_new(self, return_flag=0):
        try:
            n_iter = int(self.tx_iter_num.text())
            learning_rate = float(self.tx_fit_rate.text())
            bkg_polynomial_order = self.get_bkg_poly_order()

            elem = self._get_elem()
            roi_selected = self._get_roi_selection()
            fit_eng_range = self._get_fit_eng_range()
            img = self._select_xanes_fit_img()

            if len(img):
                img = img[fit_eng_range]
                img = self.smooth(img)
            eng = self.xanes_eng[fit_eng_range]
            img_stack = self._get_roi_image(img, roi_selected)
            img_stack_s = np.mean(np.mean(img_stack, axis=-1), axis=-1)
            img_stack_s = img_stack_s.reshape((len(eng), 1, 1))

            #fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = self.fit_2d_xanes_core(img_stack_s, eng, bkg_polynomial_order, n_iter, learning_rate)
            fit_coef, cost, X, y_fit, y_offset, var, x_interp, y_interp = self.fit_2d_xanes_core(img_stack, eng,
                                                                                                 bkg_polynomial_order,
                                                                                                 n_iter, learning_rate)
            fit_coef = np.squeeze(fit_coef)
            fit_coef = np.mean(fit_coef, axis=(1,2))
            cost = np.mean(cost)
            y_fit = np.squeeze(y_fit)
            y_fit = np.mean(y_fit, axis=1)

            y_offset = np.squeeze(y_offset)
            y_offset = np.mean(y_offset, axis=(1, 2))

            y_interp_mean = np.mean(y_interp, axis=-1)

            title = self._get_roi_fit_title(fit_coef, roi_selected, elem)
            t_color = ['g', 'orange', 'm', 'c', 'y']
            plt.figure()
            legend = []
            line_raw, = plt.plot(eng, np.squeeze(img_stack_s), 'b.', label='Experiment data')
            #line_fit = plt.plot(eng, y_fit, color='r', label='Fitted')
            line_fit = plt.plot(x_interp, y_interp_mean, color='r', label='Fitted')
            legend.append(line_raw)
            legend.append(line_fit)
            ref_offset = {}
            if self.chkbox_overlay_ref.isChecked():
                line_ref = {}
                for i in range(self.num_ref):
                    try:
                        ref_name = elem[i]
                    except:
                        ref_name = f'ref{i}'
                    x_ref = self.spectrum_ref[ref_name][:, 0]
                    y_ref = self.spectrum_ref[ref_name][:, 1]
                    offset_ref = pyxas.fit1D(eng, y_offset, x_ref, 3, smooth=0.01)
                    y_plot = y_ref * fit_coef[i] + offset_ref
                    line_ref[ref_name] = plt.plot(x_ref, y_plot, alpha=0.6, color=t_color[i%5], label=ref_name)
                    legend.append(line_ref[ref_name])
                    ref_offset[i] = {}
                    ref_offset[i]['x'] = x_ref
                    ref_offset[i]['y'] = y_plot
            plt.xlim([eng[0] - 0.02, eng[-1] + 0.02])
            #plt.legend(handles=legend)
            plt.legend()
            plt.title(title)
            plt.show()
            fit_success = 1
            if return_flag:
                return eng, np.squeeze(img_stack_s), y_fit, fit_coef, ref_offset, roi_selected, fit_success
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()
            fit_success = 0
            if return_flag:
                return 0, 0, 0, 0, 0, 0, fit_success


    def export_roi_fit(self):
        x_data, y_data, y_fit, fit_coef, ref_offset, cord, fit_success = self.plot_roi_fit_new(return_flag=1)
        dir_path = self.fpath + '/ROI_fit'

        if fit_success:
        #if make_directory_success and fit_success:
            n = self.tx_fit_roi.text()
            n_fit = len(y_fit)
            if n_fit == len(self.xanes_eng):
                n_fit += 1
            label_raw = 'roi_' + n
            label_fit = label_raw + '_fit'
            fn_spec = dir_path + '/' + 'spectrum_' + label_fit + '.txt'
            #fn_cord = dir_path + '/' + 'coordinates_' + label_fit + '.txt'
            roi_dict_spec = {}
            roi_dict_spec['X_eng'] = pd.Series(np.round(self.xanes_eng[:n_fit], 7))
            roi_dict_spec[label_raw] = pd.Series(np.round(y_data, 7))
            roi_dict_spec[label_fit] = pd.Series(np.round(y_fit, 7))

            n_ref = len(ref_offset)
            for i in range(n_ref):
                roi_dict_spec[f'ref{i}_eng'] = pd.Series(np.round(ref_offset[i]['x'], 7))
                roi_dict_spec[f'ref{i}_spec'] = pd.Series(np.round(ref_offset[i]['y'], 7))

            roi_dict_spec[label_raw + '_fit_coef'] = pd.Series(fit_coef)

            df_spec = pd.DataFrame(roi_dict_spec)
            df_spec.fillna(0, inplace=True)
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'txt files (*.txt)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
            if fn[-4:] == '.txt':
                fn_spec = fn
            else:
                fn_spec = fn + '.txt'
            with open(fn_spec, 'w') as f:
                df_spec.to_csv(f, float_format='%.7f', sep=',', index=False)
            # replace 0.0000000 with empty string
            with open(fn_spec, 'r') as f:
                fd = f.read()
            fd = fd.replace('0.0000000', ' '*9)
            with open(fn_spec, 'w') as f:
                f.write(fd)
            self.msg = 'Fitted ROI spectrum file saved:    ' + fn_spec
            self.update_msg()
        else:
            self.msg = 'export fails'
            self.update_msg()


    def select_file(self):
        self.tx_hdf_xanes.setEnabled(True)
        self.tx_hdf_eng.setEnabled(True)


    def noise_removal(self):
        try:
            canvas = self.canvas1
            #img = canvas.current_img.copy()
            img = canvas.img_stack.copy()
            noise_level = float(self.tx_rm_noise_level.text())
            filter_size = int(self.tx_rm_noise_size.text())
            n = img.shape[0]
            self.img_rm_noise = np.zeros(img.shape)
            self.pb_rm_noise.setEnabled(False)
            QApplication.processEvents()
            for i in trange(n):
                self.img_rm_noise[i] = pyxas.rm_noise2(img[i], noise_level, filter_size)
                self.msg = f'Median filter2 denoising for image #{i + 1}/{n}'
                self.update_msg()
                QApplication.processEvents()
            if self.cb1.findText('Noise removal') < 0:
                self.cb1.addItem('Noise removal')
            self.cb1.setCurrentText('Noise removal')
            self.update_canvas_img()
            self.msg = 'Noise removed'
        except Exception as err:
            self.msg = f'fails to remove noise. Error: {str(err)}'
        finally:
            self.pb_rm_noise.setEnabled(True)
            self.update_msg()
            QApplication.processEvents()

    def noise_removal_nl(self):
        try:
            canvas = self.canvas1
            #img = canvas.current_img.copy()
            img = canvas.img_stack.copy()
            patch_dis = int(self.tx_rm_noise_nl_patch_dis.text())
            patch_size = int(self.tx_rm_noise_nl_patch_size.text())
            n = img.shape[0]
            img_d = img.copy()
            self.pb_rm_noise_nl.setEnabled(False)
            self.img_rm_noise = np.zeros(img.shape)
            for i in trange(n):
                self.img_rm_noise[i] = pyxas.img_denoise_nl(img[i], patch_size, patch_dis)[0]
                self.msg = f'Non-local mean denoising for image #{i+1}/{n}'
                self.update_msg()
                QApplication.processEvents()
            if self.cb1.findText('Noise removal') < 0:
                self.cb1.addItem('Noise removal')
            self.cb1.setCurrentText('Noise removal')
            self.update_canvas_img()
            self.msg = 'Noise removed'
        except Exception as err:
            self.msg = f'fails to remove noise. Error: {str(err)}'
        finally:
            self.pb_rm_noise_nl.setEnabled(True)
            self.update_msg()
            QApplication.processEvents()

    def convert_percentage_image(self):
        try:
            p_min = float(self.tx_cvt_min.text())
            p_max = float(self.tx_cvt_max.text())
            img = self.xanes_peak_fit.copy()
            self.peak_percentage = pyxas.rm_abnormal((img - p_min) / (p_max - p_min))
            if self.cb1.findText('Peak percentage') < 0:
                self.cb1.addItem('Peak percentage')
            self.cb1.setCurrentText('Peak percentage')
        except Exception as err:
            self.msg = f'fails to convert. Error: {str(err)}'
            self.update_msg()


    def fit_edge_curve(self):
        from scipy.interpolate import UnivariateSpline
        try:
            x, y = self.external_spec[:,0], self.external_spec[:,1]
            if self.tx_edge_s.text():
                xs = float(self.tx_edge_s.text())
            else:
                xs = x[0]
                self.tx_edge_s.setText(f'{xs}')
            if self.tx_edge_e.text():
                xe = float(self.tx_edge_e.text())
            else:
                xe = x[-1]
                self.tx_edge_e.setText(f'{xe}')
            if self.tx_edge_order.text():
                k = int(self.tx_edge_order.text())
            else:
                k = 2
            k = np.min([k, 3])

            self.tx_edge_order.setText(f'{k}')
            try:
                x0 = float(self.tx_edge_pos.text())
            except Exception as err:
                print(err)
                x0 = xs
            xs_id = pyxas.find_nearest(x, xs)
            xe_id = pyxas.find_nearest(x, xe)
            x0_id = pyxas.find_nearest(x, x0)
            x = x[xs_id: xe_id]
            y = y[xs_id: xe_id]
            w = float(self.tx_pre_edge_wt.text())
            wt = np.ones(len(x))
            wt[:x0_id - xs_id] = w
            edge_smooth = float(self.tx_edge_smooth.text())
            s = UnivariateSpline(x, y, k=k, s=edge_smooth, w=wt)
            xx = np.linspace(x[0], x[-1], 1001)
            y_eval = s(xx)
            pos = np.argmax(np.abs(np.diff(y_eval)))
            if self.rd_peak_max.isChecked():
                factor = 1
            else:
                factor = -1
            pos_max = np.argmax(y_eval*factor)
            plt.figure()
            plt.plot(x, y, '.', label='experiment data')
            plt.plot(xx, y_eval, 'r', label='fitting')
            plt.plot(xx[pos], y_eval[pos], 'rx',markersize=10, label=f'x = {xx[pos]:2.6f}')
            plt.plot(xx[pos_max], y_eval[pos_max], 'g+', markersize=16, label=f'x = {xx[pos_max]:2.6f}')
            plt.legend()
            plt.title('Curve fitting')
            plt.show()
        except Exception as err:
            self.msg = f'Fails to fit curve. Error: {str(err)}'
            self.update_msg()


    def find_edge_peak_single(self):
        try:
            k = int(eval(self.tx_edge_order.text()))
            x, y, _, roi_selected = self.extract_roi_spectrum_data(use_current_image=1)
            try:
                xs = float(self.tx_edge_s.text())
            except Exception as err:
                print(err)
                xs = 0
            try:
                xe = float(self.tx_edge_e.text())
            except Exception as err:
                print(err)
                xe = len(y)
            try:
                x0 = float(self.tx_edge_pos.text())
            except Exception as err:
                print(err)
                x0 = xs
            try:
                xs_id = pyxas.find_nearest(self.xanes_eng, xs)
            except Exception as err:
                print(err)
                xs_id = 0
            try:
                xe_id = pyxas.find_nearest(self.xanes_eng, xe)
            except Exception as err:
                print(err)
                xe_id = len(y)
            try:
                x0_id = pyxas.find_nearest(self.xanes_eng, x0)
            except Exception as err:
                print(err)
                x0_id = 0

            if self.xanes_eng[-1] < self.xanes_eng[0]:
                t = xs_id
                xs_id = xe_id
                xe_id = t

            x = x[xs_id: xe_id]
            y = y[xs_id: xe_id]
            if x[-1] < x[0]:
                x = x[::-1]
                y = y[::-1]
            w = float(self.tx_pre_edge_wt.text())
            wt = np.ones(len(x))
            wt[:x0_id - xs_id] = w
            edge_smooth = float(self.tx_edge_smooth.text())
            if self.rd_peak_max.isChecked():
                factor = 1
            else:
                factor = -1
            if self.fit_peak_method == 1:             # spline

                res = pyxas.fit_peak_curve_spline(x, y*factor, fit_order=k, smooth=edge_smooth, weight=wt)
                spl = res['spl']
                xx = res['xx']
                y_eval = spl(xx) * factor
                peak_pos = res['peak_pos']
                peak_val = res['peak_val'] * factor
                edge_pos = res['edge_pos']
                edge_val = res['edge_val'] * factor
            else:                                     # method 2: polynormial
                res = pyxas.fit_peak_curve_poly(x, y*factor, fit_order=k, num=10001)
                xx = np.linspace(x[0], x[-1], 10001)
                y_eval = res['matrix_Y'].flatten() * factor
                peak_pos = np.squeeze(res['peak_pos'])
                peak_val = np.squeeze(res['peak_val']) * factor

            plt.figure()
            plt.plot(x, y, '.', label='experiment data')
            plt.plot(xx, y_eval, 'r', label='fitting')
            plt.plot(peak_pos, peak_val, 'g+', markersize=16, label=f'x = {peak_pos:2.6f}')
            if self.chkbox_edge.isChecked and self.chkbox_edge.isEnabled():
                plt.plot(edge_pos, edge_val, 'rx',markersize=10, label=f'x = {edge_pos:2.6f}')
            plt.legend()
            plt.title(roi_selected)
            plt.show()
            self.msg = 'roi curve fitting successfully'
            self.update_msg()
        except Exception as err:
            self.msg = f'Fails to find edge for ROI. Error: {str(err)}'
            self.update_msg()
            print(err)


    def find_edge_peak_image(self):
        try:
            self.pb_find_edge_img.setEnabled(False)
            self.msg = 'Fitting image, it may take few miniuts, please wait ...'
            self.update_msg()
            QApplication.processEvents()
            try:
                fit_order = int(self.tx_edge_order.text())
            except Exception as err:
                print(err)
                fit_order = 3
                self.tx_edge_order.setText('3')
            img = self.canvas1.img_stack.copy()
            img = self.smooth(img * self.mask)
            try:
                xs = float(self.tx_edge_s.text())
            except Exception as err:
                print(err)
                xs = 0
            try:
                xe = float(self.tx_edge_e.text())
            except Exception as err:
                print(err)
                xe = len(img)
            k = int(self.tx_edge_order.text())
            try:
                x0 = float(self.tx_edge_pos.text())
            except Exception as err:
                print(err)
                x0 = xs
            try:
                xs_id = pyxas.find_nearest(self.xanes_eng, xs)
            except Exception as err:
                print(err)
                xs_id = 0
            try:
                xe_id = pyxas.find_nearest(self.xanes_eng, xe)
            except Exception as err:
                print(err)
                xe_id = len(img)
            try:
                x0_id = pyxas.find_nearest(self.xanes_eng, x0)
            except Exception as err:
                print(err)
                x0_id = 0
            eng = self.xanes_eng
            if eng[-1] < eng[0]:
                t = xs_id
                xs_id = xe_id
                xe_id = t

            img = img[xs_id:xe_id]
            s = img.shape

            if len(eng):
                x = eng[xs_id:xe_id]
            else:
                x = np.arange(len(img))

            if x[-1] < x[0]:
                x = x[::-1]
                img = img[::-1]
            self.xanes_edge_fit = np.zeros([1, s[1], s[2]])
            self.xanes_peak_fit = np.zeros([1, s[1], s[2]])
            self.xanes_peak_fit_height = np.zeros([1, s[1], s[2]])
            self.xanes_peak_fit_err = np.zeros([1, s[1], s[2]])
            self.spl = {}
            if self.rd_peak_max.isChecked():
                factor = 1
            else:
                factor = -1
            time_s = time.time()
            if self.fit_peak_method == 1:# spline
                xx = np.linspace(x[0], x[-1], 1001)
                wt = np.ones(len(x))
                w = float(self.tx_pre_edge_wt.text())
                wt[:x0_id - xs_id] = w
                try:
                    edge_smooth = float(self.tx_edge_smooth.text())
                except Exception as err:
                    print(err)
                    edge_smooth = 0.001
                    self.tx_edge_smooth.setText('0.001')
                for i in range(s[1]):
                    if not i % 10:
                        print(f'row # {i:4d}: {time.time() - time_s:3.2f} sec')
                    for j in range(s[2]):
                        y = img[:, i, j]
                        res = pyxas.fit_peak_curve_spline(x, y * factor, fit_order=fit_order, smooth=edge_smooth, weight=wt)
                        spl = res['spl']
                        xx = res['xx']
                        # y_eval = spl(xx) * factor
                        peak_pos = res['peak_pos']
                        peak_val = res['peak_val'] * factor
                        edge_pos = res['edge_pos']

                        # edge_val = res['edge_val'] * factor
                        self.xanes_edge_fit[0, i,j] = edge_pos
                        self.xanes_peak_fit[0, i,j] = peak_pos
                        self.xanes_peak_fit_height[0, i, j] = peak_val
                        self.spl[f'{i},{j}'] = res['spl']
                self.fit_edge_peak_res['method'] = 'spline'
                self.fit_edge_peak_res['spl'] = self.spl
            else:   # polynormial
                s0 = img.shape
                y = img.reshape([s0[0], -1])
                res = pyxas.fit_peak_curve_poly(x, y * factor, fit_order=fit_order, num=1001)
                self.xanes_peak_fit[0] = res['peak_pos'].reshape([s0[1], s0[2]])
                self.xanes_peak_fit_height[0] = res['peak_val'].reshape([s0[1], s0[2]]) * factor
                self.xanes_peak_fit_err[0] = res['fit_error'].reshape([s0[1], s0[2]])
                self.fit_edge_peak_res = res.copy()
                self.fit_edge_peak_res['method'] = 'poly'

            if self.chkbox_edge.isChecked() and self.chkbox_edge.isEnabled():
                if self.cb1.findText('XANES Edge Fit') < 0:
                    self.cb1.addItem('XANES Edge Fit')
                self.cb1.setCurrentText('XANES Edge Fit')
            if self.chkbox_peak.isChecked():
                if self.cb1.findText('XANES Peak Fit') < 0:
                    self.cb1.addItem('XANES Peak Fit')
                if self.cb1.findText('XANES Peak Fit Height') < 0:
                    self.cb1.addItem('XANES Peak Fit Height')
                if self.cb1.findText('XANES Peak Fit error') < 0:
                    self.cb1.addItem('XANES Peak Fit error')
                self.cb1.setCurrentText('XANES Edge Fit Height')
            self.msg = 'Image fitting finished'
        except Exception as err:
            self.msg = f'Fails in fitting image. Error: {str(err)}'
            print(err)
        finally:
            self.pb_find_edge_img.setEnabled(True)
            QApplication.processEvents()
            self.update_msg()


    def extract_roi_spectrum_data(self, use_current_image = 0):
        x = self.xanes_eng
        y = []
        try:
            canvas = self.canvas1
            if use_current_image:
                img = canvas.img_stack
            else:
                if self.dataset_used_for_fitting == 0:
                    img = deepcopy(self.img_xanes)
                elif self.dataset_used_for_fitting == 1:
                    img = deepcopy(self.img_update)
                elif self.dataset_used_for_fitting == 2:
                    img = deepcopy(self.img_regulation)
                else:
                    img = canvas.img_stack

            img = self.smooth(img * self.mask)

            roi_list = canvas.roi_list
            roi_selected = f'roi_{int(self.tx_overlay_roi.text())}'
            roi_cord = np.int32(np.array(roi_list[roi_selected][:4]))
            print(f'{roi_cord}')
            a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
            x1 = min(a, c)
            x2 = max(a, c)
            y1 = min(b, d)
            y2 = max(b, d)
        except Exception as err:
            x1, x2 = 0, img.shape[2]
            y1, y2 = 0, img.shape[1]
            roi_selected = 'image average'
            print(f'err in "extract_roi_spectrum_data":\n{str(err)}')
        if len(self.mask) == 1:
            y_data = np.mean(np.mean(img[:, y1:y2, x1:x2], axis=1), axis=1)
        else:
            n = np.sum(self.mask[y1:y2, x1:x2])
            y_data = np.sum(np.sum(img[:, y1:y2, x1:x2], axis=1), axis=1) / n
        if len(x) == 0:
            x = np.arange(len(y_data))
        cord = [y1, y2, x1, x2]
        return x, y_data, cord, roi_selected


    def plot_fit_edge_peak_roi(self):
        try:
            xs = float(self.tx_edge_s.text())
            xe = float(self.tx_edge_e.text())
            x0 = float(self.tx_edge_pos.text())

            xs_id = pyxas.find_nearest(self.xanes_eng, xs)
            xe_id = pyxas.find_nearest(self.xanes_eng, xe)
            x0_id = pyxas.find_nearest(self.xanes_eng, x0)

            w = float(self.tx_pre_edge_wt.text())

            x, y, cord, roi_selected = self.extract_roi_spectrum_data()
            x = x[xs_id:xe_id]
            y = y[xs_id:xe_id]
            xx = np.linspace(x[0], x[-1], 1001)
            wt = np.ones(len(x))
            wt[:x0_id - xs_id] = w

            row = np.arange(cord[0], cord[1])
            col = np.arange(cord[2], cord[3])
            y_eval = 0
            n = 0
            for i in row:
                for j in col:
                    y_eval += self.spl[f'{int(i)},{int(j)}'](xx)
                    n += 1
            y_eval /= n
            plt.figure()
            plt.plot(x, y, '.', label='experiment data')
            plt.plot(xx, y_eval, 'r', label='fitting')
            plt.legend()
            plt.title(roi_selected)
            plt.show()
        except Exception as err:
            print(err)


    def load_comb_xanes_img(self):
        items_img = [self.lst_comb_img.item(x).text() for x in range(self.lst_comb_img.count())]
        items_eng = [self.lst_comb_eng.item(x).text() for x in range(self.lst_comb_eng.count())]
        attr_img = self.tx_comb_h5_img.text()
        attr_eng = self.tx_comb_h5_eng.text()
        options = QFileDialog.DontUseNativeDialog
        file_type = "h5 file (*.h5);;Images (*.tiff)"
        fn, _ = QFileDialog.getOpenFileName(xanes, "Open image file", ".", file_type, options=options)
        if fn:
            fn_short = fn.split('/')[-1]
            f_type = fn_short.split('.')[-1]
            if not fn_short in items_img:
                self.lst_comb_img.addItem(fn_short)
                if f_type == 'h5':
                    with h5py.File(fn, 'r') as hf:
                        keys = list(hf.keys())
                    if attr_eng in keys:
                        self.lst_comb_eng.addItem(fn_short)
                        self.dict_comb_xanes['eng'][fn_short] = {'path':fn, 'type':'h5', 'attr':attr_eng}
                else: # tiff
                    attr_img = 'None'
                self.dict_comb_xanes['img'][fn_short] = {'path': fn, 'type': f_type, 'attr': attr_img}


    def load_comb_xanes_eng(self):
        attr_eng = self.tx_comb_h5_eng.text()
        options = QFileDialog.DontUseNativeDialog
        file_type = "txt (*.txt);;h5 file (*.h5)"
        fn, _ = QFileDialog.getOpenFileName(xanes, "Open X_Eng file", ".", file_type, options=options)
        if fn:
            fn_short = fn.split('/')[-1]
            f_type = fn_short.split('.')[-1]
            if f_type == 'h5':
                with h5py.File(fn, 'r') as hf:
                    keys = list(hf.keys())
                attr_eng = self.tx_comb_h5_eng.text()
                if attr_eng in keys:
                    self.lst_comb_eng.addItem(fn_short)
            elif f_type == 'txt':
                self.lst_comb_eng.addItem(fn_short)
                attr_eng = 'None'
            self.dict_comb_xanes['eng'][fn_short] = {'path':fn, 'type':f_type, 'attr':attr_eng}

    def remove_comb_xanes_single(self, mode):
        if mode == 'img':
            list_widget = self.lst_comb_img
        elif mode == 'eng':
            list_widget = self.lst_comb_eng
        else:
            return
        items = list_widget.selectedItems()
        for item in items:
            list_widget.takeItem(list_widget.row(item))
            fn_short = item.text()
            self.dict_comb_xanes[mode].pop(fn_short)

    def remove_comb_xanes_all(self):
        self.lst_comb_img.clear()
        self.lst_comb_eng.clear()
        self.dict_comb_xanes = {'img': {}, 'eng': {}}
    def combine_xanes(self):
        img_comb = {}
        eng_comb = {}
        n_img = self.lst_comb_img.count()
        n_eng = self.lst_comb_eng.count()
        try:
            self.pb_comb.setEnabled(False)
            self.pb_comb.setText('wait ...')
            QApplication.processEvents()
            if n_img != n_eng:
                self.msg = 'number of image file != energy file'
            else:
                for i in range(n_img):
                    fn_img = self.lst_comb_img.item(i).text()
                    fn_eng = self.lst_comb_eng.item(i).text()
                    img_comb[i] = self.get_comb_xanes_data(fn_img, mode='img')
                    eng_comb[i] = self.get_comb_xanes_data(fn_img, mode='eng')
                img = np.concatenate([img_comb[i] for i in range(n_img)])
                eng = np.concatenate([eng_comb[i] for i in range(n_img)])
                eng, img = self.sort_and_remove_redundant(eng, img)

                fn_save = self.save_comb_xanes_img_eng(eng, img)
                self.msg = f'file saved to {fn_save}'
        except Exception as err:
            self.msg = str(err)
            print(err)
        finally:
            self.update_msg()
            self.pb_comb.setText('Combine and save')
            self.pb_comb.setEnabled(True)
            QApplication.processEvents()

    def save_comb_xanes_img_eng(self, eng, img):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'hdf files (*.h5)'
        fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
        if fn[-3:] != '.h5':
            fn += '.h5'
        with h5py.File(fn, 'w') as hf:
            hf.create_dataset('X_eng', data=eng)
            hf.create_dataset('img_xanes', data=img.astype(np.float32))
        return fn


    def sort_and_remove_redundant(self, eng, img):
        idx = np.argsort(eng)
        img = img[idx]
        eng = eng[idx]
        n = len(eng)
        for i in reversed(range(1, n)):
            if eng[i] == eng[i-1]:
                img = np.delete(img, i, 0)
                eng = np.delete(eng, i, 0)
        return eng, img

    def get_comb_xanes_data(self, fn, mode):
        try:
            fn_full = self.dict_comb_xanes[mode][fn]['path']
            fn_type = self.dict_comb_xanes[mode][fn]['type']
            if fn_type == 'h5':
                attr = self.dict_comb_xanes[mode][fn]['attr']
                with h5py.File(fn_full, 'r') as hf:
                    data = np.array(hf[attr])
            else: # tiff or 'txt'
                if mode == 'img':
                    data = io.imread(fn_full)
                else: # txt for energy
                    data = np.loadtxt(fn_full)
        except Exception as err:
            data = None
            self.msg = str(err)
            self.update_msg()
            print(str(err))
        return data

    def xanes_apply_color_scale(self):
        self.xanes_colormix()


    def xanes_color_scale_up(self):
        current_scale = float(self.tx_color_scale.text())
        if current_scale >= 1:
            self.tx_color_scale.setText(f'{current_scale+1:2.1f}')
        else:
            self.tx_color_scale.setText(f'{current_scale+0.1:2.1f}')
        self.xanes_colormix()

    def xanes_color_scale_down(self):
        current_scale = float(self.tx_color_scale.text())
        if current_scale >= 2:
            self.tx_color_scale.setText(f'{current_scale - 1:2.1f}')
        elif current_scale > 0.1:
            self.tx_color_scale.setText(f'{current_scale - 0.1:2.1f}')
        self.xanes_colormix()


    def xanes_colormix(self):
        try:
            self.msg = ''
            self.update_msg()
            canvas = self.canvas1
            color = self.tx_fit_color.text()
            color = pyxas.convert_color_string(color)
            color_vec = pyxas.convert_rgb_vector(color)
            self.color_vec = color_vec
            if len(self.img_colormix_raw) == 0:
                try:
                    img = canvas.img_stack * canvas.mask
                    self.img_colormix_raw = deepcopy(img)
                except Exception as err:
                    print(err)
                    img = []
                """
                if not len(img) == len(self.spectrum_ref):
                    '''
                    self.msg = 'invalid image stack for colormix, will using "XANES fit (concentration)" to demonstrate'
                    img = self.xanes_2d_fit * self.mask1 * self.mask2 * self.img_pre_edge_sub_mean
                    self.update_msg()
                    self.img_colormix_raw = deepcopy(img)
                    '''
                    self.cb_color_channel.clear()
                    for i in range(len(img)):
                        self.cb_color_channel.addItem(str(i))
                """
            else:
                img = deepcopy(self.img_colormix_raw)

            # set color scale for selected color channel
            scale = float(self.tx_color_scale.text())
            #selected_channel = int(self.cb_color_channel.currentText())
            selected_channel = int(self.cb_color_channel.currentIndex())
            img[selected_channel] *= scale
            cmax = np.float32(self.tx_cmax.text())
            cmin = np.float32(self.tx_cmin.text())
            img = (img-cmin) / (cmax-cmin)
            img_color = pyxas.convert_rgb_img(img, color_vec)
            self.img_colormix = deepcopy(img_color)
            if len(self.spectrum_ref) == 2:
                newcmp = pyxas.create_binary_color_cmp(color)
                plt.figure()
                plt.imshow(img_color, cmap=newcmp)
                plt.colorbar()
                plt.axis('off')
                plt.show()
            print('plot the colormix ')
            #self.img_colormix = pyxas.convert_rgb_img(self.img_colormix_raw, color_vec)
            self.img_colormix = pyxas.convert_rgb_img(img, color_vec)
            #self.img_colormix = self.img_colormix_raw.copy()

            if self.cb1.findText('Color mix') < 0:
                self.cb1.addItem('Color mix')
                self.cb1.setCurrentText('Color mix')
            else:
                self.cb1.setCurrentText('Color mix')
                self.update_canvas_img()
        except Exception as err:
            print(err)

    def batch_colormix_open_file(self):
        try:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = '*.*'
            fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", '*', options=options)
            if fn:
                fn_tmp = fn.split('/')
                fn_short = fn_tmp[-1]
                file_type = fn_short.split('.')[-1]
                file_prefix = fn_short.split('_')[0]
                if len(file_prefix) > 4:
                    file_prefix = file_prefix[:4]
                self.batch_color_file_path = '/'.join(t for t in fn_tmp[:-1])
                self.batch_color_files = pyxas.retrieve_file_type(self.batch_color_file_path,
                                                                  file_prefix, file_type)
                n_file = len(self.batch_color_files)
                self.load_file_batch_color_successfull = 1
                msg = f'{n_file} file loaded: {fn_short} ...'
                self.tx_batch_color_folder.setText(fn)
            else:
                self.load_file_batch_color_successfull = 0
                self.batch_color_files = []
                msg = 'fail to load files'
        except Exception as err:
            print(err)
            msg = str(err)
            self.batch_color_files = []
            self.load_file_batch_color_successfull = 0
        finally:
            self.lb_batch_color_msg.setText(msg)


    def batch_colormix(self):
        try:
            msg = ''
            cmin = float(self.tx_batch_color_cmin.text())
            cmax = float(self.tx_batch_color_cmax.text())
            color = self.tx_batch_color.text()
            if self.load_file_batch_color_successfull:
                self.pb_batch_color.setEnabled(False)
                self.pb_batch_color.setText('wait ...')
                files = self.batch_color_files
                n = len(files)
                for i in range(n):
                    fn = files[i]
                    msg = f'[{i+1}/{n}]: processing {fn.split("/")[-1]} ...'
                    self.lb_batch_color_msg.setText(msg)
                    QApplication.processEvents()
                    img = io.imread(fn)
                    img = pyxas.check_and_swap_img_axis(img)
                    fn_split = fn.split('/')
                    fsave_root = '/'.join(i for i in fn_split[:-1])
                    fn_short = fn_split[-1]
                    fn_short = fn_short.split('.')[0]
                    fn_short = fn_short.split('_')[-1]
                    fn_save = f'colormix_{fn_short}'
                    self.colormix_and_save(img, color, clim=[cmin, cmax],
                                           fsave_root=f'{fsave_root}/colormix',
                                           fn_save=fn_save)

                msg = 'Batch colormix finished'
            else:
                msg = 'File load unsuccessfull :('

        except Exception as err:
            print(err)
            msg = str(err)
        finally:
            self.pb_batch_color.setText('Batch colormix (Tiff only)')
            self.pb_batch_color.setEnabled(True)
            self.lb_batch_color_msg.setText(msg)
            QApplication.processEvents()




    def save_2Dfit(self):
        pre_s = float(self.tx_fit_pre_s.text())
        pre_e = float(self.tx_fit_pre_e.text())
        post_s = float(self.tx_fit_post_s.text())
        post_e = float(self.tx_fit_post_e.text())
        label = self.elem_label
        mask = self.canvas1.mask
        s = mask.shape
        if len(s) == 2:
            mask = mask.reshape(1, s[0], s[1])
        img = self.xanes_2d_fit  #/ np.sum(self.xanes_2d_fit, axis=0, keepdims=True)
        img_sum = np.sum(img, axis=0, keepdims=True)
        img_sum[np.abs(img_sum) < 1e-6] = 1e6
        img = img / img_sum
        img = pyxas.rm_abnormal(img)
        if not label:
            label = [f'ref{i}' for i in range(self.num_ref)]
        try:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'hdf files (*.h5)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
            if fn[-3:] != '.h5':
                fn += '.h5'
            with h5py.File(fn, 'w') as hf:
                hf.create_dataset('X_eng', data=self.xanes_eng)
                hf.create_dataset('pre_edge', data=[pre_s, pre_e])
                hf.create_dataset('post_edge', data=[post_s, post_e])
                hf.create_dataset('unit', data='keV')
                for key, val in self.data_summary.items():
                    try:
                        attr_name = key.replace(' ', '_')
                        hf.create_dataset(attr_name, data = np.array(val, dtype=np.float32))
                    except Exception as err:
                        print(err)
                for i in range(self.num_ref):
                    hf.create_dataset(f'ref{i}', data=self.spectrum_ref[f'ref{i}'])

            msg = f'xanes_fit has been saved to file: "{fn}" and append to ".../{self.fn_raw_image.split("/")[-1]}"'
            msg = textwrap.fill(msg, 100)
            print(msg)
            self.msg = msg
        except Exception as err:
            self.msg = f'file saving fails. Error: {str(err)}'
        finally:
            self.update_msg()


    def remove_bkg(self):
        '''
        Treat if it is fluorescent image.
        calculate the mean value of 5% of the lowest pixel value, and substract this value from the whole image
        '''
        self.pb_rmbg.setText('Remove backgroud ...')
        self.pb_rmbg.setEnabled(False)
        QApplication.processEvents()

        canvas = self.canvas1
        img_stack = deepcopy(canvas.img_stack)

        roi_list = canvas.roi_list
        try:
            roi_spec = 0
            num = len(self.lst_roi.selectedItems())
            for item in self.lst_roi.selectedItems():
                print(item.text())
                roi_cord = np.int32(roi_list[item.text()][:4])
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                roi_spec += np.mean(np.mean(img_stack[:, y1:y2, x1:x2, ], axis=1), axis=1)
            roi_spec = roi_spec / num
            for i in range(img_stack.shape[0]):
                if self.chkbox_rmbg.isChecked():
                    img_stack[i] /= roi_spec[i]
                    img_stack[i] = pyxas.rm_abnormal(img_stack[i])
                else:
                    img_stack[i] -= roi_spec[i]
            self.img_update = deepcopy(img_stack)
            del img_stack
            self.msg = 'Background removed '
        except Exception as err:
            self.msg = f'fails in remove background using ROI. Error: {str(err)}'
        finally:
            self.update_msg()
            self.pb_rmbg.setEnabled(True)
            self.pb_rmbg.setText('Remove Bkg. (ROI) ')
            QApplication.processEvents()
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            self.cb1.setCurrentText('Image updated')
            self.update_canvas_img()


    def xanes_img_smooth(self):
        self.pb_filt.setEnabled(False)
        self.pb_filt.setText('Smoothing ...')
        QApplication.processEvents()
        self.smooth_param['kernal_size'] = int(self.tx_filt.text())
        self.smooth_param['flag'] = 1
        self.update_canvas_img()
        self.pb_filt.setEnabled(True)
        self.pb_filt.setText('Median filter')
        self.msg = 'Image smoothed'
        self.update_msg()
        QApplication.processEvents()


    def smooth(self, img, axis=0):
        img_stack = deepcopy(img)
        if self.smooth_param['flag'] == 1:
            try:
                kernal_size = self.smooth_param['kernal_size']
                if kernal_size > 1:
                    img_stack = pyxas.img_smooth(img_stack, kernal_size, axis=axis)
            except Exception as err:
                self.msg = f'image smoothing fails. Error: {str(err)}'
                self. update_msg()
            finally:
                self.smooth_param['flag'] = 0
        return img_stack


    def get_roi_mask(self, roi_list, roi_item, roi_shape):
        if 'SM' in roi_item.text():
            sm_index = int(roi_item.text().split('_')[-1])
            mask_roi = self.smart_mask[sm_index]
            mask_type = 'SM'
        else:
            if len(roi_shape) == 3:
                mask_roi = np.zeros([roi_shape[1], roi_shape[2]])
            else:
                mask_roi = np.zeros([roi_shape[0], roi_shape[1]])
            roi_cord = np.int32(np.array(roi_list[roi_item.text()][:4]))
            a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
            x1 = min(a, c)
            x2 = max(a, c)
            y1 = min(b, d)
            y2 = max(b, d)
            mask_roi[y1:y2, x1:x2] = 1
            mask_type = 'ROI'
        return mask_roi, mask_type


    def plot_spectrum(self):
        canvas = self.canvas1
        img_stack = deepcopy(canvas.img_stack)
        roi_shape = img_stack.shape
        plt.figure()
        roi_color = canvas.roi_color
        roi_list = canvas.roi_list
        x = self.xanes_eng
        if len(x) != len(img_stack):
            x = np.arange(len(img_stack))
        legend = []
        try:
            if len(self.lst_roi.selectedItems()):
                for item in self.lst_roi.selectedItems():
                    print(item.text())
                    plot_label = item.text()
                    mask_roi, mask_type = self.get_roi_mask(roi_list, item, roi_shape)
                    roi_spec = np.sum(np.sum(img_stack * mask_roi, axis=1), axis=1) / np.sum(mask_roi)
                    plot_color = roi_color[item.text()]
                    line, = plt.plot(x, roi_spec, marker='.', color=plot_color, label=plot_label)
                    legend.append(line)
            else:
                mask = self.mask
                if np.squeeze(mask).shape != img_stack[0].shape:
                    mask = np.ones(img_stack[0].shape)
                roi_spec = np.sum(np.sum(img_stack * mask, axis=1), axis=1) / np.sum(mask)
                line, = plt.plot(x, roi_spec, marker='.', color='r', label='image average')
                legend.append(line)
            print(legend)
            plt.legend(handles=legend)
            plt.show()
        except Exception as err:
            self.msg = f'no spectrum available for current image stack. Error: {str(err)}'
            self.update_msg()


    def evaluate_glitch(self):
        try:
            canvas = self.canvas1
            img_stack = deepcopy(canvas.img_stack)
            roi_list = canvas.roi_list
            x = self.xanes_eng
            item = self.lst_roi.selectedItems()[0]
            roi_cord = np.int32(np.array(roi_list[item.text()][:4]))
            a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
            x1 = min(a, c)
            x2 = max(a, c)
            y1 = min(b, d)
            y2 = max(b, d)
            roi_spec = np.mean(np.mean(img_stack[:, y1:y2, x1:x2], axis=1), axis=1)
            roi_spec_median = medfilt(roi_spec, 5)
            self.roi_spec_dif = roi_spec/roi_spec_median
            if not len(x) == len(roi_spec):
                return 0
            plt.figure()
            plt.subplot(2, 1, 1)
            plt.plot(x[:-1], self.roi_spec_dif[:-1], 'r.')
            plt.title('Identify the threshold for removing glitch')
            plt.subplots_adjust(hspace = 0.5)
            plt.subplot(2, 1, 2)
            plt.plot(x, roi_spec, 'b.-')
            plt.plot(x[:-1], roi_spec_median[:-1], 'r.-')
            plt.title(f'median value: {np.median(self.roi_spec_dif)}')
            plt.show()
            self.msg = 'no spectrum available for current image stack ...'
            self.update_msg()
        except Exception as err:
            print(err)


    def remove_glitch(self):
        tmp = self.tx_glitch_thresh.text()
        glitch_thresh =  self.tx_glitch_thresh.text()
        if len(self.roi_spec_dif) != len(self.xanes_eng):
            self.msg = 'data size disagree...'
            self.update_msg()
        else:
            if tmp[0] == '<':
                mask = self.roi_spec_dif > np.float32(glitch_thresh[1:])
            elif tmp[0] == '>':
                mask = self.roi_spec_dif < np.float32(glitch_thresh[1:])
            else:
                mask = self.roi_spec_dif < np.float32(glitch_thresh)
            msg = QMessageBox()
            msg.setText('This will delete the image in \"raw data\", and \"image_update\" ')
            msg.setWindowTitle('Delete multiple image')
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            reply = msg.exec_()
            if reply == QMessageBox.Ok:
                try:
                    self.img_xanes = self.img_xanes[mask]
                    print('glitch removed in img_xanes ')
                    self.img_update = self.img_update[mask]
                    print('glitch removed in img_update ')
                    self.xanes_eng = self.xanes_eng[mask]
                    st = '{0:3.1f}, {1:3.1f}, ..., {2:3.1f}  (totally, {3} angles)'.format(self.xanes_eng[0],self.xanes_eng[1],self.xanes_eng[-1],len(self.xanes_eng))
                    self.lb_eng1.setText(st)
                    print('glitch removed in xanes_eng ')
                    self.msg = 'glitch removed !'
                except Exception as err:
                    print(f'cannot delete xanes_eng. Error: {str(err)}')
                    self.msg = 'removing glitch failed ...'
                finally:
                    self.update_msg()
            self.update_canvas_img()
            QApplication.processEvents()


    def show_roi(self):
        plt.figure()
        canvas = self.canvas1
        canvas.show_roi_flag = True
        current_img = canvas.current_img
        current_colormap = canvas.colormap
        # cmin, cmax = canvas.cmin, canvas.cmax
        self.update_canvas_img()
        # canvas.update_img_stack()
        mask = canvas.mask
        s = current_img.shape
        type_index = self.cb1.currentText()
        cmax = np.float32(self.tx_cmax.text())
        cmin = np.float32(self.tx_cmin.text())
        if type_index == 'Color mix':
            current_img = self.img_colormix
            for i in range(current_img.shape[2]):
                current_img[:, :, i] *= canvas.rgb_mask
            current_img = (current_img - cmin) / (cmax - cmin)
            plt.imshow(current_img)
        else:
            plt.imshow(current_img * mask, cmap=current_colormap, vmin=cmin, vmax=cmax)

        if len(mask.shape) > 1:
            print(f'canvas_mask.shape = {canvas.mask.shape}')
            canvas.special_info = None
        plt.axis('equal')
        plt.axis('off')
        plt.colorbar()
        roi_color = canvas.roi_color
        roi_list = canvas.roi_list
        for item in self.lst_roi.selectedItems():
            mask_roi, mask_type = self.get_roi_mask(roi_list, item, s)
            if mask_type == 'ROI':
                print(item.text())
                plot_color = roi_color[item.text()]
                roi_cord = np.int32(np.array(roi_list[item.text()][:4]))
                plot_label = item.text()
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                x = [x1, x2, x2, x1, x1]
                y = [y1, y1, y2, y2, y1]
                plt.plot(x, y, '-', color=plot_color, linewidth=1.0, label=plot_label)
                roi_name = '#' + plot_label.split('_')[-1]
                plt.annotate(roi_name, xy=(x1, y1 - 10),
                             bbox={'facecolor': plot_color, 'alpha': 0.5, 'pad': 2},
                             fontsize=10)
            else: # mask_type == 'SM':
                plt.imshow(mask_roi * current_img)
        plt.show()


    def hide_roi(self):
        canvas = self.canvas1
        canvas.show_roi_flag = False
        self.update_canvas_img()


    def save_roi(self):
        try:
            canvas = self.canvas1
            roi_list = canvas.roi_list
            if len(roi_list):
                options = QFileDialog.Option()
                options |= QFileDialog.DontUseNativeDialog
                file_type = 'json files (*.json)'
                fn, _ = QFileDialog.getSaveFileName(self, 'Save ROI list', "", file_type, options=options)
                if fn[-5:] == '.json':
                    fn = fn[:-5]
                if len(fn):
                    fn_roi = f'{fn}.json'
                    with open(fn_roi, "w") as outfile:
                        json.dump(roi_list, outfile)
                with open('/tmp/roi.json', "w") as outfile_1:
                    json.dump(roi_list, outfile_1)
                    fn_roi = '/tmp/roi.json'
            self.msg = f'roi list saved to {fn_roi}'
        except Exception as err:
            self.msg = 'fails to save roi_list'
            print(err)
        finally:
            self.update_msg()


    def load_roi(self):
        try:
            self.reset_roi()
            canvas = self.canvas1
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog              # self.rd_txt_eng.isChecked() == True:
            file_type = 'json files (*.json)'
            fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
            if fn:
                with open(fn) as json_file:
                    roi_list = json.load(json_file)
                canvas.roi_count = 0
                canvas.roi_list = {}
                canvas.show_roi_flag = True
                for roi_name in roi_list.keys():
                    canvas.current_roi = roi_list[roi_name]
                    canvas.roi_add_to_list(roi_name)
                    canvas.roi_display(roi_list[roi_name])
        except Exception as err:
            print(err)

    def load_roi_last(self):
        try:
            self.reset_roi()
            canvas = self.canvas1
            fn = '/tmp/roi.json'
            with open(fn) as json_file:
                roi_list = json.load(json_file)
            canvas.roi_count = 0
            canvas.roi_list = {}
            canvas.show_roi_flag = True
            for roi_name in roi_list.keys():
                canvas.current_roi = roi_list[roi_name]
                canvas.roi_add_to_list(roi_name)
                canvas.roi_display(roi_list[roi_name])
        except Exception as err:
            print(err)


    def enable_multi_selection(self):
        if self.chkbox_multi_selec.isChecked():
            self.lst_roi.setSelectionMode(QAbstractItemView.MultiSelection)
            self.pb_roi_sel_all.setEnabled(True)
        else:
            self.lst_roi.setSelectionMode(QAbstractItemView.SingleSelection)
            self.lst_roi.clearSelection()
            self.pb_roi_sel_all.setEnabled(False)

    def roi_selection_all(self):
        self.lst_roi.selectAll()

    def export_spectrum(self):
        self.show_roi()
        make_director_success = 1 # temporay to enable saving anyway
        if make_director_success:
            canvas = self.canvas1
            img_stack = deepcopy(canvas.img_stack)
            s = img_stack.shape
            x = self.xanes_eng
            if s[0] < len(x):
                try:
                    img_stack = self.img_update.copy()
                    s = img_stack.shape
                except:
                    pass
            roi_list = canvas.roi_list
            roi_dict_spec = {'X_eng': pd.Series(x)}
            # roi_dict_cord = {}
            if len(roi_list):
                for item in self.lst_roi.selectedItems():
                    plot_label = item.text()
                    mask_roi, mask_type = self.get_roi_mask(roi_list, item, s)
                    roi_spec = np.sum(np.sum(img_stack * mask_roi, axis=1), axis=1) / np.sum(mask_roi)
                    roi_spec = np.around(roi_spec, 9)
                    roi_dict_spec[plot_label] = pd.Series(roi_spec)
            else:
                mask = self.mask
                if np.squeeze(mask).shape != img_stack[0].shape:
                    mask = np.ones(img_stack[0].shape)
                roi_spec = np.sum(np.sum(img_stack * mask, axis=1), axis=1) / np.sum(mask)
                roi_dict_spec = {'-1':pd.Series(roi_spec)}

            df_spec = pd.DataFrame(roi_dict_spec)
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'txt files (*.txt)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save Spectrum', "", file_type, options=options)
            if fn[-4:] == '.txt':
                fn = fn[:-4]
            fn_spec = f'{fn}.txt'
            with open(fn_spec, 'w') as f:
                df_spec.to_csv(f, float_format='%.9f', sep=' ', index=False)
            self.roi_file_id += 1
            self.tx_file_index.setText(str(self.roi_file_id))
            print(fn_spec + '  saved')
            self.msg = 'ROI spectrum file saved:   ' + fn_spec
            self.update_msg()

    def reset_roi(self):
        canvas = self.canvas1
        self.lst_roi.clear()
        canvas.current_roi = [0, 0, 0, 0, '0']
        canvas.show_roi_flag = False
        canvas.current_color = 'red'
        canvas.roi_list = {}
        canvas.roi_count = 0
        canvas.roi_color = {}
        self.update_canvas_img()
        s = canvas.current_img.shape


    def draw_roi(self):
        self.pb_roi_draw.setEnabled(False)
        QApplication.processEvents()
        canvas = self.canvas1
        canvas.draw_roi()


    def get_crop_roi(self, current_canvas):
        current_img = current_canvas.current_img
        s_raw = current_img.shape
        if current_canvas == self.canvas1:
            x_cen = int(self.tx_crop_cen_x.text())
            y_cen = int(self.tx_crop_cen_y.text())
            x_size = int(self.tx_crop_size_x.text())
            y_size = int(self.tx_crop_size_y.text())
        elif current_canvas == self.canvas_ml:
            x_cen = int(self.tx_ml_crop_cen_x.text())
            y_cen = int(self.tx_ml_crop_cen_y.text())
            x_size = int(self.tx_ml_crop_size_x.text())
            y_size = int(self.tx_ml_crop_size_y.text())

        x_s = int(max(x_cen - x_size / 2, 0))
        x_e = int(min(x_s + x_size, s_raw[1]))

        y_s = int(max(y_cen - y_size / 2, 0))
        y_e = int(min(y_s + y_size, s_raw[0]))

        return x_s, x_e, y_s, y_e


    def get_roi_average(self):
        try:
            if self.chkbox_multi_selec.isChecked():
                self.chkbox_multi_selec.setChecked(False)
                self.enable_multi_selection()
            current_canvas = self.canvas1
            QApplication.processEvents()
            roi_list = current_canvas.roi_list
            roi_item = self.lst_roi.selectedItems()[0]
            roi_cord = np.int32(np.array(roi_list[roi_item.text()][:4]))
            a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
            x1 = min(a, c)
            x2 = max(a, c)
            y1 = min(b, d)
            y2 = max(b, d)
            img = np.squeeze(current_canvas.current_img) * self.mask
            img = img[y1:y2, x1:x2]
            img_f = img[img>0]
            v_mean = np.mean(img_f)
            v_var = np.var(img_f)**(0.5)
            m = np.int32(img>0)
            v = np.sum(img) / np.sum(m)
            txt = f'mean={v_mean:2.6f}, var={v_var:2.6f}'
            print(txt)
            self.msg = f'   {roi_item.text()}:    Mean value = {v_mean:2.6f},  Variation = {v_var:2.6f}'

        except Exception as err:
            self.msg = str(err)
        finally:
            self.update_msg()


    def crop_roi_display(self, current_canvas):
        current_img = current_canvas.current_img
        x_s, x_e, y_s, y_e = self.get_crop_roi(current_canvas)
        x_size = x_e - x_s
        y_size = y_e - y_s
        self.tx_ml_crop_size_x.setText(f'{x_size}')
        self.tx_ml_crop_size_y.setText(f'{y_size}')
        x_list = [x_s, x_e, x_e, x_s, x_s]
        y_list = [y_s, y_s, y_e, y_e, y_s]
        plt.figure()
        plt.imshow(current_img)
        plt.plot(x_list, y_list, 'r', linewidth=1)
        plt.title('region for crop')
        plt.show()


    def crop_roi(self, current_canvas):
        x_s, x_e, y_s, y_e = self.get_crop_roi(current_canvas)
        image = current_canvas.img_stack
        try:
            self.img_update = image[:, y_s:y_e, x_s:x_e]
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            self.cb1.setCurrentText('Image updated')
            self.update_canvas_img()
        except Exception as err:
            print(err)


    def load_external_spec(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                fn_spec = fn.split('/')[-1]
                self.external_spec = np.loadtxt(fn)
                self.msg = f'loading existing spectrum: {fn_spec}'
                self.update_msg()
                QApplication.processEvents()
                plt.figure()
                plt.plot(self.external_spec[:,0], self.external_spec[:,1])
                plt.title('External xanes spectrum')
                plt.show()
            except Exception as err:
                print(f'un-supported spectrum format. Error: {str(err)}')


    def norm_external_spec(self):
        try:
            pre_s = float(self.tx_fit_pre_s.text())
            pre_e = float(self.tx_fit_pre_e.text())
            post_s = float(self.tx_fit_post_s.text())
            post_e = float(self.tx_fit_post_e.text())
            x_eng = self.external_spec[:,0]
            self.external_spec_fit = self.external_spec.copy()
            self.external_spec_fit[:, 1], y_pre_fit, y_post_fit = pyxas.normalize_1D_xanes(self.external_spec[:,1], x_eng, [pre_s, pre_e],
                                                                       [post_s, post_e])
            plt.figure()  # generate figure for each roi
            plt.subplot(211)
            plt.subplots_adjust(hspace=0.5)
            plt.plot(x_eng, self.external_spec[:,1], '.', color='gray')
            plt.plot(x_eng, y_pre_fit, 'b', linewidth=1)
            plt.plot(x_eng, y_post_fit + y_pre_fit, 'r', linewidth=1)
            plt.title('pre-post edge fitting')
            plt.subplot(212)  # plot normalized spectrum
            plt.plot(x_eng, self.external_spec_fit[:,1])
            plt.title('normalized spectrum')
            plt.show()
        except Exception as err:
            self.msg = f'faild to fit external spectrum. Error: {str(err)}'
            self.update_msg()


    def save_external_spec(self):
        try:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'txt files (*.txt)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
            if fn:
                if not fn[-4:] == 'txt':
                    fn += '.txt'
                np.savetxt(fn, np.array(self.external_spec_fit), '%2.5f')
                print(fn + '  saved')
                self.msg = f'{fn} is saved'
        except Exception as err:
            self.msg = f'fails to save normed external spectrum. Error: {str(str)}'
        finally:
            self.update_msg()


    def fit_edge(self):
        try:
            pre_s = float(self.tx_fit_pre_s.text())
            pre_e = float(self.tx_fit_pre_e.text())
            post_s = float(self.tx_fit_post_s.text())
            post_e = float(self.tx_fit_post_e.text())

            canvas = self.canvas1
            img_stack = deepcopy(canvas.img_stack)
            roi_list = canvas.roi_list
            x_eng = deepcopy(self.xanes_eng)
            num_roi_sel = len(self.lst_roi.selectedItems())
            roi_spec_fit = np.zeros([len(x_eng), num_roi_sel+1])
            roi_spec_fit[:,0] = x_eng
            n = 0
            for item in self.lst_roi.selectedItems():
                n = n + 1
                plt.figure()  # generate figure for each roi
                plt.subplot(211)
                roi_cord = np.int32(np.array(roi_list[item.text()][:4]))
                plot_label = item.text()
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                roi_spec = np.mean(np.mean(img_stack[:, y1:y2, x1:x2, ], axis=1), axis=1)
                roi_spec_fit[:,n], y_pre_fit, y_post_fit = pyxas.normalize_1D_xanes(roi_spec, x_eng, [pre_s, pre_e], [post_s, post_e])
                plt.subplots_adjust(hspace=0.5)
                plt.plot(x_eng, roi_spec, '.', color='gray')
                plt.plot(x_eng, y_pre_fit, 'b', linewidth=1)
                plt.plot(x_eng, y_post_fit + y_pre_fit, 'r', linewidth=1)
                plt.title('pre-post edge fitting for ' + plot_label)
                plt.subplot(212)  # plot normalized spectrum
                plt.plot(x_eng, roi_spec_fit[:, n])
                plt.title('normalized spectrum for ' + plot_label)
                plt.show()
            self.roi_spec = roi_spec_fit
        except Exception as err:
            self.msg = f'Fitting error. Error: {str(err)}'
            self.update_msg()


    def save_normed_roi(self):
        try:
            os.makedirs(self.fpath + '/ROI/fitted_roi')
        except Exception as err:
            print(self.fpath + f'/ROI failed. Error: {str(err)}')
            pass
        try:
            fn_spec = 'fitted_spectrum_roi_from_' + self.cb1.currentText() + '_' + self.tx_file_index.text() + '.txt'
            fn_spec = self.fpath + '/ROI/fitted_roi/' + fn_spec
            # fn_cord = 'fitted_coordinates_roi_from_' + self.cb1.currentText() + '_' + self.tx_file_index.text() + '.txt'
            # fn_cord = self.fpath + '/ROI/fitted_roi/' + fn_cord
            canvas = self.canvas1
            roi_spec = deepcopy(self.roi_spec)
            roi_spec = np.around(roi_spec, 4)
            roi_list = canvas.roi_list
            roi_dict_spec = {'X_eng': pd.Series(roi_spec[:, 0])}
            roi_dict_cord = {}
            n = 0
            for item in self.lst_roi.selectedItems():
                n = n + 1
                plot_label = item.text()
                roi_cord = np.int32(np.array(roi_list[item.text()][:4]))
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                area = (x2 - x1) * (y2 - y1)
                roi_dict_spec[plot_label] = pd.Series(roi_spec[:, n])
                roi_dict_cord[plot_label] = pd.Series([x1, y1, x2, y2, area], index=['x1', 'y1', 'x2', 'y2', 'area'])
            df_spec = pd.DataFrame(roi_dict_spec)
            df_cord = pd.DataFrame(roi_dict_cord)

            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'txt files (*.txt)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
            if fn:
                if not fn[-4:] == '.txt':
                    fn += '.txt'
                np.savetxt(fn, np.array(df_spec), '%2.5f')
                # fn_cord_another = fn+f'_fitted_coordinates_roi_from_{self.cb1.currentText()}_{self.tx_file_index.text()}.txt'
                with open(fn_spec, 'w') as f:
                    df_cord.to_csv(f, sep=' ')
                print(fn_spec + '  saved')
                self.msg = 'Fitted ROI spectrum saved:   ' + fn
        except Exception as err:
            self.msg = f'Save fitted roi spectrum fails. Error: {str(err)}'
        finally:
            self.update_msg()


    def fit_edge_img(self):
        try:
            pre_s = float(self.tx_fit_pre_s.text())
            pre_e = float(self.tx_fit_pre_e.text())
            post_s = float(self.tx_fit_post_s.text())
            post_e = float(self.tx_fit_post_e.text())
            canvas = self.canvas1

            self.pb_fit_img.setText('wait ...')
            self.pb_fit_img.setEnabled(False)
            QApplication.processEvents()
            img_norm = deepcopy(canvas.img_stack) * self.mask
            x_eng = deepcopy(self.xanes_eng)
            pre_edge_only_flag = 1 if self.chkbox_norm_pre_edge_only.isChecked() else 0
            if self.rd_norm1.isChecked():
                img_norm, self.img_pre_edge_sub_mean = pyxas.normalize_2D_xanes_old(img_norm, x_eng, [pre_s, pre_e], [post_s, post_e], pre_edge_only_flag)
                self.msg = '2D Spectra image normalized (pixel-wise)'
            elif self.rd_norm2.isChecked():
                img_norm, tmp = pyxas.normalize_2D_xanes2(img_norm, x_eng, [pre_s, pre_e], [post_s, post_e], pre_edge_only_flag)
                # if len(self.img_pre_edge_sub_mean.shape) == 1:
                #    self.img_pre_edge_sub_mean = tmp
                self.img_pre_edge_sub_mean = tmp
                self.msg = '2D Spectra image normalized (using global slope)'
            self.update_msg()
            self.data_summary['XANES Fit (thickness)'] = self.smooth(self.img_pre_edge_sub_mean)
            self.img_update = deepcopy(img_norm)
            self.cb1.setCurrentText('Image updated')
            self.update_canvas_img()
            self.pb_fit_img.setText('Norm Img.')
            self.pb_fit_img.setEnabled(True)
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            if self.cb1.findText('XANES Fit (thickness)') < 0:
                self.cb1.addItem('XANES Fit (thickness)')
            self.cb1.setCurrentText('Image updated')
            QApplication.processEvents()
            del img_norm
        except Exception as err:
            self.msg = f'fails to normalize 2D spectra image.  Error: {str(err)}'
        finally:
            self.pb_fit_img.setText('Norm Image')
            self.pb_fit_img.setEnabled(True)
            QApplication.processEvents()
            self.update_msg()


    def regular_edge_img(self):
        try:
            canvas = self.canvas1
            img_norm = deepcopy(canvas.img_stack)
            pre_s = float(self.tx_fit_pre_s.text())
            pre_e = float(self.tx_fit_pre_e.text())
            post_s = float(self.tx_fit_post_s.text())
            post_e = float(self.tx_fit_post_e.text())
            x_eng = deepcopy(self.xanes_eng)
            regular_max = float(self.tx_reg_max.text())
            regular_width = float(self.tx_reg_width.text())
            self.pb_reg_img.setText('wait ...')
            self.pb_reg_img.setEnabled(False)
            QApplication.processEvents()
            self.img_regulation = pyxas.normalize_2D_xanes_regulation(img_norm, x_eng, pre_edge=[pre_s, pre_e], post_edge=[post_s, post_e], designed_max=regular_max, gamma=regular_width)
            self.msg = 'Image regulation finished'
            if self.cb1.findText('Image regulation') < 0:
                self.cb1.addItem('Image regulation')
            self.cb1.setCurrentText('Image regulation')
            QApplication.processEvents()
        except Exception as err:
            self.msg = f'fails to regularize 2D spectra image.  Error: {str(err)}'
        finally:
            self.pb_reg_img.setText('Regulation')
            self.pb_reg_img.setEnabled(True)
            QApplication.processEvents()
            self.update_msg()


    def save_img_stack(self, current_canvas):
        try:
            #self.pb_save_img_stack.setEnabled(False)
            QApplication.processEvents()
            #canvas = self.canvas1
            canvas = current_canvas
            save_stack = True
            if canvas == self.canvas1:
                if self.cb1.currentText() == 'Color mix':
                    save_stack = False
                    self.save_img_single()
                else:
                    img_stack = (canvas.img_stack * self.mask1 * self.mask2 * self.mask).astype(np.float32)
            elif canvas == self.canvas_ml:
                img_stack = (canvas.img_stack).astype(np.float32)
            if save_stack:
                options = QFileDialog.Option()
                options |= QFileDialog.DontUseNativeDialog
                file_type = 'tif files (*.tiff)'
                fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
                if fn[-5:] != '.tiff' and fn[-4:]!='.tif':
                    fn += '.tiff'
                io.imsave(fn, img_stack)
                print(f'current image stack has been saved to file: {fn}')
                self.msg = f'image stack saved to: {fn}'
        except Exception as err:
            self.msg = f'file saving fails.  Error: {str(err)}'
        finally:
            self.update_msg()
            if canvas == self.canvas1:
                self.pb_save_img_stack.setEnabled(True)
            elif canvas == self.canvas_ml:
                self.pb_ml_save_img_stack.setEnabled(True)
            QApplication.processEvents()


    def save_img_single(self):
        try:
            self.pb_save_img_single.setEnabled(False)
            QApplication.processEvents()
            canvas = self.canvas1
            cmax = np.float32(self.tx_cmax.text())
            cmin = np.float32(self.tx_cmin.text())
            if self.cb1.currentText() == 'Color mix':
                img = self.img_colormix
                for i in range(img.shape[2]):
                    img[:, :, i] = img[:, :, i] * canvas.rgb_mask
                plt.figure()
                img = (img - cmin) / (cmax - cmin)
                plt.imshow(img, clim=[cmin, cmax])
                plt.show()
            else:
                img_stack = canvas.img_stack[canvas.current_img_index] * canvas.mask
                img_stack = np.array(img_stack, dtype = np.float32)
                options = QFileDialog.Option()
                options |= QFileDialog.DontUseNativeDialog
                file_type = 'tif files (*.tiff)'
                fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
                if not(fn[-5:] == '.tiff' or fn[-4:] =='.tif'):
                    fn += '.tiff'
                if not fn == '.tiff':
                    io.imsave(fn, img_stack)
                    print(f'current image has been saved to file: {fn}')
                    self.msg = f'current image saved to: {fn}'
                plt.figure()
                plt.imshow(img_stack, clim=[cmin, cmax], cmap=canvas.colormap)
                plt.axis('off')
                plt.show()
        except Exception as err:
            self.msg = f'file saving fails.  Error: {str(err)}'
        finally:
            self.update_msg()
            self.pb_save_img_single.setEnabled(True)
            QApplication.processEvents()


    def delete_single_img(self):
        canvas = self.canvas1
        if canvas.img_stack.shape[0] < 2:
            self.msg = 'cannot delete image in single-image-stack'
            self.update_msg()
        else:
            msg = QMessageBox()
            msg.setText('This will delete the image in \"raw data\", and \"image_update\" ')
            msg.setWindowTitle('Delete single image')
            msg.setStandardButtons(QMessageBox.Ok | QMessageBox.Cancel)
            reply = msg.exec_()
            if reply == QMessageBox.Ok:
                #img_type = self.cb1.currentText()
                current_slice = self.sl1.value()
                try:
                    self.img_xanes = np.delete(self.img_xanes, current_slice, axis=0)
                except Exception as err:
                    print(f'cannot delete img_xanes. Error: {str(err)}')
                try:
                    self.img_update = np.delete(self.img_update, current_slice, axis=0)
                except Exception as err:
                    print(f'cannot delete img_update. Error: {str(err)}')
                try:
                    self.xanes_eng = np.delete(self.xanes_eng, current_slice, axis=0)
                    st = '{0:3.1f}, {1:3.1f}, ..., {2:3.1f}  (totally, {3} energies)'.format(self.xanes_eng[0],self.xanes_eng[1],self.xanes_eng[-1],len(self.xanes_eng))
                    self.lb_eng1.setText(st)  # update angle information showing on the label
                except Exception as err:
                    print(f'cannot delete energy. Error: {str(err)}')
                self.msg = 'image #{} has been deleted'.format(current_slice)
                self.update_msg()
                self.update_canvas_img()


    def load_energy(self):
        self.xanes_eng = np.array([0])
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_txt_flag = 0
        if len(self.tx_hdf_eng.text()):
            dataset_eng = self.tx_hdf_eng.text()
        else:
            dataset_eng = 'X_eng'
        if self.rd_hdf_eng.isChecked():
            file_type = 'hdf files (*.h5)'
            file_txt_flag = 0
        else:                                           # self.rd_txt_eng.isChecked() == True:
            file_type = 'txt files (*.txt)'
            file_txt_flag = 1
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        note = ''
        if fn:
            try:
                print(fn)
                if file_txt_flag:
                    self.xanes_eng = np.array(np.loadtxt(fn))
                else:
                    f = h5py.File(fn, 'r')
                    self.xanes_eng = np.array(f[dataset_eng])
                    f.close()
                '''
                if self.xanes_eng[-1] < self.xanes_eng[0]:
                    note = 'auto reverse the energy list. '
                    self.xanes_eng = self.xanes_eng[::-1]
                '''
                self.xanes_eng, self.img_xanes = pyxas.check_eng_image_order(self.xanes_eng, self.img_xanes)
                st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f} keV   totally, {3} energies'.format(self.xanes_eng[0], self.xanes_eng[1], self.xanes_eng[-1], len(self.xanes_eng))
                self.tx_fit_pre_s.setText('{:2.4f}'.format(min(self.xanes_eng)))
                self.tx_fit_pre_e.setText('{:2.4f}'.format(min(self.xanes_eng) + 0.010))
                self.tx_fit_post_e.setText('{:2.4f}'.format(max(self.xanes_eng)))
                self.tx_fit_post_s.setText('{:2.4f}'.format(max(self.xanes_eng) - 0.010))
                self.lb_eng1.setText(st)
                self.tx_fit2d_s.setText('{:2.4f}'.format(self.xanes_eng[0]))
                self.tx_fit2d_e.setText('{:2.4f}'.format(self.xanes_eng[-1]))
                self.tx_multi_elem_s.setText('{:2.4f}'.format(self.xanes_eng[0]))
                self.tx_multi_elem_e.setText('{:2.4f}'.format(self.xanes_eng[-1]))
                # update 3D fitting
                if not self.load_eng_successful:
                    self.eng = self.xanes_eng.copy()
                n_eng = len(self.eng)
                self.load_eng_successful = 1
                self.lb_param_eng_info.setText(
                    f'Energy: {n_eng} energies: {self.eng[0]:2.4f}, {self.eng[1]:2.4f},   ...   '
                    f'{self.eng[-1]:2.4f} keV')
                if (len(self.xanes_eng) != self.img_xanes.shape[0]):
                    self.msg = 'number of energy does not match number of images, try manual input ...'
                else:
                    self.msg = 'energy load succesfully'
            except Exception as err:
                self.xanes_eng = np.array([0])
                self.lb_eng1.setText('No energy data ...')
                self.lb_eng2.setVisible(True)
                self.tx_eng.setVisible(True)
                self.pb_eng.setVisible(True)
                self.msg = self.msg + f';  Energy list not exist.  Error: {str(err)}'
                self.eng = [0, 20]
                self.load_eng_successful = 0

            self.update_msg()
            self.update_canvas_img()


    def load_fitted_file_sub(self, fn):
        self.dataset_used_for_fitting = -1
        self.xanes_2d_fit_offset = 0
        self.num_ref = 0
        thickness_flag = 0
        concentration_flag = 0
        f = h5py.File(fn, 'r')
        keys = list(f.keys())
        # edge
        post_edge = np.array(f['post_edge'])
        pre_edge = np.array(f['pre_edge'])
        self.tx_fit_pre_s.setText(str(pre_edge[0]))
        self.tx_fit_pre_e.setText(str(pre_edge[1]))
        self.tx_fit_post_s.setText(str(post_edge[0]))
        self.tx_fit_post_e.setText(str(post_edge[1]))
        self.msg = f"reading: {', '.join(t for t in keys)}"
        for k in keys:
            if k.lower() == 'mask':
                self.mask = np.squeeze(np.array(f[k]))
                self.canvas1.mask = self.mask
                self.mask1 = self.mask
                self.pb_mask1.setStyleSheet('color: rgb(200, 50, 50);')
                self.cb1.addItem('Mask')
                continue
            if 'smart' in k.lower():
                self.smart_mask = np.array(f[k])
                self.cb1.addItem('Smart Mask')
                continue
            if 'eng' in k.lower():
                self.xanes_eng = np.array(f[k])
                st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f} keV   totally, {3} energies'.format(self.xanes_eng[0], self.xanes_eng[1], self.xanes_eng[-1], len(self.xanes_eng))
                self.lb_eng1.setText(st)
            if 'ratio' in k.lower() and 'sum' in k.lower():
                self.xanes_2d_fit = np.array(f[k])
                self.cb1.addItem('XANES Fit (ratio, summed to 1)')
                continue
            if 'thickness' in k.lower():
                self.img_pre_edge_sub_mean = np.array(f[k])
                self.cb1.addItem('XANES Fit (thickness)')
                concentration_flag = 1
                thickness_flag = 1
                continue
            if 'error' in k.lower():
                self.xanes_fit_cost = np.array(f[k])
                self.cb1.addItem('XANES Fit error')
                continue
            if 'ref' in k.lower():
                self.num_ref += 1
                continue
            if 'offset' in k.lower():
                self.xanes_2d_fit_offset = np.array(f[k])
                self.cb1.addItem('XANES Fit offset')
                continue
        if thickness_flag == 0:
            for k in keys:
                if 'concentration' in k.lower():
                    self.img_pre_edge_sub_mean = self.xanes_2d_fit / np.array(f[k])
                    concentration_flag = 1
                    break
        if concentration_flag:
            self.cb1.addItem('XANES Fit (Elem. concentration)')
        for i in range(self.num_ref):
            try:
                ref_name = f'ref{i}'
                self.spectrum_ref[ref_name] = np.float32(np.array(f[ref_name]))
                self.lb_ref_info.setText(self.lb_ref_info.text() + '\n' + ref_name + '  loaded')
                self.lb_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
                self.cb_color_channel.addItem(str(i))
                QApplication.processEvents()
            except Exception as err:
                print(err)
                self.num_ref -= 1
        f.close()
        return 1


    def load_fitted_file(self):
        self.default_layout()
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'hdf files (*.h5)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            load_successful = self.load_fitted_file_sub(fn)
        '''
        if fn:
            self.dataset_used_for_fitting = -1
            self.xanes_2d_fit_offset = 0
            self.num_ref = len(self.spectrum_ref)
            thickness_flag = 0
            concentration_flag = 0
            f = h5py.File(fn, 'r')
            keys = list(f.keys())
            # edge
            post_edge = np.array(f['post_edge'])
            pre_edge = np.array(f['pre_edge'])
            self.tx_fit_pre_s.setText(str(pre_edge[0]))
            self.tx_fit_pre_e.setText(str(pre_edge[1]))
            self.tx_fit_post_s.setText(str(post_edge[0]))
            self.tx_fit_post_e.setText(str(post_edge[1]))

            self.msg = f"reading: {', '.join(t for t in keys)}"
            for k in keys:
                if k.lower() == 'mask':
                    self.mask = np.squeeze(np.array(f[k]))
                    self.canvas1.mask = self.mask
                    self.mask1 = self.mask
                    self.pb_mask1.setStyleSheet('color: rgb(200, 50, 50);')
                    self.cb1.addItem('Mask')
                    continue
                if 'smart' in k.lower():
                    self.smart_mask = np.array(f[k])
                    self.cb1.addItem('Smart Mask')
                    continue
                if 'eng' in k.lower():
                    self.xanes_eng = np.array(f[k])
                    st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f} keV   totally, {3} energies'.format(self.xanes_eng[0],
                            self.xanes_eng[1], self.xanes_eng[-1], len(self.xanes_eng))
                    self.lb_eng1.setText(st)
                if 'ratio' in k.lower() and 'sum' in k.lower():
                    self.xanes_2d_fit = np.array(f[k])
                    self.cb1.addItem('XANES Fit (ratio, summed to 1)')
                    continue
                if 'thickness' in k.lower():
                    self.img_pre_edge_sub_mean = np.array(f[k])
                    self.cb1.addItem('XANES Fit (thickness)')
                    concentration_flag = 1
                    thickness_flag = 1
                    continue
                if 'error' in k.lower():
                    self.xanes_fit_cost = np.array(f[k])
                    self.cb1.addItem('XANES Fit error')
                    continue
                if 'ref' in k.lower():
                    self.num_ref += 1
                    continue
                if 'offset' in k.lower():
                    self.xanes_2d_fit_offset = np.array(f[k])
                    self.cb1.addItem('XANES Fit offset')
                    continue


            if thickness_flag == 0:
                for k in keys:
                    if 'concentration' in k.lower():
                        self.img_pre_edge_sub_mean = self.xanes_2d_fit / np.array(f[k])
                        concentration_flag = 1
                        break

            if concentration_flag:
                self.cb1.addItem('XANES Fit (Elem. concentration)')

            for i in range(self.num_ref):
                try:
                    ref_name = f'ref{i}'
                    self.spectrum_ref[ref_name] = np.float32(np.array(f[ref_name]))
                    self.lb_ref_info.setText(self.lb_ref_info.text() + '\n' + ref_name + '  loaded')
                    self.lb_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
                    QApplication.processEvents()
                except:
                    self.num_ref -= 1
        f.close()
        '''
        self.lb_ip.setText('File loaded:   {}'.format(fn))
        self.pb_plot_roi.setEnabled(True)
        self.pb_export_roi_fit.setEnabled(True)


    def open_imagej(self):
        try:
            os.system('imagej &')
        except Exception as err:
            self.msg = f'can not find/open imagej.  Error: {str(err)}'
            self.update_msg()


    def close_all_figures(self):
        plt.close('all')


    def check_white_field_normed(self):
        if self.chkbox_white_field_corr.isChecked():
            self.tx_hdf_xanes_bkg.setDisabled(True)
            self.tx_hdf_xanes_dark.setDisabled(True)
        else:
            self.tx_hdf_xanes_bkg.setEnabled(True)
            self.tx_hdf_xanes_dark.setEnabled(True)
        QApplication.processEvents()

    
    def reverse_img_order(self):
        try:
            self.img_xanes = self.img_xanes[::-1]
            self.update_canvas_img() 
            self.msg = 'Reversed image order'     
        except Exception as err:
            self.msg = str(err)
            print(err)  
        finally:
            self.update_msg()


    def load_image(self):
        if len(self.xanes_eng) > 1:
            xeng_load_exist = True
            xeng = self.xanes_eng.copy()
        else:
            xeng_load_exist = False
        self.default_layout()
        if xeng_load_exist:
            self.xanes_eng = xeng.copy()
            st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f} keV (totally, {3} energies)'.format(self.xanes_eng[0],
                                                                                        self.xanes_eng[1],
                                                                                        self.xanes_eng[-1],
                                                                                        len(self.xanes_eng))
            self.lb_eng1.setText(st)
        self.pb_ld.setEnabled(False)
        if len(self.tx_hdf_xanes.text()):
            dataset_xanes = self.tx_hdf_xanes.text()
        else:
            dataset_xanes = 'img_xanes'

        if len(self.tx_hdf_eng.text()):
            dataset_eng = self.tx_hdf_eng.text()
        else:
            dataset_eng = 'X_eng'
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        if self.rd_hdf.isChecked():
            file_type = 'hdf files (*.h5)'
            flag_read_from_file = 1
            flag_read_from_database =0
        elif self.rd_tif.isChecked():
            file_type = 'tif files (*.tif, *.tiff)'
            flag_read_from_file = 1
            flag_read_from_database = 0
        else:
            flag_read_from_database = 1
            flag_read_from_file = 0
        if flag_read_from_file:
            fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
            if fn:
                print(fn)
                self.fn_raw_image = fn
                fn_relative = fn.split('/')[-1]
                self.fpath = fn[:-len(fn_relative)-1]
                print(f'current path: {self.fpath}')

                self.lb_ip.setStyleSheet('color: rgb(200, 50, 50);')
                if self.rd_hdf.isChecked():  # read hdf file
                    f = h5py.File(fn, 'r')
                    flag_reverse_eng = 0
                    # read energy
                    try:
                        self.xanes_eng = np.round(np.array(f[dataset_eng]), 8)  # Generally, it is in unit of keV

                        # if min(self.xanes_eng) < 4000:  # make sure it is in unit of KeV
                        #     self.xanes_eng = self.xanes_eng * 1000
                        st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f} keV (totally, {3} energies)'.format(self.xanes_eng[0], self.xanes_eng[1], self.xanes_eng[-1], len(self.xanes_eng))
                        self.tx_fit_pre_s.setText('{:2.4f}'.format(min(self.xanes_eng) - 0.001))
                        self.tx_fit_pre_e.setText('{:2.4f}'.format(min(self.xanes_eng) + 0.010))
                        self.tx_fit_post_e.setText('{:2.4f}'.format(max(self.xanes_eng) + 0.001))
                        self.tx_fit_post_s.setText('{:2.4f}'.format(max(self.xanes_eng) - 0.010))
                        self.lb_eng1.setText(st)
                        self.tx_fit2d_s.setText('{:2.4f}'.format(self.xanes_eng[0]))
                        self.tx_fit2d_e.setText('{:2.4f}'.format(self.xanes_eng[-1]))
                        self.tx_multi_elem_s.setText('{:2.4f}'.format(self.xanes_eng[0]))
                        self.tx_multi_elem_e.setText('{:2.4f}'.format(self.xanes_eng[-1]))
                    except Exception as err:
                        self.xanes_eng = np.array([0])
                        self.lb_eng1.setText('No energy data ...')
                        self.lb_eng2.setVisible(True)
                        self.tx_eng.setVisible(True)
                        self.pb_eng.setVisible(True)
                        self.msg = self.msg + f';  Energy list not exist.  Error: {str(err)}'
                        self.update_msg()
                    # read xanes-scan image
                    try:
                        try:
                            self.img_xanes = pyxas.rm_abnormal(np.array(f[dataset_xanes]))
                            if flag_reverse_eng:
                                self.img_xanes = self.img_xanes[::-1]
                            if not self.chkbox_white_field_corr.isChecked():
                                dataset_bkg = self.tx_hdf_xanes_bkg.text()
                                dataset_dark = self.tx_hdf_xanes_dark.text()
                                img_bkg = np.array(f[dataset_bkg])
                                img_dark = np.array(f[dataset_dark])
                                self.img_xanes = pyxas.rm_abnormal((self.img_xanes - img_dark) / (img_bkg - img_dark))
                        except Exception as err:
                            print(err)
                            k = list(f.keys())
                            hdf_attr = ', '.join(k)
                            self.msg = str(err) + '\n' + ' '*18 + 'available hdf attr:  ' + hdf_attr
                            self.update_msg()
                            f.close()
                            self.pb_ld.setEnabled(True)
                            return 0
                        s = self.img_xanes.shape
                        if len(s) == 2:
                            self.img_xanes = np.expand_dims(self.img_xanes, axis=0)
                        self.img_update = deepcopy(self.img_xanes)
                        print('Image size: ' + str(self.img_xanes.shape))
                        self.pb_norm_txm.setEnabled(True)
                        self.pb_align.setEnabled(True)
                        self.pb_del.setEnabled(True)  # delete single image
                        self.pb_filt.setEnabled(True)  # delete single image
                        self.pb_rmbg.setEnabled(True)
                        self.pb_align_roi.setEnabled(True)
                        self.msg = 'image shape: {0}'.format(self.img_xanes.shape)
                        self.lb_ip.setText('File loaded:   {}'.format(fn))
                        if self.cb1.findText('Raw image') < 0:
                            self.cb1.addItem('Raw image')
                        self.cb1.setCurrentText('Raw image')
                        print(f'num of eng: {len(self.xanes_eng)}   image_shape: {self.img_xanes.shape}')
                        if (len(self.xanes_eng) != self.img_xanes.shape[0]):
                            self.msg = 'number of energy does not match number of images, try manual input ...'
                    except Exception as err:
                        self.img_xanes = np.zeros([1, 100, 100])
                        self.img_update = self.img_xanes.copy()
                        print(f'xanes image not exist.  Error: {str(err)}')
                        self.lb_ip.setText('File loading fails ...')
                        self.msg = f'xanes image not exist.  Error: {str(err)}'
                    load_fitted = 0

                    try:
                        self.xanes_eng, self.img_xanes = pyxas.check_eng_image_order(self.xanes_eng, self.img_xanes)
                    except:
                        pass
                    self.update_canvas_img()
                    self.update_msg()
                    f.close()
                else:  # read tiff file
                    try:
                        self.img_xanes = pyxas.rm_abnormal(pyxas.get_img_from_tif_file(fn))
                        s = self.img_xanes.shape
                        if len(s) == 2:
                            self.img_xanes = np.expand_dims(self.img_xanes, axis=0)
                        self.msg = 'image shape: {0}'.format(self.img_xanes.shape)
                        self.update_msg()
                        self.pb_norm_txm.setEnabled(True)  # remove background
                        self.lb_ip.setText('File loaded:   {}'.format(fn))
                        self.pb_del.setEnabled(True)  # delete single image
                        if self.cb1.findText('Raw image') < 0:
                            self.cb1.addItem('Raw image')
                        self.cb1.setCurrentText('Raw image')
                        QApplication.processEvents()
                    except Exception as err:
                        self.img_xanes = np.zeros([1, 100, 100])
                        print(f'image not exist.  Error: {str(err)}')
                    finally:
                        self.img_update = deepcopy(self.img_xanes)
                        self.update_canvas_img()
                        #self.xanes_eng = np.array([])
                        if not xeng_load_exist:
                            self.lb_eng1.setText('No energy data ...')
                        self.lb_eng2.setVisible(True)
                        self.tx_eng.setVisible(True)
                        self.pb_eng.setVisible(True)
                self.auto_contrast(self.canvas1)
        elif flag_read_from_database:
            print('read_from_databroker, not implemented yet')
        else:
            print('Something happened in loading file ... :(')
        n_img = len(self.img_xanes)
        n_eng = len(self.xanes_eng)
        if not n_img == n_eng:
            self.msg = f'!! Inconsistance found: number of image ({n_img})!= number of energy ({n_eng})'
            self.update_msg()
        self.pb_ld.setEnabled(True)
        QApplication.processEvents()


    def update_msg(self):
        self.lb_msg.setFont(self.font1)
        self.lb_msg.setText('Message: ' + self.msg)
        self.lb_msg.setStyleSheet('color: rgb(200, 50, 50);')


    def manu_energy_input(self):
        energy_list_old = deepcopy(self.xanes_eng)
        com = self.tx_eng.text()
        try:
            exec(com)
            if 'self.xanes_eng' in com:
                if len(self.xanes_eng) != self.img_xanes.shape[0] or self.img_xanes.shape[0] <=3:
                    self.msg = 'invalid command of number of energy does not match number of images'
                    self.xanes_eng = deepcopy(energy_list_old)
                else:
                    st = '{0:2.4f}, {1:2.4f}, ..., {2:2.4f}    totally, {3} energies'.format(self.xanes_eng[0], self.xanes_eng[1], self.xanes_eng[-1], len(self.xanes_eng))
                    self.lb_eng1.setText(st)
            self.msg = 'command executed'
        except Exception as err:
            self.msg = f'un-recognized python command. Error: {str(err)} '
        finally:
            self.update_msg()


    def sliderval(self, current_canvas):
        #canvas = self.canvas1
        canvas = current_canvas
        if canvas == self.canvas1:
            img_index = self.sl1.value()
        elif canvas == self.canvas_ml:
            img_index = self.sl1_ml.value()
        canvas.current_img_index = img_index
        canvas.current_img = canvas.img_stack[img_index]
        img = canvas.img_stack[img_index]
        canvas.update_img_one(img, img_index=img_index)


    def get_slider_color_scale_value(self):
        t = self.sl_color.value()
        t = np.power(10, t / 50. - 1)
        return t


    def slider_color_scale(self):
        scale = self.get_slider_color_scale_value()
        self.lb_colormax.setText(f'x {scale:1.2f}')
        selected_channel = int(self.cb_color_channel.currentText())
        if self.cb1.currentText() == 'Color mix':
            img = self.img_colormix_raw
            img[selected_channel] *= scale
            #self.img_colormix = self.convert_rgb_img(img, self.color_vec)
            self.img_colormix = pyxas.convert_rgb_img(img, self.color_vec)
            self.update_canvas_img()
        else:
            self.msg = 'invalid colormix'
            self.update_msg()


    def norm_txm(self):
        self.pb_norm_txm.setText('wait ...')
        QApplication.processEvents()
        canvas = self.canvas1
        tmp = canvas.img_stack
        tmp = pyxas.rm_abnormal(tmp)
        tmp = -np.log(tmp)
        tmp[np.isinf(tmp)] = 0
        tmp[np.isnan(tmp)] = 0
        tmp[tmp<0] = 0
        self.img_update = deepcopy(tmp)
        self.pb_norm_txm.setText('Norm. TMX (-log)')
        del tmp
        QApplication.processEvents()
        if self.cb1.findText('Image updated') < 0:
            self.cb1.addItem('Image updated')
        print('img = -log(img) \n"img_updated" has been created or updated')
        self.msg = 'img = -log(img)'
        self.update_msg()
        if not self.cb1.currentText() == 'Image updated':
            self.cb1.setCurrentText('Image updated')
        else:
            self.update_canvas_img()


    def xanes_align_img(self):
        self.pb_align.setText('Aligning ...')
        QApplication.processEvents()
        self.pb_align.setEnabled(False)
        canvas = self.canvas1
        prj = deepcopy(canvas.img_stack) * self.mask1 * self.mask2
        img_ali = deepcopy(prj)
        n = prj.shape[0]
        self.shift_list = []
        try:
            ref_index = int(self.tx_ali_ref.text())
            if ref_index >= prj.shape[0]:   # sequential align next image with its previous image
                self.shift_list.append([0, 0])
                for i in range(1, n):
                    print('Aligning image slice ' + str(i))

                    if self.rd_ali1.isChecked():
                        method = self.cb_ali.currentText().strip()
                        img_ali[i], rsft, csft, _ = pyxas.align_img_stackreg(prj[i - 1], prj[i], method=method)
                    elif self.rd_ali2.isChecked():
                        _, rsft, csft = pyxas.align_img(prj[i - 1], prj[i])
                        img_ali[i] = shift(canvas.img_stack[i], [rsft, csft], mode='constant', cval=0)
                    self.shift_list.append([rsft, csft])
                    self.msg = f'Aligned image slice {i}, row_shift: {rsft:3.2f}, col_shift: {csft:3.2f}'
                    self.update_msg()
                    QApplication.processEvents()
            else:                                            # align all images with image_stack[ref_index]
                for i in range(n):
                    print('Aligning image slice ' + str(i))
                    self.msg = 'Aligning image slice ' + str(i)
                    self.update_msg()
                    if self.rd_ali1.isChecked():
                        method = self.cb_ali.currentText().strip()
                        img_ali[i], rsft, csft, _ = pyxas.align_img_stackreg(prj[ref_index], prj[i], method=method)
                    elif self.rd_ali2.isChecked():
                        _, rsft, csft = pyxas.align_img(prj[ref_index], prj[i])
                        img_ali[i] = shift(canvas.img_stack[i], [rsft, csft], mode='constant', cval=0)
                    self.msg = f'Aligned image slice {i}, row_shift: {rsft:3.2f}, col_shift: {csft:3.2f}'
                    self.update_msg()
                    self.shift_list.append([rsft, csft])
                    QApplication.processEvents()
            for i in range(n):
                t = img_ali[i]
                t[t<=0] = np.median(t)
                img_ali[i] = t
            self.img_update = deepcopy(img_ali)
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            if not self.cb1.currentText() == 'Image updated':
                self.cb1.setCurrentText('Image updated')
            else:
                self.update_canvas_img()
            self.pb_align.setText('Align Img')
            self.pb_align.setEnabled(True)
            print('Image aligned.\n Item "Aligned Image" has been added.')
            self.msg = 'Image aligning finished'
        except Exception as err:
            self.msg = f'image stack has only one image slice, aligning aborted. Error: {str(err)} '
        finally:
            self.update_msg()
            self.update_canvas_img()
            del prj, img_ali


    def xanes_align_img_roi(self):
        self.pb_align_roi.setText('Aligning ...')
        QApplication.processEvents()
        self.pb_align_roi.setEnabled(False)
        canvas = self.canvas1
        roi_list = canvas.roi_list
        img_ali = deepcopy(canvas.img_stack)
        self.shift_list = []
        try:
            n = int(self.tx_ali_roi.text())
            roi_selected = 'roi_' + str(n)
        except Exception as err:
            print(f'index should be integer. Error: {str(err)}')
            n = 0
            roi_selected = 'None'
        n_roi = self.lst_roi.count()
        if n > n_roi or n < 0:
            n = 0
            roi_selected = 'None'
        if not roi_selected == 'None':
            print(f'{roi_selected}')
            try:
                roi_cord = np.int32(np.array(roi_list[roi_selected][:4]))
                print(f'{roi_cord}')
                a, b, c, d = roi_cord[0], roi_cord[1], roi_cord[2], roi_cord[3]
                x1 = min(a, c)
                x2 = max(a, c)
                y1 = min(b, d)
                y2 = max(b, d)
                prj = (img_ali * self.mask1 * self.mask2)[:, y1: y2, x1: x2]
                s = prj.shape
                ref_index = int(self.tx_ali_ref.text())
                if ref_index >= s[0]:  # sequantial align next image with its previous image
                    print(f'sequency : {ref_index}')
                    self.shift_list.append([0, 0])
                    for i in range(1, s[0]):
                        print('Aligning image slice ' + str(i))
                        if self.rd_ali1.isChecked():
                            method = self.cb_ali.currentText().strip()
                            rsft, csft, sr = pyxas.align_img_stackreg(prj[i - 1], prj[i], align_flag=0, method=method)
                            img_ali[i] = sr.transform(img_ali[i])
                        elif self.rd_ali2.isChecked():
                            rsft, csft = pyxas.align_img(prj[i - 1], prj[i], align_flag=0)
                            img_ali[i] = shift(img_ali[i], [rsft, csft], mode='constant', cval=0)
                        self.msg = f'Aligned image slice {i}, row_shift: {rsft:3.2f}, col_shift: {csft:3.2f}'
                        self.update_msg()
                        self.shift_list.append([rsft, csft])
                        QApplication.processEvents()
                else:  # align all images with image_stack[ref_index]
                    for i in range(s[0]):
                        print('Aligning image slice ' + str(i))
                        if self.rd_ali1.isChecked():
                            method = self.cb_ali.currentText().strip()
                            rsft, csft, sr = pyxas.align_img_stackreg(prj[ref_index], prj[i], align_flag=0, method=method)
                            img_ali[i] = sr.transform(img_ali[i])
                        elif self.rd_ali2.isChecked():
                            rsft, csft = pyxas.align_img(prj[ref_index], prj[i], align_flag=0)
                            img_ali[i] = shift(img_ali[i], [rsft, csft], mode='constant', cval=0)
                        self.shift_list.append([rsft, csft])
                        self.msg = f'Aligned image slice {i}, row_shift: {rsft:3.2f}, col_shift: {csft:3.2f}'
                        self.update_msg()
                        QApplication.processEvents()
                for i in range(s[0]):
                    t = img_ali[i]
                    t[t<=0] = np.median(t)
                    img_ali[i] = t
                self.img_update = deepcopy(img_ali)
                if self.cb1.findText('Image updated') < 0:
                    self.cb1.addItem('Image updated')
                    self.cb1.setCurrentText('Image updated')
                print('Image aligned.\n Item "Aligned Image" has been added.')
                self.msg = 'Image aligning finished'
            except Exception as err:
                self.msg = f'image stack has only one image slice, aligning aborted. Error: {str(err)}'
            finally:
                self.pb_align_roi.setText('Align Img (ROI)')
                self.pb_align_roi.setEnabled(True)
                self.update_canvas_img()
                self.update_msg()
        else:
            self.pb_align_roi.setText('Align Img (ROI)')
            self.pb_align_roi.setEnabled(True)
            self.msg = 'Invalid roi index for aligning, nothing applied'
            self.update_msg()


    def apply_shift(self):
        canvas =self.canvas1
        prj = deepcopy(canvas.img_stack)
        img_ali = np.zeros(prj.shape)
        n = prj.shape[0]
        n1 = len(self.shift_list)
        if n!=n1:
            self.msg = 'number of shifts does not match number of images, aligning will not perform'
        else:
            for i in range(min(n, n1)):
                rsft, csft = self.shift_list[i]
                print(f'Aligned image slice {i}, row_shift: {rsft}, col_shift: {csft}')
                img_ali[i] = shift(prj[i], [rsft, csft], mode='constant', cval=0)
                self.msg = f'Aligned image slice {i}, row_shift: {rsft}, col_shift: {csft}'
                self.update_msg()
            self.img_update = deepcopy(img_ali)
            if self.cb1.findText('Image updated') < 0:
                self.cb1.addItem('Image updated')
            self.cb1.setCurrentText('Image updated')
            self.update_canvas_img()
            self.msg = 'Applied shift to current image stack, Image upated'
        self.update_msg()


    def load_shift(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                fn_shift = fn.split('/')[-1]
                print(f'selected shift list: {fn_shift}')
                self.msg = f'selected shift list: {fn_shift}'
                self.lb_shift.setText('  '+ fn_shift)
                QApplication.processEvents()
                self.shift_list = np.loadtxt(fn)
            except Exception as err:
                print(f'un-recognized shift list. Error: {str(err)}')
            finally:
                self.update_msg()


    def save_shift(self):
        num = len(self.shift_list)
        if num == 0:
            self.msg = 'shift list not exist'
        elif num != self.img_xanes.shape[0]:
            self.msg = 'number of shifts not match number of images'
        else:
            try:
                options = QFileDialog.Option()
                options |= QFileDialog.DontUseNativeDialog
                file_type = 'txt files (*.txt)'
                fn, _ = QFileDialog.getSaveFileName(self, 'Save Spectrum', "", file_type, options=options)
                if fn[-4:] != '.txt':
                    fn += '.txt'
                np.savetxt(fn, self.shift_list, '%3.2f')
                self.msg = fn + ' saved.'
            except Exception as err:
                self.msg = f'fails to save {fn}.  Error: {str(err)}'
        self.update_msg()


    def update_canvas_img(self):
        canvas = self.canvas1
        slide = self.sl1
        type_index = self.cb1.currentText()
        QApplication.processEvents()
        canvas.draw_line = False
        self.pb_adj_cmap.setEnabled(True)
        self.pb_set_cmap.setEnabled(True)
        self.pb_del.setEnabled(True)
        if len(canvas.mask.shape) > 1:
            print(f'canvas_mask.shape = {canvas.mask.shape}')
            sh = canvas.img_stack.shape
            canvas.special_info = None
            canvas.title = []
            canvas.update_img_stack()
            slide.setMaximum(max(sh[0] - 1, 0))
        try:
            if type_index == 'Raw image':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = self.img_xanes.shape
                canvas.img_stack = self.smooth(self.img_xanes)
                canvas.special_info = None
                canvas.current_img_index = self.sl1.value()
                canvas.title = [f'#{i:3d},   {self.xanes_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = self.img_xanes[0]

            elif type_index == 'Image updated':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_update
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = self.sl1.value()
                canvas.title = [f'#{i:3d},   {self.xanes_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                #self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Moved from external':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_external
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = img
                canvas.special_info = None
                canvas.current_img_index = self.sl1.value()
                #canvas.title = [f'#{i:3d},   {self.xanes_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
            elif type_index == 'XANES Fit (thickness)': # will be saved
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_pre_edge_sub_mean
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                canvas.title = self.elem_label
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'XANES Fit (ratio, summed to 1)': # will be saved
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_2d_fit
                img_sum = np.sum(img, axis=0, keepdims=True)
                img_sum[np.abs(img_sum) < 1e-6] = 1e6
                img = img / img_sum
                img = pyxas.rm_abnormal(img)
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = self.elem_label
                canvas.cmin = 0
                canvas.cmax = 1
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Fit (Elem. concentration)':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_2d_fit
                img_sum = np.sum(img, axis=0, keepdims=True)
                img_sum[np.abs(img_sum) < 1e-6] = 1e6
                img = img / img_sum
                img = img * self.img_pre_edge_sub_mean
                img = pyxas.rm_abnormal(img)
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = self.elem_label
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Fit variance':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_2d_fit_var

                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                canvas.title = self.elem_label
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Fit error':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_fit_cost
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'XANES Fit offset':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_2d_fit_offset
                sh = img.shape
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                #slide.setMaximum(0)
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Image Minus Offset':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_img_minus_offset
                sh = img.shape
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                # slide.setMaximum(0)
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Image regulation':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_regulation
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = [f'#{i:3d},   {self.xanes_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
            elif type_index == 'Mask':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                canvas.cmin = 0
                canvas.cmax = 1
                img = self.mask
                if len(img.shape) == 2:
                    img = img.reshape([1, img.shape[0], img.shape[1]])
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'Smart Mask':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.smart_mask
                if len(img.shape) == 2:
                    img = img.reshape([1, img.shape[0], img.shape[1]])
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = self.sl1.value()
                if canvas.current_img_index >= img.shape[0]:
                    canvas.current_img_index = 0
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(img.shape[0]-1)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Image compress':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_compress
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.data_summary[type_index] = self.canvas1.img_stackv
            elif type_index == 'Image Labels':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_labels
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Noise removal':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_rm_noise
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = self.sl1.value()
                canvas.title = ['noise removed']
                canvas.update_img_stack()
                slide.setMaximum(img.shape[0]-1)
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'XANES Edge Fit':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_edge_fit
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                # canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Peak Fit':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_peak_fit
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                '''
                try:
                    canvas.cmin = float(self.tx_edge_s.text())
                    self.tx_cmin.setText(f'{canvas.cmin}')
                    canvas.cmax = float(self.tx_edge_e.text())
                    self.tx_cmax.setText(f'{canvas.cmax}')
                except Exception as err:
                    print(err)
                '''
                # canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Peak Fit Height':
                self.img_colormix_raw  = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_peak_fit_height
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                # canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'XANES Peak Fit error':
                self.img_colormix_raw  = np.array([])
                canvas.rgb_flag = 0
                img = self.xanes_peak_fit_err
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                # canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'Peak percentage':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.peak_percentage
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                canvas.current_img_index = 0
                canvas.cmin = 0
                canvas.cmax = 1
                self.tx_cmin.setText('0')
                self.tx_cmax.setText('1')
                # canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.data_summary[type_index] = self.canvas1.img_stack
            elif type_index == 'Multi-elem fit (ratio)':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img =  self.data_summary['Multi-elem fit (ratio)']
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = self.elem_label
                canvas.cmin = 0
                canvas.cmax = 1
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.display_cmin_cmax(0, 1)
                #self.data_summary[type_index] = self.canvas1.img_stack * self.mask
            elif type_index == 'Multi-elem fit (concentration)':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img =  self.data_summary['Multi-elem fit (concentration)']
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = self.elem_label
                canvas.cmin = 0
                canvas.cmax = 1
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]
                self.auto_contrast(self.canvas1)
            elif type_index == 'Multi-elem fit error':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.multi_elem_fit_err
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                canvas.img_stack = self.smooth(img)
                canvas.special_info = None
                # canvas.current_img_index = 0
                canvas.current_img_index = self.sl1.value()
                canvas.title = []
                canvas.update_img_stack()
                slide.setMaximum(0)
                self.current_image = img[0]
                self.auto_contrast(self.canvas1)
                self.data_summary[type_index] = self.canvas1.img_stack

            elif type_index == 'Color mix':
                img = self.img_colormix
                img = self.smooth(img, axis=2)
                self.img_colormix = deepcopy(img)
                canvas.rgb_flag = 1
                cmax = np.float32(self.tx_cmax.text())
                cmin = np.float32(self.tx_cmin.text())
                # img = (img - cmin) / (cmax - cmin)
                canvas.img_stack = img
                canvas.cmin = cmin
                canvas.cmax = cmax
                canvas.current_img_index = 0
                canvas.title = 'RGB colormix'
                slide.setMaximum(0)
                # canvas.update_img_stack()
                canvas.set_contrast(cmin, cmax)

        except Exception as err:
            self.msg = f'fails to update {type_index}.  Error: {str(err)}'
            self.update_msg()
        QApplication.processEvents()


    def update_roi_list(self, mode='add', item_name=''):
        # de-select all the existing selection
        if mode == 'add':
            for i in range(self.lst_roi.count()):
                item = self.lst_roi.item(i)
                item.setSelected(False)
            item = QListWidgetItem(item_name)
            self.lst_roi.addItem(item)
            self.lst_roi.setCurrentItem(item)
        elif mode == 'del_all':
            self.lst_roi.clear()
        elif mode == 'del':
            for selectItem in self.lst_roi.selectedItems():
                self.lst_roi.removeItemWidget(selectItem)


    def change_colormap(self, current_canvas):
        #canvas = self.canvas1
        canvas = current_canvas
        if canvas == self.canvas1:
            cmap = self.cb_cmap.currentText()
        elif canvas == self.canvas_ml:
            cmap = self.cb_ml_cmap.currentText()
        canvas.colormap = cmap
        canvas.colorbar_on_flag = True
        canvas.update_img_one(canvas.current_img, canvas.current_img_index)


    def auto_contrast(self, current_canvas):
        #canvas = self.canvas1
        canvas = current_canvas
        cmin, cmax = canvas.auto_contrast()
        self.display_cmin_cmax(cmin, cmax, current_canvas)

    def display_cmin_cmax(self, cmin, cmax, current_canvas):
        if np.abs(cmax) > 1e3 or np.abs(cmax)<1e-3:
            txt_max = f'{cmax:1.3e}'
            #self.tx_cmax.setText('{:1.3e}'.format(cmax))
        else:
            txt_max = f'{cmax:6.3f}'
            #self.tx_cmax.setText('{:6.3f}'.format(cmax))
        if np.abs(cmin) > 1e3 or np.abs(cmin) < 1e-3:
            txt_min = f'{cmin:1.3e}'
            #self.tx_cmin.setText('{:1.3e}'.format(cmin))
        else:
            txt_min = f'{cmin:6.3f}'
            #self.tx_cmin.setText('{:6.3f}'.format(cmin))
        if current_canvas == self.canvas1:
            self.tx_cmax.setText(txt_max)
            self.tx_cmin.setText(txt_min)
        elif current_canvas == self.canvas_ml:
            self.tx_ml_cmax.setText(txt_max)
            self.tx_ml_cmin.setText(txt_min)
        QApplication.processEvents()

    def cmin_cmax_pressed1(self):
        return self.set_contrast(self.canvas1)

    def cmin_cmax_pressed2(self):
        return self.set_contrast(self.canvas1)

    def set_contrast(self, current_canvas):
        try:
            #canvas = self.canvas1
            canvas = current_canvas
            if canvas == self.canvas1:
                cmax = np.float32(self.tx_cmax.text())
                cmin = np.float32(self.tx_cmin.text())
            else:
                cmax = np.float32(self.tx_ml_cmax.text())
                cmin = np.float32(self.tx_ml_cmin.text())
            assert cmax >= cmin, "cmax should > cmin"
            canvas.set_contrast(cmin, cmax)
            if canvas == self.canvas1 and canvas.rgb_flag:
                self.xanes_colormix()
        except Exception as err:
            print(err)
            self.msg = str(err)
            self.update_msg()

    '''
    batch process/ 3D xanes
    '''
    def layout_3D(self):
        gpbox_3D_param_file = self.layout_3D_param_open_filefolder()
        gpbox_3D_msg = self.layout_3D_msg()
        gpbox_3D_fit_param = self.layout_3D_param_fit()
        grid_3D_find_peak = self.layout_3D_fit_peak_only()

        grid = QGridLayout()
        grid.addWidget(gpbox_3D_param_file, 0, 1)
        grid.addLayout(gpbox_3D_msg, 1, 1)
        grid.addLayout(gpbox_3D_fit_param, 2, 1)
        grid.addWidget(grid_3D_find_peak, 3, 1, 1, 2)

        tab2 = QWidget()
        tab2.setLayout(grid)

        tab1 = QWidget()
        tab1.setLayout(self.layout_3D_prep())

        tabs = QTabWidget()
        tabs.addTab(tab1, 'Preparation')
        tabs.addTab(tab2, 'Fitting')
        layout3 = QVBoxLayout()
        layout3.addWidget(tabs)
        layout3.addStretch()

        return layout3

    def layout_3D_prep(self):
        lb_empty = QLabel()
        lb_empty.setFixedHeight(20)

        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(20)

        lb_msg = QLabel()
        lb_msg.setFont(self.font1)
        lb_msg.setText('Message:')
        lb_msg.setStyleSheet('color: rgb(200, 50, 50);')
        lb_msg.setFixedWidth(80)

        self.lb_3D_prep_msg = QLabel()
        self.lb_3D_prep_msg.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_3D_prep_msg.setFont(self.font2)
        self.lb_3D_prep_msg.setFixedWidth(1000)

        hbox_msg = QHBoxLayout()
        hbox_msg.addWidget(lb_msg)
        hbox_msg.addWidget(self.lb_3D_prep_msg)
        hbox_msg.addStretch()
        hbox_msg.setAlignment(QtCore.Qt.AlignLeft)

        hbox_bottom = QHBoxLayout()
        hbox_bottom.addLayout(self.vbox_3D_load_tomo_file())
        hbox_bottom.addLayout(self.vbox_seg_extract())
        hbox_bottom.setAlignment(QtCore.Qt.AlignLeft)
        hbox_bottom.addStretch()

        vbox_ali = QVBoxLayout()
        vbox_ali.addLayout(hbox_msg)
        vbox_ali.addWidget(lb_empty)
        vbox_ali.addLayout(self.vbox_3D_load_fxi_tomo())
        vbox_ali.addLayout(self.vbox_3D_assemble_xanes())
        #vbox_ali.addLayout(self.vbox_3D_load_tomo_file())
        vbox_ali.addWidget(lb_empty1)
        vbox_ali.addLayout(hbox_bottom)
        vbox_ali.addStretch()

        return vbox_ali


    def vbox_3D_load_fxi_tomo(self):

        self.pb_load_tomo_file = QPushButton('Load FXI tomo(s)')
        self.pb_load_tomo_file.setFixedWidth(160)
        self.pb_load_tomo_file.setFont(self.font2)
        self.pb_load_tomo_file.clicked.connect(lambda: self.load_3D_tomo_file('raw'))

        self.pb_align_tomo_file = QPushButton('Align tomo files')
        self.pb_align_tomo_file.setFixedWidth(160)
        self.pb_align_tomo_file.setFont(self.font2)
        self.pb_align_tomo_file.clicked.connect(self.align_3D_tomo_file)

        self.pb_align_tomo_single = QPushButton('Align single file')
        self.pb_align_tomo_single.setFixedWidth(160)
        self.pb_align_tomo_single.setFont(self.font2)
        self.pb_align_tomo_single.clicked.connect(self.align_3D_tomo_file_single)

        lb_prefix = QLabel()
        lb_prefix.setText('file_prefix:')
        lb_prefix.setFixedWidth(80)
        lb_prefix.setFont(self.font2)
        lb_prefix.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_prefix = QLineEdit()
        self.tx_3D_prefix.setText('recon')
        self.tx_3D_prefix.setFont(self.font2)
        self.tx_3D_prefix.setFixedWidth(80)

        lb_ref_index = QLabel()
        lb_ref_index.setText('Ref. index:')
        lb_ref_index.setFixedWidth(80)
        lb_ref_index.setFont(self.font2)
        lb_ref_index.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_ref_index = QLineEdit()
        self.tx_3D_ref_index.setText('-1')
        self.tx_3D_ref_index.setFont(self.font2)
        self.tx_3D_ref_index.setFixedWidth(80)

        lb_bin = QLabel()
        lb_bin.setFixedWidth(80)
        lb_bin.setFont(self.font2)
        lb_bin.setText('binning:')
        lb_bin.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_bin = QLineEdit()
        self.tx_3D_bin.setText('1')
        self.tx_3D_bin.setFont(self.font2)
        self.tx_3D_bin.setValidator(QIntValidator())
        self.tx_3D_bin.setFixedWidth(80)

        lb_mask = QLabel()
        lb_mask.setText('circle mask ratio:')
        lb_mask.setFixedWidth(140)
        lb_mask.setFont(self.font2)
        lb_mask.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_mask = QLineEdit()
        self.tx_3D_mask.setText('1')
        self.tx_3D_mask.setFixedWidth(80)
        self.tx_3D_mask.setValidator(QDoubleValidator())
        self.tx_3D_mask.setFont(self.font2)

        lb_method = QLabel()
        lb_method.setFixedWidth(80)
        lb_method.setFont(self.font2)
        lb_method.setText('method:')
        lb_method.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_align_method = QLineEdit()
        self.tx_3D_align_method.setText('2')
        self.tx_3D_align_method.setFixedWidth(80)
        self.tx_3D_align_method.setValidator(QIntValidator())
        self.tx_3D_align_method.setFont(self.font2)

        lb_attr_img = QLabel()
        lb_attr_img.setText('attr_img:')
        lb_attr_img.setFixedWidth(80)
        lb_attr_img.setFont(self.font2)
        lb_attr_img.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_tomo_attr_img = QLineEdit()
        self.tx_3D_tomo_attr_img.setText('img')
        self.tx_3D_tomo_attr_img.setFont(self.font2)
        self.tx_3D_tomo_attr_img.setFixedWidth(80)

        lb_num_cpu = QLabel()
        lb_num_cpu.setText('num of cpu:')
        lb_num_cpu.setFixedWidth(80)
        lb_num_cpu.setFont(self.font2)
        lb_num_cpu.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_tomo_cpu = QLineEdit()
        self.tx_3D_tomo_cpu.setText('1')
        self.tx_3D_tomo_cpu.setFont(self.font2)
        self.tx_3D_tomo_cpu.setValidator(QIntValidator())
        self.tx_3D_tomo_cpu.setFixedWidth(80)

        lb_empty_ali0 = QLabel()
        lb_empty_ali0.setFixedWidth(160)

        lb_sel_ref = QLabel()
        lb_sel_ref.setFixedWidth(80)
        lb_sel_ref.setFont(self.font2)
        lb_sel_ref.setText('Ref. file:')
        lb_sel_ref.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_sel_ref = QLineEdit()
        self.tx_sel_ref.setFixedWidth(400)
        self.tx_sel_ref.setFont(self.font2)

        self.pb_sel_ref = QPushButton('select')
        self.pb_sel_ref.setFixedWidth(80)
        self.pb_sel_ref.setFont(self.font2)
        self.pb_sel_ref.clicked.connect(self.select_3D_ref_file)

        lb_empty_ali = QLabel()
        lb_empty_ali.setFixedWidth(160)

        lb_sel_align = QLabel()
        lb_sel_align.setFixedWidth(80)
        lb_sel_align.setFont(self.font2)
        lb_sel_align.setText('Align file:')
        lb_sel_align.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_sel_align = QLineEdit()
        self.tx_sel_align.setFixedWidth(400)
        self.tx_sel_align.setFont(self.font2)

        self.pb_sel_align = QPushButton('select')
        self.pb_sel_align.setFixedWidth(80)
        self.pb_sel_align.setFont(self.font2)
        self.pb_sel_align.clicked.connect(self.select_3D_align_file)


        hbox_file = QHBoxLayout()
        hbox_file.addWidget(self.pb_load_tomo_file)
        hbox_file.addWidget(lb_prefix)
        hbox_file.addWidget(self.tx_3D_prefix)
        hbox_file.addStretch()
        hbox_file.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali1 = QHBoxLayout()
        hbox_ali1.addWidget(self.pb_align_tomo_file)
        hbox_ali1.addWidget(lb_ref_index)
        hbox_ali1.addWidget(self.tx_3D_ref_index)
        hbox_ali1.addWidget(lb_bin)
        hbox_ali1.addWidget(self.tx_3D_bin)
        hbox_ali1.addWidget(lb_mask)
        hbox_ali1.addWidget(self.tx_3D_mask)
        hbox_ali1.addWidget(lb_method)
        hbox_ali1.addWidget(self.tx_3D_align_method)
        hbox_ali1.addStretch()
        hbox_ali1.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali2 = QHBoxLayout()
        hbox_ali2.addWidget(lb_empty_ali0)
        hbox_ali2.addWidget(lb_attr_img)
        hbox_ali2.addWidget(self.tx_3D_tomo_attr_img)
        hbox_ali2.addWidget(lb_num_cpu)
        hbox_ali2.addWidget(self.tx_3D_tomo_cpu)
        hbox_ali2.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali_single1 = QHBoxLayout()
        hbox_ali_single1.addWidget(self.pb_align_tomo_single)
        hbox_ali_single1.addWidget(lb_sel_ref)
        hbox_ali_single1.addWidget(self.tx_sel_ref)
        hbox_ali_single1.addWidget(self.pb_sel_ref)
        hbox_ali_single1.setAlignment(QtCore.Qt.AlignLeft)

        hbox_ali_single2 = QHBoxLayout()
        hbox_ali_single2.addWidget(lb_empty_ali)
        hbox_ali_single2.addWidget(lb_sel_align)
        hbox_ali_single2.addWidget(self.tx_sel_align)
        hbox_ali_single2.addWidget(self.pb_sel_align)
        hbox_ali_single2.setAlignment(QtCore.Qt.AlignLeft)

        lb_empty = QLabel()
        lb_empty.setFixedHeight(40)

        vbox = QVBoxLayout()
        vbox.addLayout(hbox_file)
        vbox.addLayout(hbox_ali1)
        vbox.addLayout(hbox_ali2)
        vbox.addLayout(hbox_ali_single1)
        vbox.addLayout(hbox_ali_single2)
        vbox.addWidget(lb_empty)
        vbox.addStretch()

        return vbox


    def vbox_3D_load_tomo_file(self):
        # loaded files -> listbox
        lb_tomo_file = QLabel()
        lb_tomo_file.setFont(self.font1)
        lb_tomo_file.setFixedWidth(120)
        lb_tomo_file.setText('Tomo files')

        self.lst_3D_tomo = QListWidget()
        self.lst_3D_tomo.setFont(self.font2)
        self.lst_3D_tomo.itemClicked.connect(self.show_3D_h5_attr)
        self.lst_3D_tomo.setFixedWidth(240)
        self.lst_3D_tomo.setFixedHeight(400)

        self.lb_tomo_file2 = QLabel()
        self.lb_tomo_file2.setFont(self.font1)
        self.lb_tomo_file2.setFixedWidth(120)
        self.lb_tomo_file2.setText('Labeled files')

        self.lst_3D_tomo2 = QListWidget()
        self.lst_3D_tomo2.setFont(self.font2)
        self.lst_3D_tomo2.setFixedWidth(240)
        self.lst_3D_tomo2.setFixedHeight(400)

        lb_3D_h5_attr = QLabel()
        lb_3D_h5_attr.setFont(self.font2)
        lb_3D_h5_attr.setFixedWidth(140)
        lb_3D_h5_attr.setText('Insdie .h5 tomo file: ')

        self.lb_3D_h5_attr = QLabel()
        self.lb_3D_h5_attr.setFont(self.font2)
        self.lb_3D_h5_attr.setFixedWidth(400)

        lb_h5_attr = QLabel()
        lb_h5_attr.setFont(self.font2)
        lb_h5_attr.setFixedWidth(120)
        lb_h5_attr.setText('Dataset to plot:')

        self.tx_3D_h5_attr = QLineEdit()
        self.tx_3D_h5_attr.setFont(self.font2)
        self.tx_3D_h5_attr.setText('img')
        self.tx_3D_h5_attr.setFixedWidth(80)

        self.pb_3D_plot_tomo = QPushButton('plot3D')
        self.pb_3D_plot_tomo.setFixedWidth(80)
        self.pb_3D_plot_tomo.setFont(self.font2)
        self.pb_3D_plot_tomo.clicked.connect(self.plot_3D_tomo)

        self.chkbox_napari = QCheckBox('View in napari')
        self.chkbox_napari.setFont(self.font2)
        self.chkbox_napari.setFixedWidth(155)
        self.chkbox_napari.setChecked(False)


        hbox_1 = QHBoxLayout()
        hbox_1.addWidget(lb_3D_h5_attr)
        hbox_1.addWidget(self.lb_3D_h5_attr)
        hbox_1.addStretch()

        hbox_2 = QHBoxLayout()
        hbox_2.addWidget(lb_h5_attr)
        hbox_2.addWidget(self.tx_3D_h5_attr)
        hbox_2.addWidget(self.pb_3D_plot_tomo)
        hbox_2.addStretch()

        vbox_1 = QVBoxLayout()
        vbox_1.addLayout(hbox_1)
        vbox_1.addLayout(hbox_2)
        vbox_1.addWidget(self.chkbox_napari)
        vbox_1.addStretch()

        '''
        hbox_2 = QHBoxLayout()
        hbox_2.addWidget(self.lst_3D_tomo)
        hbox_2.addLayout(vbox_1)
        hbox_2.addStretch()
        '''

        vbox_file1 = QVBoxLayout()
        vbox_file1.addWidget(lb_tomo_file)
        vbox_file1.addWidget(self.lst_3D_tomo)
        vbox_file1.addStretch()

        vbox_file2 = QVBoxLayout()
        vbox_file2.addWidget(self.lb_tomo_file2)
        vbox_file2.addWidget(self.lst_3D_tomo2)
        vbox_file2.addStretch()

        hbox_file = QHBoxLayout()
        hbox_file.addLayout(vbox_file1)
        hbox_file.addLayout(vbox_file2)
        hbox_file.addStretch()

        vbox_file = QVBoxLayout()
        vbox_file.addLayout(hbox_file)
        vbox_file.addLayout(vbox_1)
        vbox_file.addStretch()

        return vbox_file


    def vbox_segmentation(self):
        self.lb_seg_title = QLabel()
        self.lb_seg_title.setFixedWidth(200)
        self.lb_seg_title.setText('Watershed segmentation')

        self.pb_seg_select = QPushButton()
        self.pb_seg_select.setText('Select all')
        self.pb_seg_select.setFont(self.font2)
        self.pb_seg_select.setFixedWidth(160)
        self.pb_seg_select.clicked.connect(self.seg_select_all)

        self.pb_seg_unselect = QPushButton()
        self.pb_seg_unselect.setText('Clear selection')
        self.pb_seg_unselect.setFont(self.font2)
        self.pb_seg_unselect.setFixedWidth(160)
        self.pb_seg_unselect.clicked.connect(self.seg_unselect_all)

        self.pb_seg_go = QPushButton()
        self.pb_seg_go.setText('Segment')
        self.pb_seg_go.setFont(self.font2)
        self.pb_seg_go.setFixedWidth(160)
        self.pb_seg_go.clicked.connect(self.seg_seg)

        self.lb_seg_gf = QLabel()
        self.lb_seg_gf.setFixedWidth(110)
        self.lb_seg_gf.setFont(self.font2)
        self.lb_seg_gf.setText('Gaussian filter:')
        self.lb_seg_gf.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_seg_gf = QLineEdit()
        self.tx_seg_gf.setText('3')
        self.tx_seg_gf.setFixedWidth(80)
        self.tx_seg_gf.setFont(self.font2)
        self.tx_seg_gf.setValidator(QIntValidator())

        self.lb_seg_fs = QLabel()
        self.lb_seg_fs.setFixedWidth(110)
        self.lb_seg_fs.setFont(self.font2)
        self.lb_seg_fs.setText('footpint size:')
        self.lb_seg_fs.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_seg_fs = QLineEdit()
        self.tx_seg_fs.setText('15')
        self.tx_seg_fs.setFixedWidth(80)
        self.tx_seg_fs.setFont(self.font2)
        self.tx_seg_fs.setValidator(QIntValidator())

        self.lb_seg_bin = QLabel()
        self.lb_seg_bin.setFixedWidth(110)
        self.lb_seg_bin.setFont(self.font2)
        self.lb_seg_bin.setText('binning:')
        self.lb_seg_bin.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_seg_bin = QLineEdit()
        self.tx_seg_bin.setText('2')
        self.tx_seg_bin.setFixedWidth(80)
        self.tx_seg_bin.setFont(self.font2)
        self.tx_seg_bin.setValidator(QIntValidator())

        self.lb_seg_dis = QLabel()
        self.lb_seg_dis.setFixedWidth(110)
        self.lb_seg_dis.setFont(self.font2)
        self.lb_seg_dis.setText('distance:')
        self.lb_seg_dis.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_seg_dis = QLineEdit()
        self.tx_seg_dis.setText('10')
        self.tx_seg_dis.setFixedWidth(80)
        self.tx_seg_dis.setFont(self.font2)
        self.tx_seg_dis.setValidator(QIntValidator())


        hbox_pb = QHBoxLayout()
        hbox_pb.addWidget(self.pb_seg_select)
        hbox_pb.addWidget(self.pb_seg_unselect)
        hbox_pb.addWidget(self.pb_seg_go)
        hbox_pb.setAlignment(QtCore.Qt.AlignLeft)
        hbox_pb.addStretch()

        hbox = QHBoxLayout()
        hbox.addWidget(self.lb_seg_gf)
        hbox.addWidget(self.tx_seg_gf)
        hbox.addWidget(self.lb_seg_fs)
        hbox.addWidget(self.tx_seg_fs)
        hbox.setAlignment(QtCore.Qt.AlignLeft)
        hbox.addStretch()

        hbox2 = QHBoxLayout()
        hbox2.addWidget(self.lb_seg_bin)
        hbox2.addWidget(self.tx_seg_bin)
        hbox2.addWidget(self.lb_seg_dis)
        hbox2.addWidget(self.tx_seg_dis)
        hbox2.setAlignment(QtCore.Qt.AlignLeft)
        hbox2.addStretch()

        vbox = QVBoxLayout()
        vbox.addWidget(self.lb_seg_title)
        vbox.addLayout(hbox)
        vbox.addLayout(hbox2)
        vbox.addLayout(hbox_pb)
        vbox.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        vbox.addStretch()
        return vbox


    def vbox_3D_extract_particle(self):
        self.lb_extr_empty = QLabel()
        self.lb_extr_empty.setFixedHeight(10)

        self.lb_extr_title = QLabel()
        self.lb_extr_title.setText('Extract particle')
        self.lb_extr_title.setFont(self.font1)

        self.lb_extr_info = QLabel()
        self.lb_extr_info.setText('Hint: from assembled 2D slice of labeled image')
        self.lb_extr_info.setFont(self.font2)

        # open labeld folder
        self.pb_extr_open_fn_label = QPushButton()
        self.pb_extr_open_fn_label.setText('Load labeled files')
        self.pb_extr_open_fn_label.setFont(self.font2)
        self.pb_extr_open_fn_label.setFixedWidth(160)
        self.pb_extr_open_fn_label.clicked.connect(self.extract_open_label)

        # open 3D aligned folder
        self.pb_extr_open_fn_tomo = QPushButton()
        self.pb_extr_open_fn_tomo.setText('Load tomo files')
        self.pb_extr_open_fn_tomo.setFont(self.font2)
        self.pb_extr_open_fn_tomo.setFixedWidth(160)
        self.pb_extr_open_fn_tomo.clicked.connect(self.extract_open_tomo)

        hbox_load = QHBoxLayout()
        hbox_load.addWidget(self.pb_extr_open_fn_tomo)
        hbox_load.addWidget(self.pb_extr_open_fn_label)
        hbox_load.setAlignment(QtCore.Qt.AlignLeft)
        hbox_load.addStretch()
        ##

        # open labled xanes filer

        self.tx_extr_open_fn_slice = QLineEdit()
        self.tx_extr_open_fn_slice.setFont(self.font2)
        self.tx_extr_open_fn_slice.setFixedWidth(345)

        self.pb_extr_open_fn_slice = QPushButton()
        self.pb_extr_open_fn_slice.setText('2D label-xanes sli')
        self.pb_extr_open_fn_slice.setFont(self.font2)
        self.pb_extr_open_fn_slice.setFixedWidth(160)
        self.pb_extr_open_fn_slice.clicked.connect(self.extract_open_slice)

        self.pb_extr_view_sli = QPushButton()
        self.pb_extr_view_sli.setText( 'V')
        self.pb_extr_view_sli.setFont(self.font2)
        self.pb_extr_view_sli.setFixedWidth(20)
        self.pb_extr_view_sli.clicked.connect(self.extract_view_slice)

        hbox_slice = QHBoxLayout()
        hbox_slice.addWidget(self.pb_extr_open_fn_slice)
        hbox_slice.addWidget(self.tx_extr_open_fn_slice)
        hbox_slice.addWidget(self.pb_extr_view_sli)
        hbox_slice.setAlignment(QtCore.Qt.AlignLeft)
        hbox_slice.addStretch()
        ##

        self.lb_extr_row = QLabel()
        self.lb_extr_row.setFixedWidth(80)
        self.lb_extr_row.setFont(self.font2)
        self.lb_extr_row.setText('row:')
        self.lb_extr_row.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_extr_row = QLineEdit()
        self.tx_extr_row.setText('')
        self.tx_extr_row.setFixedWidth(80)
        self.tx_extr_row.setFont(self.font2)
        self.tx_extr_row.setValidator(QIntValidator())

        self.lb_extr_col = QLabel()
        self.lb_extr_col.setFixedWidth(80)
        self.lb_extr_col.setFont(self.font2)
        self.lb_extr_col.setText('col:')
        self.lb_extr_col.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_extr_col = QLineEdit()
        self.tx_extr_col.setText('')
        self.tx_extr_col.setFixedWidth(80)
        self.tx_extr_col.setFont(self.font2)
        self.tx_extr_col.setValidator(QIntValidator())

        self.lb_extr_sz = QLabel()
        self.lb_extr_sz.setFixedWidth(80)
        self.lb_extr_sz.setFont(self.font2)
        self.lb_extr_sz.setText('mask size:')
        self.lb_extr_sz.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_extr_sz = QLineEdit()
        self.tx_extr_sz.setText('150')
        self.tx_extr_sz.setFixedWidth(80)
        self.tx_extr_sz.setFont(self.font2)
        self.tx_extr_sz.setValidator(QIntValidator())

        self.lb_extr_dilation_iter = QLabel()
        self.lb_extr_dilation_iter.setFixedWidth(80)
        self.lb_extr_dilation_iter.setFont(self.font2)
        self.lb_extr_dilation_iter.setText('dilation:')
        self.lb_extr_dilation_iter.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_extr_dilation_iter = QLineEdit()
        self.tx_extr_dilation_iter.setText('1')
        self.tx_extr_dilation_iter.setFixedWidth(80)
        self.tx_extr_dilation_iter.setFont(self.font2)
        self.tx_extr_dilation_iter.setValidator(QIntValidator())

        self.lb_extr_save_prefix = QLabel()
        self.lb_extr_save_prefix.setFixedWidth(80)
        self.lb_extr_save_prefix.setFont(self.font2)
        self.lb_extr_save_prefix.setText('save prefix:')
        self.lb_extr_save_prefix.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_extr_save_prefix = QLineEdit()
        self.tx_extr_save_prefix.setText('pos1')
        self.tx_extr_save_prefix.setFixedWidth(80)
        self.tx_extr_save_prefix.setFont(self.font2)

        self.pb_extr_extr = QPushButton('Extract')
        self.pb_extr_extr.setFixedWidth(160)
        self.pb_extr_extr.setFont(self.font2)
        self.pb_extr_extr.clicked.connect(self.extract_particle)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(self.lb_extr_row)
        hbox1.addWidget(self.tx_extr_row)
        hbox1.addWidget(self.lb_extr_col)
        hbox1.addWidget(self.tx_extr_col)
        hbox1.addWidget(self.lb_extr_sz)
        hbox1.addWidget(self.tx_extr_sz)
        hbox1.setAlignment(QtCore.Qt.AlignLeft)
        hbox1.addStretch()

        hbox2 = QHBoxLayout()

        hbox2.addWidget(self.lb_extr_dilation_iter)
        hbox2.addWidget(self.tx_extr_dilation_iter)
        hbox2.addWidget(self.lb_extr_save_prefix)
        hbox2.addWidget(self.tx_extr_save_prefix)
        hbox2.setAlignment(QtCore.Qt.AlignLeft)
        hbox2.addStretch()

        vbox = QVBoxLayout()
        vbox.addWidget(self.lb_extr_title)
        vbox.addWidget(self.lb_extr_info)
        vbox.addWidget(self.lb_extr_empty)
        vbox.addLayout(hbox_load)
        vbox.addLayout(hbox_slice)
        vbox.addLayout(hbox1)
        vbox.addLayout(hbox2)
        vbox.addWidget(self.pb_extr_extr)
        vbox.setAlignment(QtCore.Qt.AlignLeft)
        vbox.addStretch()

        return vbox

    def vbox_seg_extract(self):
        lb_empty = QLabel()
        lb_empty1 = QLabel()
        lb_empty1.setFixedHeight(10)
        vbox = QVBoxLayout()
        vbox.addLayout(self.vbox_segmentation())
        vbox.addWidget(lb_empty1)
        vbox.addLayout(self.vbox_3D_extract_particle())
        vbox.addWidget(lb_empty)
        vbox.setAlignment(QtCore.Qt.AlignLeft)
        vbox.addStretch()
        return vbox

    def refresh(self, mode=False):
        self.seg_flag = mode

        self.lb_tomo_file2.setVisible(mode)
        self.lst_3D_tomo2.setVisible(mode)

        self.lb_seg_title.setVisible(mode)
        self.pb_seg_select.setVisible(mode)
        self.pb_seg_unselect.setVisible(mode)
        self.pb_seg_go.setVisible(mode)
        self.lb_seg_gf.setVisible(mode)
        self.tx_seg_gf.setVisible(mode)
        self.lb_seg_fs.setVisible(mode)
        self.tx_seg_fs.setVisible(mode)
        self.lb_seg_bin.setVisible(mode)
        self.tx_seg_bin.setVisible(mode)
        self.lb_seg_dis.setVisible(mode)
        self.tx_seg_dis.setVisible(mode)

        self.lb_extr_empty.setVisible(mode)
        self.lb_extr_title.setVisible(mode)
        self.lb_extr_info.setVisible(mode)
        self.pb_extr_view_sli.setVisible(mode)
        self.pb_extr_open_fn_label.setVisible(mode)
        self.pb_extr_open_fn_tomo.setVisible(mode)
        self.tx_extr_open_fn_slice.setVisible(mode)
        self.pb_extr_open_fn_slice.setVisible(mode)
        self.lb_extr_row.setVisible(mode)
        self.tx_extr_row.setVisible(mode)
        self.lb_extr_col.setVisible(mode)
        self.tx_extr_col.setVisible(mode)
        self.lb_extr_sz.setVisible(mode)
        self.tx_extr_sz.setVisible(mode)
        self.lb_extr_dilation_iter.setVisible(mode)
        self.tx_extr_dilation_iter.setVisible(mode)
        self.lb_extr_save_prefix.setVisible(mode)
        self.tx_extr_save_prefix.setVisible(mode)
        self.pb_extr_extr.setVisible(mode)
        QApplication.processEvents()


    def vbox_3D_assemble_xanes(self):
        lb_empty = QLabel()
        lb_empty.setFixedWidth(160)
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(160)

        self.pb_3D_assemble = QPushButton('Assemble XANES')
        self.pb_3D_assemble.setFixedWidth(160)
        self.pb_3D_assemble.setFont(self.font2)
        self.pb_3D_assemble.clicked.connect(self.assemble_3D_xanes)

        lb_attr_img = QLabel()
        lb_attr_img.setText('attr_img:')
        lb_attr_img.setFixedWidth(80)
        lb_attr_img.setFont(self.font2)
        lb_attr_img.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_attr_img = QLineEdit()
        self.tx_3D_attr_img.setText('img')
        self.tx_3D_attr_img.setFont(self.font2)
        self.tx_3D_attr_img.setFixedWidth(80)

        lb_sli = QLabel()
        lb_sli.setFixedWidth(80)
        lb_sli.setFont(self.font2)
        lb_sli.setText('slice:')
        lb_sli.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_assemble_sli = QLineEdit()
        self.tx_3D_assemble_sli.setText('[]')
        self.tx_3D_assemble_sli.setFont(self.font2)
        self.tx_3D_assemble_sli.setFixedWidth(80)

        lb_cpu = QLabel()
        lb_cpu.setFixedWidth(140)
        lb_cpu.setFont(self.font2)
        lb_cpu.setText('num of cpu:')
        lb_cpu.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_assemble_cpu = QLineEdit()
        self.tx_3D_assemble_cpu.setText('1')
        self.tx_3D_assemble_cpu.setFont(self.font2)
        self.tx_3D_assemble_cpu.setValidator(QIntValidator())
        self.tx_3D_assemble_cpu.setFixedWidth(80)

        lb_ali_flag = QLabel()
        lb_ali_flag.setText('Align?')
        lb_ali_flag.setFixedWidth(80)
        lb_ali_flag.setFont(self.font2)
        lb_ali_flag.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_assemble_ali_flag = QLineEdit()
        self.tx_3D_assemble_ali_flag.setText('True')
        self.tx_3D_assemble_ali_flag.setFixedWidth(80)
        self.tx_3D_assemble_ali_flag.setFont(self.font2)

        lb_ali_ref = QLabel()
        lb_ali_ref.setText('Ref. file:')
        lb_ali_ref.setFixedWidth(80)
        lb_ali_ref.setFont(self.font2)
        lb_ali_ref.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_assemble_ali_ref = QLineEdit()
        self.tx_3D_assemble_ali_ref.setText('-1')
        self.tx_3D_assemble_ali_ref.setFixedWidth(80)
        self.tx_3D_assemble_ali_ref.setFont(self.font2)

        lb_mask = QLabel()
        lb_mask.setText('circle mask ratio:')
        lb_mask.setFixedWidth(140)
        lb_mask.setFont(self.font2)
        lb_mask.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        lb_ali_method = QLabel()
        lb_ali_method.setText('align method:')
        lb_ali_method.setFixedWidth(100)
        lb_ali_method.setFont(self.font2)
        lb_ali_method.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.rd_3D_ali_method_translation = QRadioButton('Trans.')
        self.rd_3D_ali_method_translation.setFixedWidth(65)
        self.rd_3D_ali_method_translation.setChecked(True)
        self.rd_3D_ali_method_translation.setFont(self.font2)

        self.rd_3D_ali_method_rigid = QRadioButton('Rigid')
        self.rd_3D_ali_method_rigid.setFixedWidth(65)
        self.rd_3D_ali_method_rigid.setFont(self.font2)

        self.rd_3D_ali_method_rot = QRadioButton('Scale_rot')
        self.rd_3D_ali_method_rot.setFixedWidth(100)
        self.rd_3D_ali_method_rot.setFont(self.font2)

        self.ali_3D_group = QButtonGroup()
        self.ali_3D_group.setExclusive(True)
        self.ali_3D_group.addButton(self.rd_3D_ali_method_translation)
        self.ali_3D_group.addButton(self.rd_3D_ali_method_rigid)
        self.ali_3D_group.addButton(self.rd_3D_ali_method_rot)
        self.ali_3D_group.addButton(self.rd_3D_ali_method_rot)

        lb_ali_roi_rs = QLabel()
        lb_ali_roi_rs.setText('roi_r_start:')
        lb_ali_roi_rs.setFixedWidth(80)
        lb_ali_roi_rs.setFont(self.font2)
        lb_ali_roi_rs.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_ali_roi_rs = QLineEdit()
        self.tx_3D_ali_roi_rs.setText('0')
        self.tx_3D_ali_roi_rs.setFixedWidth(80)
        self.tx_3D_ali_roi_rs.setFont(self.font2)

        lb_ali_roi_cs = QLabel()
        lb_ali_roi_cs.setText('roi_c_start:')
        lb_ali_roi_cs.setFixedWidth(140)
        lb_ali_roi_cs.setFont(self.font2)
        lb_ali_roi_cs.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_ali_roi_cs = QLineEdit()
        self.tx_3D_ali_roi_cs.setText('0')
        self.tx_3D_ali_roi_cs.setFixedWidth(80)
        self.tx_3D_ali_roi_cs.setFont(self.font2)

        lb_ali_roi_re = QLabel()
        lb_ali_roi_re.setText('roi_r_end:')
        lb_ali_roi_re.setFixedWidth(80)
        lb_ali_roi_re.setFont(self.font2)
        lb_ali_roi_re.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_ali_roi_re = QLineEdit()
        self.tx_3D_ali_roi_re.setText('1280')
        self.tx_3D_ali_roi_re.setFixedWidth(80)
        self.tx_3D_ali_roi_re.setFont(self.font2)

        lb_ali_roi_ce = QLabel()
        lb_ali_roi_ce.setText('roi_c_end:')
        lb_ali_roi_ce.setFixedWidth(100)
        lb_ali_roi_ce.setFont(self.font2)
        lb_ali_roi_ce.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_ali_roi_ce = QLineEdit()
        self.tx_3D_ali_roi_ce.setText('1280')
        self.tx_3D_ali_roi_ce.setFixedWidth(80)
        self.tx_3D_ali_roi_ce.setFont(self.font2)

        self.tx_3D_assemble_mask = QLineEdit()
        self.tx_3D_assemble_mask.setText('1')
        self.tx_3D_assemble_mask.setFixedWidth(80)
        self.tx_3D_assemble_mask.setFont(self.font2)

        self.pb_load_aligned_tomo_file = QPushButton('Load aligned tomo')
        self.pb_load_aligned_tomo_file.setFixedWidth(160)
        self.pb_load_aligned_tomo_file.setFont(self.font2)
        self.pb_load_aligned_tomo_file.clicked.connect(lambda :
                                                       self.load_3D_tomo_file('align'))

        lb_prefix = QLabel()
        lb_prefix.setText('file_prefix:')
        lb_prefix.setFixedWidth(80)
        lb_prefix.setFont(self.font2)
        lb_prefix.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_3D_assemble_prefix = QLineEdit()
        self.tx_3D_assemble_prefix.setText('ali')
        self.tx_3D_assemble_prefix.setFont(self.font2)
        self.tx_3D_assemble_prefix.setFixedWidth(80)

        hbox_0 = QHBoxLayout()
        hbox_0.addWidget(self.pb_load_aligned_tomo_file)
        hbox_0.addWidget(lb_prefix)
        hbox_0.addWidget(self.tx_3D_assemble_prefix)
        hbox_0.addStretch()

        hbox_1 = QHBoxLayout()
        hbox_1.addWidget(self.pb_3D_assemble)
        hbox_1.addWidget(lb_attr_img)
        hbox_1.addWidget(self.tx_3D_attr_img)
        hbox_1.addWidget(lb_sli)
        hbox_1.addWidget(self.tx_3D_assemble_sli)
        hbox_1.addWidget(lb_cpu)
        hbox_1.addWidget(self.tx_3D_assemble_cpu)
        hbox_1.addStretch()

        hbox_2 = QHBoxLayout()
        hbox_2.addWidget(lb_empty)
        hbox_2.addWidget(lb_ali_flag)
        hbox_2.addWidget(self.tx_3D_assemble_ali_flag)
        hbox_2.addWidget(lb_ali_ref)
        hbox_2.addWidget(self.tx_3D_assemble_ali_ref)
        hbox_2.addWidget(lb_mask)
        hbox_2.addWidget(self.tx_3D_assemble_mask)
        hbox_2.addWidget(lb_ali_method)
        hbox_2.addWidget(self.rd_3D_ali_method_translation)
        hbox_2.addWidget(self.rd_3D_ali_method_rigid)
        hbox_2.addWidget(self.rd_3D_ali_method_rot)
        hbox_2.addStretch()

        hbox_3 = QHBoxLayout()
        hbox_3.addWidget(lb_empty2)
        hbox_3.addWidget(lb_ali_roi_rs)
        hbox_3.addWidget(self.tx_3D_ali_roi_rs)
        hbox_3.addWidget(lb_ali_roi_re)
        hbox_3.addWidget(self.tx_3D_ali_roi_re)
        hbox_3.addWidget(lb_ali_roi_cs)
        hbox_3.addWidget(self.tx_3D_ali_roi_cs)
        hbox_3.addWidget(lb_ali_roi_ce)
        hbox_3.addWidget(self.tx_3D_ali_roi_ce)
        hbox_3.addStretch()

        vbox_1 = QVBoxLayout()
        vbox_1.addLayout(hbox_0)
        vbox_1.addLayout(hbox_1)
        vbox_1.addLayout(hbox_2)
        vbox_1.addLayout(hbox_3)
        vbox_1.addStretch()
        vbox_1.setAlignment(QtCore.Qt.AlignTop)

        return vbox_1


    def layout_3D_param_open_filefolder(self):
        gpbox = QGroupBox('Files')
        gpbox.setFont(self.font1)

        # file directory
        lb_param_filepath = QLabel()
        lb_param_filepath.setFont(self.font2)
        lb_param_filepath.setText('File path:')
        lb_param_filepath.setFixedWidth(80)

        self.tx_param_folder = QLineEdit()
        self.tx_param_folder.setFixedWidth(250)
        # self.tx_param_folder.setEnabled(False)
        self.tx_param_folder.setFont(self.font2)

        self.pb_file = QPushButton('Open')
        self.pb_file.setFont(self.font2)
        self.pb_file.clicked.connect(self.open_3D_folder)
        self.pb_file.setFixedWidth(80)
        self.pb_file.setFixedWidth(80)

        hbox_param_open = QHBoxLayout()
        hbox_param_open.addWidget(lb_param_filepath)
        hbox_param_open.addWidget(self.tx_param_folder)
        hbox_param_open.addWidget(self.pb_file)
        hbox_param_open.setAlignment(QtCore.Qt.AlignLeft)

        self.tx_param_pre_s = QLineEdit()
        self.tx_param_pre_s.setFixedWidth(60)
        self.tx_param_pre_s.setFont(self.font2)

        # file name and type
        lb_param_file_name = QLabel()
        lb_param_file_name.setFont(self.font2)
        lb_param_file_name.setText('File name start with:')
        lb_param_file_name.setFixedWidth(140)

        self.tx_param_file_prefix = QLineEdit()
        self.tx_param_file_prefix.setFixedWidth(60)
        self.tx_param_file_prefix.setText('xanes')
        self.tx_param_file_prefix.setFont(self.font2)

        lb_param_file_type = QLabel()
        lb_param_file_type.setFont(self.font2)
        lb_param_file_type.setText('  format:')
        lb_param_file_type.setFixedWidth(60)

        self.tx_param_file_type = QLineEdit()
        self.tx_param_file_type.setFixedWidth(60)
        self.tx_param_file_type.setText('.tiff')
        self.tx_param_file_type.setFont(self.font2)

        self.pb_load_file = QPushButton('Load')
        self.pb_load_file.setFont(self.font2)
        self.pb_load_file.clicked.connect(self.load_3D_xanes_image_file)
        self.pb_load_file.setFixedWidth(80)

        # file type: .h5 or .tiff
        lb_param_true_file_type = QLabel()
        lb_param_true_file_type.setText('  File type:')
        lb_param_true_file_type.setFont(self.font2)
        lb_param_true_file_type.setFixedWidth(80)

        self.file_group_3D = QButtonGroup()
        self.file_group_3D.setExclusive(True)
        self.rd_3D_hdf = QRadioButton('hdf')
        self.rd_3D_hdf.setFixedWidth(60)

        self.rd_3D_tif = QRadioButton('tiff')
        self.rd_3D_tif.setFixedWidth(60)
        self.rd_3D_tif.setChecked(True)

        self.file_group_3D.addButton(self.rd_3D_hdf)
        self.file_group_3D.addButton(self.rd_3D_tif)

        lb_param_fit_hdf = QLabel()
        lb_param_fit_hdf.setText('Dataset:')
        lb_param_fit_hdf.setFixedWidth(80)
        lb_param_fit_hdf.setFont(self.font2)

        self.tx_param_hdf = QLineEdit()
        self.tx_param_hdf.setFixedWidth(80)
        self.tx_param_hdf.setText('img_xanes')
        self.tx_param_hdf.setFont(self.font2)

        hbox_param_file = QHBoxLayout()
        hbox_param_file.addWidget(lb_param_file_name)
        hbox_param_file.addWidget(self.tx_param_file_prefix)
        hbox_param_file.addWidget(lb_param_file_type)
        hbox_param_file.addWidget(self.tx_param_file_type)
        hbox_param_file.addWidget(self.pb_load_file)
        hbox_param_file.addWidget(lb_param_true_file_type)
        hbox_param_file.addWidget(self.rd_3D_tif)
        hbox_param_file.addWidget(self.rd_3D_hdf)
        hbox_param_file.addWidget(self.tx_param_hdf)
        hbox_param_file.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_file = QVBoxLayout()
        vbox_param_file.addLayout(hbox_param_open)
        vbox_param_file.addLayout(hbox_param_file)
        vbox_param_file.setAlignment(QtCore.Qt.AlignTop)

        gpbox.setLayout(vbox_param_file)

        return gpbox


    def layout_3D_param_default(self):
        pass


    def layout_3D_msg(self):
        self.lb_3D_ip = QLabel()
        self.lb_3D_ip.setFont(self.font2)
        self.lb_3D_ip.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_3D_ip.setText('File loaded:')

        self.lb_3D_msg = QLabel()
        self.lb_3D_msg.setFont(self.font1)
        self.lb_3D_msg.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_3D_msg.setText('Message: Load File first before batch fitting')

        vbox_msg = QVBoxLayout()
        # vbox_msg.addWidget(self.lb_3D_ip)
        vbox_msg.addWidget(self.lb_3D_msg)
        vbox_msg.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_msg

    def layout_3D_param_fit(self):

        param_cpu = self.layout_3D_param_cpu()
        param_txm_norm = self.layout_3D_param_txm_norm()
        param_edge_fit = self.layout_3D_param_edge_norm()
        #param_peak_reg = self.layout_3D_param_edge_regulation()
        param_image_align = self.layout_3D_param_align()
        param_xanes_fit_eng = self.layout_3D_param_fitting()
        param_xanes_fit_method = self.layout_3D_fitting_method()
        param_mask = self.layout_3D_param_mask()
        param_ref = self.layout_3D_param_ref()
        param_execute = self.layout_3D_param_execute()
        param_colormix = self.layout_3D_param_colormix()
        #param_comb_color_ref = QVBoxLayout()
        #param_comb_color_ref.addLayout(param_colormix)
        #param_comb_color_ref.addLayout(param_ref)
        param_comb = QVBoxLayout()
        param_comb.addLayout(param_mask)
        param_comb.addLayout(param_ref)

        grid = QGridLayout()
        grid.addLayout(param_cpu, 0, 1)
        grid.addLayout(param_txm_norm, 0, 2)
        grid.addLayout(param_edge_fit, 1, 1)
        #grid.addLayout(param_peak_reg, 1, 2)
        #grid.addLayout(param_image_align, 2, 1)
        grid.addLayout(param_image_align, 1, 2)
        grid.addLayout(param_xanes_fit_eng, 2, 1)
        grid.addLayout(param_colormix, 2, 2)
        grid.addLayout(param_mask, 2, 2)
        #grid.addLayout(param_xanes_fit, 3, 1)
        #grid.addLayout(param_comb_color_ref, 3, 2)
        grid.addLayout(param_xanes_fit_method, 3, 1)
        grid.addLayout(param_comb, 3, 2)
        # grid.addLayout(param_ref, 4, 2)
        grid.addLayout(param_execute, 4, 1, 1, 2)

        return grid

    def layout_3D_param_cpu(self):
        lb_param_parellel = QLabel()
        lb_param_parellel.setFont(self.font1)
        lb_param_parellel.setText('Parallel and Binning')

        lb_param_cpu = QLabel()
        lb_param_cpu.setFont(self.font2)
        lb_param_cpu.setText('Number of CPU:')
        lb_param_cpu.setFixedWidth(140)

        self.tx_param_cpu = QLineEdit()
        self.tx_param_cpu.setFixedWidth(60)
        self.tx_param_cpu.setText('1')
        self.tx_param_cpu.setValidator(QIntValidator())
        self.tx_param_cpu.setFont(self.font2)

        lb_param_bin = QLabel()
        lb_param_bin.setFont(self.font2)
        lb_param_bin.setText('  Binning: ')
        lb_param_bin.setFixedWidth(70)

        self.tx_param_bin = QLineEdit()
        self.tx_param_bin.setFixedWidth(60)
        self.tx_param_bin.setText('1')
        self.tx_param_bin.setValidator(QIntValidator())
        self.tx_param_bin.setFont(self.font2)

        hbox_param_cpu = QHBoxLayout()
        hbox_param_cpu.addWidget(lb_param_cpu)
        hbox_param_cpu.addWidget(self.tx_param_cpu)
        hbox_param_cpu.addWidget(lb_param_bin)
        hbox_param_cpu.addWidget(self.tx_param_bin)
        hbox_param_cpu.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_cpu = QVBoxLayout()
        vbox_param_cpu.addWidget(lb_param_parellel)
        vbox_param_cpu.addLayout(hbox_param_cpu)
        vbox_param_cpu.addWidget(self.lb_empty)
        vbox_param_cpu.setAlignment(QtCore.Qt.AlignTop)
        return vbox_param_cpu

    '''
    def layout_3D_param_bin(self):
        lb_param_bin = QLabel()
        lb_param_bin.setFont(self.font1)
        lb_param_bin.setText('Image binning')

        lb_param_bin = QLabel()
        lb_param_bin.setFont(self.font2)
        lb_param_bin.setText('Binning: ')
        lb_param_bin.setFixedWidth(140)

        self.tx_param_bin = QLineEdit()
        self.tx_param_bin.setFixedWidth(60)
        self.tx_param_bin.setText('1')
        self.tx_param_bin.setValidator(QIntValidator())
        self.tx_param_bin.setFont(self.font2)

        hbox_param_bin = QHBoxLayout()
        hbox_param_bin.addWidget(lb_param_bin)
        hbox_param_bin.addWidget(self.tx_param_bin)
        hbox_param_bin.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_bin = QVBoxLayout()
        vbox_param_bin.addWidget(lb_param_bin)
        vbox_param_bin.addLayout(hbox_param_bin)
        vbox_param_bin.addWidget(self.lb_empty)
        vbox_param_bin.setAlignment(QtCore.Qt.AlignTop)
        return vbox_param_bin
        '''

    def layout_3D_param_txm_norm(self):
        lb_param_txm_norm0 = QLabel()
        lb_param_txm_norm0.setFont(self.font1)
        lb_param_txm_norm0.setText('TXM normalization')
        lb_param_txm_norm0.setFixedWidth(140)

        lb_param_txm_norm = QLabel()
        lb_param_txm_norm.setFont(self.font2)
        lb_param_txm_norm.setText('Take -log()')
        lb_param_txm_norm.setFixedWidth(80)

        self.param_txm_norm_group = QButtonGroup()
        self.param_txm_norm_group.setExclusive(True)
        self.rd_param_txm_norm_yes = QRadioButton('Yes')
        self.rd_param_txm_norm_yes.setFixedWidth(80)

        self.rd_param_txm_norm_no = QRadioButton('No')
        self.rd_param_txm_norm_no.setFixedWidth(80)

        self.param_txm_norm_group.addButton(self.rd_param_txm_norm_yes)
        self.param_txm_norm_group.addButton(self.rd_param_txm_norm_no)
        self.param_txm_norm_group.setExclusive(True)
        self.rd_param_txm_norm_no.setChecked(True)

        hbox_param_txm_norm = QHBoxLayout()
        hbox_param_txm_norm.addWidget(lb_param_txm_norm)
        hbox_param_txm_norm.addWidget(self.rd_param_txm_norm_yes)
        hbox_param_txm_norm.addWidget(self.rd_param_txm_norm_no)
        hbox_param_txm_norm.addWidget(self.lb_empty)
        hbox_param_txm_norm.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_txm_norm = QVBoxLayout()
        vbox_param_txm_norm.addWidget(lb_param_txm_norm0)
        vbox_param_txm_norm.addLayout(hbox_param_txm_norm)
        vbox_param_txm_norm.addWidget(self.lb_empty)
        vbox_param_txm_norm.setAlignment(QtCore.Qt.AlignTop)
        return vbox_param_txm_norm

    def layout_3D_param_edge_norm(self):
        lb_space = QLabel()
        lb_space.setFixedWidth(40)

        lb_param_fit_edge0 = QLabel()
        lb_param_fit_edge0.setFont(self.font1)
        lb_param_fit_edge0.setText('Edge normalization')
        lb_param_fit_edge0.setFixedWidth(140)

        # normalization method
        lb_param_fit_edge_method = QLabel()
        lb_param_fit_edge_method.setFont(self.font2)
        lb_param_fit_edge_method.setText('Method:')
        lb_param_fit_edge_method.setFixedWidth(80)

        self.chkbox_param_fit_edge_method = QCheckBox('Global slope')
        self.chkbox_param_fit_edge_method.setFixedWidth(140)
        self.chkbox_param_fit_edge_method.setLayoutDirection(QtCore.Qt.RightToLeft)
        self.chkbox_param_fit_edge_method.setFont(self.font2)

        hbox_param_fit_edge_method = QHBoxLayout()
        hbox_param_fit_edge_method.addWidget(lb_param_fit_edge0)
        # hbox_param_fit_edge_method.addWidget(lb_space)
        hbox_param_fit_edge_method.addWidget(self.chkbox_param_fit_edge_method)
        hbox_param_fit_edge_method.setAlignment(QtCore.Qt.AlignLeft)

        # normalize or not
        lb_param_fit_edge = QLabel()
        lb_param_fit_edge.setFont(self.font2)
        lb_param_fit_edge.setText('Norm absorp. edge')
        lb_param_fit_edge.setFixedWidth(140)

        self.fit_edge_group = QButtonGroup()
        self.fit_edge_group.setExclusive(True)
        self.rd_param_fit_edge_yes = QRadioButton('Yes')
        self.rd_param_fit_edge_yes.setFixedWidth(80)

        self.rd_param_fit_edge_no = QRadioButton('No')
        self.rd_param_fit_edge_no.setFixedWidth(80)

        self.fit_edge_group.addButton(self.rd_param_fit_edge_yes)
        self.fit_edge_group.addButton(self.rd_param_fit_edge_no)
        self.fit_edge_group.setExclusive(True)
        self.rd_param_fit_edge_no.setChecked(True)

        hbox_param_fit_edge_flag = QHBoxLayout()
        hbox_param_fit_edge_flag.addWidget(lb_param_fit_edge)
        hbox_param_fit_edge_flag.addWidget(self.rd_param_fit_edge_yes)
        hbox_param_fit_edge_flag.addWidget(self.rd_param_fit_edge_no)
        hbox_param_fit_edge_flag.setAlignment(QtCore.Qt.AlignLeft)

        # pre-edge
        lb_param_pre = QLabel()
        lb_param_pre.setFont(self.font2)
        lb_param_pre.setText('Pre-edge')
        lb_param_pre.setFixedWidth(80)

        lb_param_pre_start = QLabel()
        lb_param_pre_start.setFont(self.font2)
        lb_param_pre_start.setText('start:')
        lb_param_pre_start.setFixedWidth(60)

        lb_param_pre_end = QLabel()
        lb_param_pre_end.setFont(self.font2)
        lb_param_pre_end.setText('  end:')
        lb_param_pre_end.setFixedWidth(60)

        self.tx_param_pre_s = QLineEdit()
        self.tx_param_pre_s.setFixedWidth(60)
        self.tx_param_pre_s.setFont(self.font2)

        self.tx_param_pre_e = QLineEdit()
        self.tx_param_pre_e.setFixedWidth(60)
        self.tx_param_pre_e.setFont(self.font2)

        hbox_param_pre = QHBoxLayout()
        hbox_param_pre.addWidget(lb_param_pre)
        hbox_param_pre.addWidget(lb_param_pre_start)
        hbox_param_pre.addWidget(self.tx_param_pre_s)
        hbox_param_pre.addWidget(lb_param_pre_end)
        hbox_param_pre.addWidget(self.tx_param_pre_e)
        hbox_param_pre.setAlignment(QtCore.Qt.AlignLeft)

        # post edge
        lb_param_post = QLabel()
        lb_param_post.setFont(self.font2)
        lb_param_post.setText('Post-edge')
        lb_param_post.setFixedWidth(80)

        lb_param_post_start = QLabel()
        lb_param_post_start.setFont(self.font2)
        lb_param_post_start.setText('start:')
        lb_param_post_start.setFixedWidth(60)

        lb_param_post_end = QLabel()
        lb_param_post_end.setFont(self.font2)
        lb_param_post_end.setText('  end:')
        lb_param_post_end.setFixedWidth(60)

        self.tx_param_post_s = QLineEdit()
        self.tx_param_post_s.setFixedWidth(60)
        self.tx_param_post_s.setFont(self.font2)

        self.tx_param_post_e = QLineEdit()
        self.tx_param_post_e.setFixedWidth(60)
        self.tx_param_post_e.setFont(self.font2)

        hbox_param_post = QHBoxLayout()
        hbox_param_post.addWidget(lb_param_post)
        hbox_param_post.addWidget(lb_param_post_start)
        hbox_param_post.addWidget(self.tx_param_post_s)
        hbox_param_post.addWidget(lb_param_post_end)
        hbox_param_post.addWidget(self.tx_param_post_e)
        hbox_param_post.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_edge = QVBoxLayout()
        vbox_param_edge.addLayout(hbox_param_fit_edge_method)
        vbox_param_edge.addLayout(hbox_param_fit_edge_flag)
        vbox_param_edge.addLayout(hbox_param_fit_edge_method)
        vbox_param_edge.addLayout(hbox_param_pre)
        vbox_param_edge.addLayout(hbox_param_post)
        vbox_param_edge.addWidget(self.lb_empty)
        vbox_param_edge.setAlignment(QtCore.Qt.AlignTop)

        return vbox_param_edge

    '''
    def layout_3D_param_edge_regulation(self):
        lb_param_reg_edge0 = QLabel()
        lb_param_reg_edge0.setFont(self.font1)
        lb_param_reg_edge0.setText('Peak regularization')
        lb_param_reg_edge0.setFixedWidth(140)
        # normalize or not
        lb_param_reg_edge = QLabel()
        lb_param_reg_edge.setFont(self.font2)
        lb_param_reg_edge.setText('Peak regulation')
        lb_param_reg_edge.setFixedWidth(140)

        self.reg_edge_group = QButtonGroup()
        self.reg_edge_group.setExclusive(True)
        self.rd_param_reg_edge_yes = QRadioButton('Yes')
        self.rd_param_reg_edge_yes.setFixedWidth(80)

        self.rd_param_reg_edge_no = QRadioButton('No')
        self.rd_param_reg_edge_no.setFixedWidth(80)
        self.rd_param_reg_edge_no.setChecked(True)

        self.reg_edge_group.addButton(self.rd_param_reg_edge_yes)
        self.reg_edge_group.addButton(self.rd_param_reg_edge_no)
        self.reg_edge_group.setExclusive(True)

        hbox_param_reg_edge_flag = QHBoxLayout()
        hbox_param_reg_edge_flag.addWidget(lb_param_reg_edge)
        hbox_param_reg_edge_flag.addWidget(self.rd_param_reg_edge_yes)
        hbox_param_reg_edge_flag.addWidget(self.rd_param_reg_edge_no)
        hbox_param_reg_edge_flag.setAlignment(QtCore.Qt.AlignLeft)

        # regulation peak max
        lb_param_reg_peak = QLabel()
        lb_param_reg_peak.setFont(self.font2)
        lb_param_reg_peak.setText('Peak maximum:')
        lb_param_reg_peak.setFixedWidth(140)

        self.tx_param_reg_peak = QLineEdit()
        self.tx_param_reg_peak.setFixedWidth(60)
        self.tx_param_reg_peak.setFont(self.font2)

        # regulation gamma
        lb_param_reg_gamma = QLabel()
        lb_param_reg_gamma.setFont(self.font2)
        lb_param_reg_gamma.setText('  Width:')
        lb_param_reg_gamma.setFixedWidth(60)

        self.tx_param_reg_gamma = QLineEdit()
        self.tx_param_reg_gamma.setText('0.05')
        self.tx_param_reg_gamma.setFixedWidth(60)
        self.tx_param_reg_gamma.setFont(self.font2)

        hbox_param_reg_peak = QHBoxLayout()
        hbox_param_reg_peak.addWidget(lb_param_reg_peak)
        hbox_param_reg_peak.addWidget(self.tx_param_reg_peak)
        hbox_param_reg_peak.addWidget(lb_param_reg_gamma)
        hbox_param_reg_peak.addWidget(self.tx_param_reg_gamma)
        hbox_param_reg_peak.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_reg = QVBoxLayout()
        vbox_param_reg.addWidget(lb_param_reg_edge0)
        vbox_param_reg.addLayout(hbox_param_reg_edge_flag)
        vbox_param_reg.addLayout(hbox_param_reg_peak)
        vbox_param_reg.addWidget(self.lb_empty)
        vbox_param_reg.setAlignment(QtCore.Qt.AlignTop)

        return vbox_param_reg
    '''

    def layout_3D_param_align(self):
        lb_param_align0 = QLabel()
        lb_param_align0.setFont(self.font1)
        lb_param_align0.setText('Image alignment')
        lb_param_align0.setFixedWidth(140)
        # Alignment
        lb_param_align = QLabel()
        lb_param_align.setFont(self.font2)
        lb_param_align.setText('Image alignment')
        lb_param_align.setFixedWidth(140)

        self.align_group = QButtonGroup()
        self.align_group.setExclusive(True)
        self.rd_param_align_yes = QRadioButton('Yes')
        self.rd_param_align_yes.setFixedWidth(80)

        self.rd_param_align_no = QRadioButton('No')
        self.rd_param_align_no.setFixedWidth(80)

        self.align_group.addButton(self.rd_param_align_yes)
        self.align_group.addButton(self.rd_param_align_no)
        self.align_group.setExclusive(True)
        self.rd_param_align_no.setChecked(True)

        hbox_param_align_flag = QHBoxLayout()
        hbox_param_align_flag.addWidget(lb_param_align)
        hbox_param_align_flag.addWidget(self.rd_param_align_yes)
        hbox_param_align_flag.addWidget(self.rd_param_align_no)
        hbox_param_align_flag.setAlignment(QtCore.Qt.AlignLeft)

        # ROI ratio
        lb_param_align_roi = QLabel()
        lb_param_align_roi.setFont(self.font2)
        lb_param_align_roi.setText('  Ratio:')
        lb_param_align_roi.setFixedWidth(60)

        self.tx_param_align_roi = QLineEdit()
        self.tx_param_align_roi.setFixedWidth(60)
        self.tx_param_align_roi.setText('0.9')
        self.tx_param_align_roi.setFont(self.font2)

        # reference index
        lb_param_align_ref = QLabel()
        lb_param_align_ref.setFont(self.font2)
        lb_param_align_ref.setText('Reference index:')
        lb_param_align_ref.setFixedWidth(140)

        self.tx_param_align_ref = QLineEdit()
        self.tx_param_align_ref.setFixedWidth(60)
        self.tx_param_align_ref.setText('-1')
        self.tx_param_align_ref.setFont(self.font2)

        hbox_param_align_ref = QHBoxLayout()
        hbox_param_align_ref.addWidget(lb_param_align_ref)
        hbox_param_align_ref.addWidget(self.tx_param_align_ref)
        hbox_param_align_ref.addWidget(lb_param_align_roi)
        hbox_param_align_ref.addWidget(self.tx_param_align_roi)
        hbox_param_align_ref.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_align = QVBoxLayout()
        vbox_param_align.addWidget(lb_param_align0)
        vbox_param_align.addLayout(hbox_param_align_flag)
        vbox_param_align.addLayout(hbox_param_align_ref)
        vbox_param_align.addWidget(self.lb_empty)
        vbox_param_align.setAlignment(QtCore.Qt.AlignTop)

        # gpbox.setLayout(vbox_param_align)
        return vbox_param_align

    def layout_3D_param_fitting(self):
        # gpbox = QGroupBox('Fitting')
        # gpbox.setFont(self.font1)
        lb_param_fit_iter0 = QLabel()
        lb_param_fit_iter0.setFont(self.font1)
        lb_param_fit_iter0.setText('Energy fitting range')
        lb_param_fit_iter0.setFixedWidth(160)

        # Fit energy range
        lb_param_fit_range = QLabel()
        lb_param_fit_range.setFont(self.font2)
        lb_param_fit_range.setText('Eng. range')
        lb_param_fit_range.setFixedWidth(80)

        lb_param_fit_range_start = QLabel()
        lb_param_fit_range_start.setFont(self.font2)
        lb_param_fit_range_start.setText('start:')
        lb_param_fit_range_start.setFixedWidth(55)

        lb_param_fit_range_end = QLabel()
        lb_param_fit_range_end.setFont(self.font2)
        lb_param_fit_range_end.setText('  end:')
        lb_param_fit_range_end.setFixedWidth(60)

        self.tx_param_fit_range_s = QLineEdit()
        self.tx_param_fit_range_s.setFixedWidth(60)
        self.tx_param_fit_range_s.setFont(self.font2)

        self.tx_param_fit_range_e = QLineEdit()
        self.tx_param_fit_range_e.setFixedWidth(60)
        self.tx_param_fit_range_e.setFont(self.font2)

        hbox_param_fit_range = QHBoxLayout()
        hbox_param_fit_range.addWidget(lb_param_fit_range)
        hbox_param_fit_range.addWidget(lb_param_fit_range_start)
        hbox_param_fit_range.addWidget(self.tx_param_fit_range_s)
        hbox_param_fit_range.addWidget(lb_param_fit_range_end)
        hbox_param_fit_range.addWidget(self.tx_param_fit_range_e)
        hbox_param_fit_range.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_fit_range = QVBoxLayout()
        vbox_param_fit_range.addWidget(lb_param_fit_iter0)
        vbox_param_fit_range.addLayout(hbox_param_fit_range)
        return vbox_param_fit_range

    def layout_3D_fitting_method(self):

        # XANES fitting
         # fit 3D method
        lb_param_fit_method = QLabel()
        lb_param_fit_method.setText('Fitting method: ')
        lb_param_fit_method.setFixedWidth(120)
        lb_param_fit_method.setFont(self.font1)

        self.rd_param_fit_method1 = QRadioButton('Basic')
        self.rd_param_fit_method1.setFixedWidth(120)
        self.rd_param_fit_method1.setFont(self.font2)
        self.rd_param_fit_method1.setChecked(True)
        #self.rd_param_fit_method1.toggled.connect(self.select_2d_fitting_method)

        self.rd_param_fit_method3 = QRadioButton('NN-ADMM')
        self.rd_param_fit_method3.setFixedWidth(120)
        self.rd_param_fit_method3.setFont(self.font2)
        self.rd_param_fit_method3.setChecked(False)
        #self.rd_param_fit_method3.toggled.connect(self.select_2d_fitting_method)

        self.fit_param_method_group = QButtonGroup()
        self.fit_param_method_group.setExclusive(True)
        self.fit_param_method_group.addButton(self.rd_fit_method1)
        #self.fit_param_method_group.addButton(self.rd_fit_method2)
        self.fit_param_method_group.addButton(self.rd_fit_method3)

        hbox_fit_param_method = QHBoxLayout()
        #hbox_fit_param_method.addWidget(lb_param_fit_method)
        hbox_fit_param_method.addWidget(self.rd_param_fit_method1)
        #hbox_fit_param_method.addWidget(self.rd_fit_method2)
        hbox_fit_param_method.addWidget(self.rd_param_fit_method3)
        hbox_fit_param_method.setAlignment(QtCore.Qt.AlignLeft)

        ##
        lb_param_bkg_poly = QLabel()
        lb_param_bkg_poly.setFont(self.font2)
        lb_param_bkg_poly.setText('Bkg. polynomial:')
        lb_param_bkg_poly.setFixedWidth(120)

        self.chkbox_param_bkg_poly1 = QCheckBox('1')
        self.chkbox_param_bkg_poly1.setFixedWidth(45)
        self.chkbox_param_bkg_poly1.setFont(self.font2)
        self.chkbox_param_bkg_poly1.setChecked(False)

        self.chkbox_param_bkg_poly2 = QCheckBox('0')
        self.chkbox_param_bkg_poly2.setFixedWidth(45)
        self.chkbox_param_bkg_poly2.setFont(self.font2)
        self.chkbox_param_bkg_poly2.setChecked(True)

        self.chkbox_param_bkg_poly3 = QCheckBox('-1')
        self.chkbox_param_bkg_poly3.setFixedWidth(45)
        self.chkbox_param_bkg_poly3.setFont(self.font2)
        self.chkbox_param_bkg_poly3.setChecked(False)

        self.chkbox_param_bkg_poly4 = QCheckBox('-2')
        self.chkbox_param_bkg_poly4.setFixedWidth(45)
        self.chkbox_param_bkg_poly4.setFont(self.font2)
        self.chkbox_param_bkg_poly4.setChecked(False)

        self.chkbox_param_bkg_poly5 = QCheckBox('-3')
        self.chkbox_param_bkg_poly5.setFixedWidth(45)
        self.chkbox_param_bkg_poly5.setFont(self.font2)
        self.chkbox_param_bkg_poly5.setChecked(False)

        hbox_param_bkg_poly = QHBoxLayout()
        hbox_param_bkg_poly.addWidget(lb_param_bkg_poly)
        hbox_param_bkg_poly.addWidget(self.chkbox_param_bkg_poly1)
        hbox_param_bkg_poly.addWidget(self.chkbox_param_bkg_poly2)
        hbox_param_bkg_poly.addWidget(self.chkbox_param_bkg_poly3)
        hbox_param_bkg_poly.addWidget(self.chkbox_param_bkg_poly4)
        hbox_param_bkg_poly.addWidget(self.chkbox_param_bkg_poly5)
        hbox_param_bkg_poly.setAlignment(QtCore.Qt.AlignLeft)

        ##
        lb_param_iter_num = QLabel()
        lb_param_iter_num.setFont(self.font2)
        lb_param_iter_num.setText('Maximum iteration:')
        lb_param_iter_num.setFixedWidth(140)

        self.tx_param_iter_num = QLineEdit(self)
        self.tx_param_iter_num.setFont(self.font2)
        self.tx_param_iter_num.setText('10')
        self.tx_param_iter_num.setValidator(QIntValidator())
        self.tx_param_iter_num.setFixedWidth(100)
        self.tx_param_iter_num.setEnabled(True)

        hbox_param_fit_iter_num = QHBoxLayout()
        hbox_param_fit_iter_num.addWidget(lb_param_iter_num)
        hbox_param_fit_iter_num.addWidget(self.tx_param_iter_num)
        hbox_param_fit_iter_num.setAlignment(QtCore.Qt.AlignTop)

        ##
        lb_param_fit_rate = QLabel()
        lb_param_fit_rate.setFont(self.font2)
        lb_param_fit_rate.setText('Denoise level:')
        lb_param_fit_rate.setFixedWidth(140)

        self.tx_param_fit_rate = QLineEdit(self)
        self.tx_param_fit_rate.setFont(self.font2)
        self.tx_param_fit_rate.setText('0.05')  # conjugate gradient updating rate
        self.tx_param_fit_rate.setFixedWidth(100)
        self.tx_param_fit_rate.setEnabled(True)

        hbox_param_fit_iter_rate = QHBoxLayout()
        hbox_param_fit_iter_rate.addWidget(lb_param_fit_rate)
        hbox_param_fit_iter_rate.addWidget(self.tx_param_fit_rate)
        hbox_param_fit_iter_rate.setAlignment(QtCore.Qt.AlignTop)


        lb_param_fit_sigma = QLabel()
        lb_param_fit_sigma.setFont(self.font2)
        lb_param_fit_sigma.setText('Sigma:')
        lb_param_fit_sigma.setFixedWidth(140)

        self.tx_param_fit_sigma = QLineEdit(self)
        self.tx_param_fit_sigma.setFont(self.font2)
        self.tx_param_fit_sigma.setText('0.1')  # conjugate gradient updating rate
        self.tx_param_fit_sigma.setFixedWidth(100)
        self.tx_param_fit_sigma.setValidator(QDoubleValidator())

        hbox_param_fit_iter_sigma = QHBoxLayout()
        hbox_param_fit_iter_sigma.addWidget(lb_param_fit_sigma)
        hbox_param_fit_iter_sigma.addWidget(self.tx_param_fit_sigma)
        hbox_param_fit_iter_sigma.setAlignment(QtCore.Qt.AlignTop)


        vbox_param_fit = QVBoxLayout()
        #vbox_param_fit.addWidget(lb_param_fit_iter0)
        #vbox_param_fit.addLayout(hbox_param_fit_edge)
        #vbox_param_fit.addLayout(hbox_param_fit_range)
        vbox_param_fit.addWidget(self.lb_empty)
        vbox_param_fit.addWidget(lb_param_fit_method)
        vbox_param_fit.addLayout(hbox_fit_param_method)
        vbox_param_fit.addLayout(hbox_param_bkg_poly)
        vbox_param_fit.addLayout(hbox_param_fit_iter_num)
        vbox_param_fit.addLayout(hbox_param_fit_iter_rate)
        vbox_param_fit.addLayout(hbox_param_fit_iter_sigma)
        #vbox_param_fit.addWidget(self.chkbox_fit_iter)
        #vbox_param_fit.addLayout(hbox_param_fit_iter_p)
        #vbox_param_fit.addLayout(hbox_param_fit_iter_bounds)
        #vbox_param_fit.addLayout(hbox_param_fit_iter_lambda)
        vbox_param_fit.addWidget(self.lb_empty)
        vbox_param_fit.setAlignment(QtCore.Qt.AlignTop)

        # gpbox.setLayout(vbox_param_fit)
        return vbox_param_fit

    def layout_3D_param_mask(self):
        # gpbox = QGroupBox('Mask')
        # gpbox.setFont(self.font1)
        lb_param_smart_mask0 = QLabel()
        lb_param_smart_mask0.setFont(self.font1)
        lb_param_smart_mask0.setText('Cluster / Threshold Mask')
        lb_param_smart_mask0.setFixedWidth(180)
        # smart mask
        lb_param_smart_mask = QLabel()
        lb_param_smart_mask.setFont(self.font2)
        lb_param_smart_mask.setText('Cluster mask comp.')
        lb_param_smart_mask.setFixedWidth(140)

        self.tx_param_smart_mask_comp = QLineEdit()
        self.tx_param_smart_mask_comp.setFixedWidth(60)
        self.tx_param_smart_mask_comp.setText('0')
        self.tx_param_smart_mask_comp.setFont(self.font2)

        hbox_param_smart_mask_comp = QHBoxLayout()
        hbox_param_smart_mask_comp.addWidget(lb_param_smart_mask)
        hbox_param_smart_mask_comp.addWidget(self.tx_param_smart_mask_comp)
        hbox_param_smart_mask_comp.setAlignment(QtCore.Qt.AlignLeft)

        # XANES fitting mask
        lb_param_threshold = QLabel()
        lb_param_threshold.setFont(self.font2)
        lb_param_threshold.setText('Threshold: thickness:')
        lb_param_threshold.setFixedWidth(140)

        self.tx_param_threshold_thick = QLineEdit()
        self.tx_param_threshold_thick.setFixedWidth(60)
        self.tx_param_threshold_thick.setText('0')
        self.tx_param_threshold_thick.setFont(self.font2)

        lb_param_threshold_error = QLabel()
        lb_param_threshold_error.setFont(self.font2)
        lb_param_threshold_error.setText('  error:')
        lb_param_threshold_error.setFixedWidth(60)

        self.tx_param_threshold_error = QLineEdit()
        self.tx_param_threshold_error.setFixedWidth(60)
        self.tx_param_threshold_error.setText('100')
        self.tx_param_threshold_error.setFont(self.font2)

        hbox_param_fit_threshold_mask = QHBoxLayout()
        hbox_param_fit_threshold_mask.addWidget(lb_param_threshold)
        hbox_param_fit_threshold_mask.addWidget(self.tx_param_threshold_thick)
        hbox_param_fit_threshold_mask.addWidget(lb_param_threshold_error)
        hbox_param_fit_threshold_mask.addWidget(self.tx_param_threshold_error)
        hbox_param_fit_threshold_mask.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_mask = QVBoxLayout()
        vbox_param_mask.addWidget(lb_param_smart_mask0)
        vbox_param_mask.addLayout(hbox_param_smart_mask_comp)
        vbox_param_mask.addLayout(hbox_param_fit_threshold_mask)
        vbox_param_mask.addWidget(self.lb_empty)
        vbox_param_mask.setAlignment(QtCore.Qt.AlignTop)

        return vbox_param_mask

    def layout_3D_param_ref(self):
        lb_param_ref = QLabel()
        lb_param_ref.setFont(self.font1)
        lb_param_ref.setText('Reference spec. & X-ray energy')
        lb_param_ref.setFixedWidth(240)

        # ref
        self.pb_param_load_ref = QPushButton('Load Ref.')
        self.pb_param_load_ref.setFont(self.font2)
        self.pb_param_load_ref.clicked.connect(self.load_3D_reference)
        self.pb_param_load_ref.setFixedWidth(80)

        self.pb_param_plot_ref = QPushButton('Plot Ref.')
        self.pb_param_plot_ref.setFont(self.font2)
        self.pb_param_plot_ref.clicked.connect(self.plot_3D_reference)
        self.pb_param_plot_ref.setFixedWidth(80)

        self.pb_param_reset_ref = QPushButton('Reset Ref.')
        self.pb_param_reset_ref.setFont(self.font2)
        self.pb_param_reset_ref.clicked.connect(self.reset_3D_reference)
        self.pb_param_reset_ref.setFixedWidth(80)

        self.pb_param_eng = QPushButton('Load XEng')
        self.pb_param_eng.setFont(self.font2)
        self.pb_param_eng.clicked.connect(self.load_3D_energy)
        self.pb_param_eng.setFixedWidth(80)

        self.lb_param_ref_info = QLabel()
        self.lb_param_ref_info.setFont(self.font2)
        self.lb_param_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_param_ref_info.setText('Reference spectrum: ')
        self.lb_param_ref_info.setFixedWidth(450)

        self.lb_param_eng_info = QLabel()
        self.lb_param_eng_info.setFont(self.font2)
        self.lb_param_eng_info.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_param_eng_info.setText('Energy: ')
        self.lb_param_eng_info.setFixedWidth(450)

        hbox_param_load_ref = QHBoxLayout()
        hbox_param_load_ref.addWidget(self.pb_param_load_ref)
        hbox_param_load_ref.addWidget(self.pb_param_plot_ref)
        hbox_param_load_ref.addWidget(self.pb_param_reset_ref)
        hbox_param_load_ref.addWidget(self.pb_param_eng)
        hbox_param_load_ref.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_load_ref = QVBoxLayout()
        vbox_param_load_ref.addWidget(lb_param_ref)
        vbox_param_load_ref.addLayout(hbox_param_load_ref)
        vbox_param_load_ref.addWidget(self.lb_param_ref_info)
        vbox_param_load_ref.addWidget(self.lb_param_eng_info)
        vbox_param_load_ref.setAlignment(QtCore.Qt.AlignLeft)

        return vbox_param_load_ref

    def layout_3D_param_colormix(self):
        lb_param_colormix = QLabel()
        lb_param_colormix.setFont(self.font1)
        lb_param_colormix.setText('Color Mix')
        lb_param_colormix.setFixedWidth(240)

        lb_param_color = QLabel()
        lb_param_color.setFont(self.font2)
        lb_param_color.setText('Color Mix')
        lb_param_color.setFixedWidth(80)

        self.tx_param_color = QLineEdit()
        self.tx_param_color.setFixedWidth(60)
        self.tx_param_color.setText('r, g, b')
        self.tx_param_color.setFont(self.font2)

        lb_param_color_hint = QLabel()
        lb_param_color_hint.setFont(self.font2)
        lb_param_color_hint.setText("   choose from 'r, g, b, c, p, y'")

        hbox_param_colormix = QHBoxLayout()
        hbox_param_colormix.addWidget(lb_param_color)
        hbox_param_colormix.addWidget(self.tx_param_color)
        hbox_param_colormix.addWidget(lb_param_color_hint)
        hbox_param_colormix.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_colormix = QVBoxLayout()
        vbox_param_colormix.addWidget(lb_param_colormix)
        vbox_param_colormix.addLayout(hbox_param_colormix)
        vbox_param_colormix.addWidget(self.lb_empty)
        vbox_param_colormix.setAlignment(QtCore.Qt.AlignLeft)

        return vbox_param_colormix

    def layout_3D_param_execute(self):
        lb_empty = QLabel()
        self.pb_param_save_param = QPushButton('Save parameter')
        self.pb_param_save_param.setFont(self.font2)
        self.pb_param_save_param.clicked.connect(self.save_3D_fit_param)
        self.pb_param_save_param.setFixedWidth(120)

        self.pb_param_load_param = QPushButton('Load parameter')
        self.pb_param_load_param.setFont(self.font2)
        self.pb_param_load_param.clicked.connect(self.load_3D_fit_param)
        self.pb_param_load_param.setFixedWidth(120)

        self.pb_param_test_fit = QPushButton('Test single fitting')
        self.pb_param_test_fit.setFont(self.font2)
        self.pb_param_test_fit.clicked.connect(self.test_single_fitting)
        self.pb_param_test_fit.setFixedWidth(120)
        self.pb_param_test_fit.setStyleSheet('color: rgb(200, 50, 50);')

        lb_single_file = QLabel()
        lb_single_file.setFont(self.font2)
        lb_single_file.setFixedWidth(50)
        lb_single_file.setText('File id:')

        self.tx_param_test_fit = QLineEdit()
        self.tx_param_test_fit.setFont(self.font2)
        self.tx_param_test_fit.setText('0')
        self.tx_param_test_fit.setFixedWidth(60)

        self.pb_param_batch_fit = QPushButton('Batch fitting')
        self.pb_param_batch_fit.setFont(self.font2)
        self.pb_param_batch_fit.clicked.connect(self.batch_fitting)
        self.pb_param_batch_fit.setFixedWidth(120)
        self.pb_param_batch_fit.setStyleSheet('color: rgb(200, 50, 50);')

        self.tx_param_output = QPlainTextEdit()
        self.tx_param_output.resize(6, 200)

        self.lb_execute_output = QLabel()
        self.lb_execute_output.setFixedWidth(800)
        self.lb_execute_output.setStyleSheet('color: rgb(200, 50, 50);')

        hbox_param_save_load = QHBoxLayout()
        hbox_param_save_load.addWidget(self.pb_param_save_param)
        hbox_param_save_load.addWidget(self.pb_param_load_param)
        hbox_param_save_load.setAlignment(QtCore.Qt.AlignLeft)

        hbox_param_test_fit = QHBoxLayout()
        hbox_param_test_fit.addWidget(self.pb_param_test_fit)
        hbox_param_test_fit.addWidget(lb_single_file)
        hbox_param_test_fit.addWidget(self.tx_param_test_fit)
        hbox_param_test_fit.addWidget(self.pb_param_batch_fit)
        hbox_param_test_fit.setAlignment(QtCore.Qt.AlignLeft)

        vbox_param_execute = QVBoxLayout()
        vbox_param_execute.addLayout(hbox_param_save_load)
        vbox_param_execute.addLayout(hbox_param_test_fit)
        vbox_param_execute.addWidget(self.lb_execute_output)
        # vbox_param_execute.addWidget(self.tx_param_output)
        vbox_param_execute.setAlignment(QtCore.Qt.AlignTop)

        return vbox_param_execute

    def layout_3D_fit_peak_only(self):
        gpbox = QGroupBox()
        gpbox.setFont(self.font1)
        gpbox.setTitle('Fit Peak / Cluster Mask only  ')

        lb_edge_range = QLabel()
        lb_edge_range.setFont(self.font1)
        lb_edge_range.setText('Energy range:')
        lb_edge_range.setFixedWidth(100)

        lb_edge_range_s = QLabel()
        lb_edge_range_s.setFont(self.font2)
        lb_edge_range_s.setText('start:')
        lb_edge_range_s.setFixedWidth(50)

        lb_edge_range_e = QLabel()
        lb_edge_range_e.setFont(self.font2)
        lb_edge_range_e.setText('end:')
        lb_edge_range_e.setFixedWidth(50)

        self.tx_3D_edge_s = QLineEdit()
        self.tx_3D_edge_s.setFont(self.font2)
        self.tx_3D_edge_s.setFixedWidth(60)
        self.tx_3D_edge_s.setValidator(QDoubleValidator())

        self.tx_3D_edge_e = QLineEdit()
        self.tx_3D_edge_e.setFont(self.font2)
        self.tx_3D_edge_e.setFixedWidth(60)
        self.tx_3D_edge_e.setValidator(QDoubleValidator())

        lb_empty1 = QLabel()
        lb_empty1.setFixedWidth(20)
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(30)
        lb_empty3 = QLabel()
        lb_empty3.setFixedWidth(20)
        lb_empty4 = QLabel()
        lb_empty4.setFixedWidth(20)

        lb_edge_param = QLabel()
        lb_edge_param.setText('Fit param:')
        lb_edge_param.setFont(self.font1)
        lb_edge_param.setFixedWidth(80)

        lb_edge_smooth = QLabel()
        lb_edge_smooth.setText('smooth:')
        lb_edge_smooth.setFixedWidth(60)
        lb_edge_smooth.setFont(self.font2)

        self.tx_3D_edge_smooth = QLineEdit()
        self.tx_3D_edge_smooth.setText('0.002')
        self.tx_3D_edge_smooth.setFont(self.font2)
        self.tx_3D_edge_smooth.setValidator(QDoubleValidator())
        self.tx_3D_edge_smooth.setFixedWidth(60)

        lb_edge_order = QLabel()
        lb_edge_order.setText('order:')
        lb_edge_order.setFixedWidth(50)
        lb_edge_order.setFont(self.font2)

        self.tx_3D_edge_order = QLineEdit()
        self.tx_3D_edge_order.setText('3')
        self.tx_3D_edge_order.setFont(self.font2)
        self.tx_3D_edge_order.setValidator(QIntValidator())
        self.tx_3D_edge_order.setFixedWidth(60)

        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(20)

        lb_empty3 = QLabel()
        lb_empty3.setFixedWidth(20)

        lb_scale_img = QLabel()
        lb_scale_img.setText('scale  x')
        lb_scale_img.setFixedWidth(50)
        lb_scale_img.setFont(self.font2)

        self.tx_3D_scale_img = QLineEdit()
        self.tx_3D_scale_img.setText('1.0')
        self.tx_3D_scale_img.setFont(self.font2)
        self.tx_3D_scale_img.setValidator(QDoubleValidator())
        self.tx_3D_scale_img.setFixedWidth(60)

        hbox_peak_param = QHBoxLayout()
        hbox_peak_param.addWidget(lb_edge_range)
        hbox_peak_param.addWidget(lb_edge_range_s)
        hbox_peak_param.addWidget(self.tx_3D_edge_s)
        hbox_peak_param.addWidget(lb_empty1)
        hbox_peak_param.addWidget(lb_edge_range_e)
        hbox_peak_param.addWidget(self.tx_3D_edge_e)
        hbox_peak_param.addWidget(lb_empty2)
        hbox_peak_param.addWidget(lb_edge_param)
        hbox_peak_param.addWidget(lb_edge_order)
        hbox_peak_param.addWidget(self.tx_3D_edge_order)
        hbox_peak_param.addWidget(lb_empty4)
        hbox_peak_param.addWidget(lb_scale_img)
        hbox_peak_param.addWidget(self.tx_3D_scale_img)
        hbox_peak_param.setAlignment(QtCore.Qt.AlignLeft)

        lb_peak_maxmin = QLabel()
        lb_peak_maxmin.setText('Fit peak:')
        lb_peak_maxmin.setFixedWidth(80)
        lb_peak_maxmin.setFont(self.font1)

        self.peak_group_3D = QButtonGroup()
        self.peak_group_3D.setExclusive(True)
        self.rd_3D_peak_max = QRadioButton('find max')
        self.rd_3D_peak_max.setFixedWidth(100)
        self.rd_3D_peak_max.setChecked(True)
        self.rd_3D_peak_max.setFont(self.font2)
        self.rd_3D_peak_max.setChecked(True)

        self.rd_3D_peak_min = QRadioButton('find min')
        self.rd_3D_peak_min.setFixedWidth(100)
        self.rd_3D_peak_min.setFont(self.font2)

        self.peak_group_3D.addButton(self.rd_3D_peak_max)
        self.peak_group_3D.addButton(self.rd_3D_peak_min)

        self.chkbox_3D_gen_th_mask = QCheckBox('threshold mask')
        self.chkbox_3D_gen_th_mask.setFont(self.font2)
        self.chkbox_3D_gen_th_mask.setFixedWidth(150)
        self.chkbox_3D_gen_th_mask.setChecked(False)

        self.pb_3D_gen_cl_mask = QPushButton()
        self.pb_3D_gen_cl_mask.setText('Gen. cluster mask')
        self.pb_3D_gen_cl_mask.setFont(self.font2)
        self.pb_3D_gen_cl_mask.setFixedWidth(180)
        self.pb_3D_gen_cl_mask.clicked.connect(self.gen_3D_smart_mask)

        self.pb_3D_find_peak_img = QPushButton()
        self.pb_3D_find_peak_img.setText('Find peak')
        self.pb_3D_find_peak_img.setFont(self.font2)
        self.pb_3D_find_peak_img.setFixedWidth(180)
        self.pb_3D_find_peak_img.clicked.connect(self.find_3D_peak_image_poly)

        lb_param_cpu = QLabel()
        lb_param_cpu.setFont(self.font1)
        lb_param_cpu.setText('Number of CPU:')
        lb_param_cpu.setFixedWidth(120)

        self.tx_3D_peak_cpu = QLineEdit()
        self.tx_3D_peak_cpu.setFixedWidth(60)
        self.tx_3D_peak_cpu.setText('1')
        self.tx_3D_peak_cpu.setValidator(QIntValidator())
        self.tx_3D_peak_cpu.setFont(self.font2)

        hbox_peak_maxmin = QHBoxLayout()
        hbox_peak_maxmin.addWidget(lb_peak_maxmin)
        hbox_peak_maxmin.addWidget(self.rd_3D_peak_max)
        hbox_peak_maxmin.addWidget(self.rd_3D_peak_min)
        hbox_peak_maxmin.addWidget(self.chkbox_3D_gen_th_mask)

        hbox_peak_maxmin.addWidget(self.pb_3D_find_peak_img)
        hbox_peak_maxmin.addWidget(self.pb_3D_gen_cl_mask)
        hbox_peak_maxmin.setAlignment(QtCore.Qt.AlignLeft)

        vbox_3D_find_peak = QVBoxLayout()
        vbox_3D_find_peak.addLayout(hbox_peak_param)
        vbox_3D_find_peak.addLayout(hbox_peak_maxmin)
        vbox_3D_find_peak.setAlignment(QtCore.Qt.AlignTop)
        gpbox.setLayout(vbox_3D_find_peak)
        return gpbox

    def open_3D_folder(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = '*.*'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", '*', options=options)
        fn_tmp = fn.split('/')
        file_type = fn_tmp[-1].split('.')[-1]
        self.file_path = '/'.join(t for t in fn_tmp[:-1])
        # self.file_path = QFileDialog.getExistingDirectory(None, 'Select a folder:', self.fpath, QFileDialog.ShowDirsOnly)
        self.tx_param_folder.setText(self.file_path)
        self.tx_param_file_prefix.setText(fn_tmp[-1][:3])
        self.tx_param_file_type.setText('.' + file_type)
        self.lb_execute_output.setText('')
        self.lb_3D_msg.setText(f'Message: ')
        if 'tif' in file_type:
            self.rd_3D_tif.setChecked(True)
        else:
            self.rd_3D_hdf.setChecked(True)
        self.load_3D_xanes_image_file()

    def load_3D_xanes_image_file(self):
        self.load_file_successful = 0
        try:
            self.file_path = self.tx_param_folder.text()
            self.file_prefix = self.tx_param_file_prefix.text()
            self.file_type = self.tx_param_file_type.text()
            self.xanes_files = pyxas.retrieve_file_type(self.file_path, self.file_prefix, self.file_type)
            print('file load in sequence:')
            for fn in self.xanes_files:
                print(fn.split("/")[-1])
            msg = f'{self.xanes_files[0].split("/")[-1]}  ...  {self.xanes_files[-1].split("/")[-1]}'
            self.lb_3D_msg.setText(f'Message: {len(self.xanes_files)} files loaded:   [{msg}]')
            self.load_file_successful = 1
        except Exception as err:
            print(err)
            self.load_file_successful = 0

    def load_3D_reference(self):

        self.lb_param_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
        self.load_reference_successful = 0
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                fn_tmp = fn.split('/')
                fn_ref = '/'.join(t for t in fn_tmp[-4:])
                fn_ref = f'.../{fn_ref}'
                print(f'selected reference: {fn_ref}')

                self.lb_ref_info.setText(self.lb_ref_info.text() + '\n' + f'ref #{self.num_ref}: ' + fn_ref)
                self.lb_ref_info.setStyleSheet('color: rgb(200, 50, 50);')
                QApplication.processEvents()

                self.lb_param_ref_info.setText(self.lb_param_ref_info.text() + '\n' + f'ref #{self.num_ref}: ' + fn_ref)
                QApplication.processEvents()
                self.spectrum_ref[f'ref{self.num_ref}'] = np.loadtxt(fn)
                self.num_ref += 1
                self.load_reference_successful = 1
            except Exception as err:
                print(f'un-supported xanes reference format. Error: {str(err)}')
                self.load_reference_successful = 0

    def load_3D_energy(self):
        self.load_eng_successful = 0
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", ' txt files (*.txt)',
                                            options=options)
        try:
            self.eng = np.loadtxt(fn)
            n_eng = len(self.eng)
            self.lb_param_eng_info.setText(
                f'Energy: {n_eng} energies: {self.eng[0]:2.4f}, {self.eng[1]:2.4f},   ...   {self.eng[-1]:2.4f} keV')
            self.load_eng_successful = 1
            if not self.load_file_successful:
                self.tx_param_fit_range_s.setText(f'{self.eng[0]:2.4f}')
                self.tx_param_fit_range_e.setText(f'{self.eng[-1]:2.4f}')
            self.tx_3D_edge_s.setText(f'{self.eng[0]:2.4f}')
            self.tx_3D_edge_e.setText(f'{self.eng[-1]:2.4f}')
            self.tx_param_fit_range_s.setText(f'{self.eng[0]:2.4f}')
            self.tx_param_fit_range_e.setText(f'{self.eng[-1]:2.4f}')
        except Exception as err:
            self.lb_param_eng_info.setText('Energy load fails')
            self.load_eng_successful = 0
            print(err)
            self.lb_3D_msg.setText(str(err))

    def plot_3D_reference(self):
        plt.figure()
        legend = []
        try:
            for i in range(self.num_ref):
                plot_label = f'ref_{i}'
                spec = self.spectrum_ref[f'ref{i}']
                line, = plt.plot(spec[:, 0], spec[:, 1], label=plot_label)
                legend.append(line)
            print(legend)
            plt.legend(handles=legend)
            plt.show()
        except Exception as err:
            print(err)
            self.lb_param_ref_info = 'un-recognized reference spectrum format'

    def reset_3D_reference(self):
        self.reset_xanes_ref()

    def collect_3D_fit_param(self):
        self.lb_3D_msg.setText('')
        self.msg_3d = ''
        self.fit_param = {}
        try:
            self.fit_param['align_flag'] = 1 if self.rd_param_align_yes.isChecked() else 0
            self.fit_param['align_ref_index'] = int(self.tx_param_align_ref.text())

            self.fit_param['bin'] = int(self.tx_param_bin.text())

            roi_ratio = self.tx_param_align_roi.text()
            roi_ratio = float(roi_ratio) if roi_ratio else 1
            self.fit_param['roi_ratio'] = roi_ratio
            self.tx_param_align_roi.setText(str(roi_ratio))

            # fit_eng
            fit_eng_s = self.tx_param_fit_range_s.text()
            fit_eng_e = self.tx_param_fit_range_e.text()
            fit_eng_s = float(fit_eng_s) if fit_eng_s else self.eng[0]
            fit_eng_e = float(fit_eng_e) if fit_eng_e else self.eng[-1]
            self.fit_param['fit_eng'] = [fit_eng_s, fit_eng_e]
            self.tx_param_fit_range_s.setText(f'{fit_eng_s:2.4f}')
            self.tx_param_fit_range_e.setText(f'{fit_eng_e:2.4f}')

            #  fit_method
            self.fit_param['fit_method'] = 'basic' if self.rd_param_fit_method1.isChecked() else 'admm'
            self.fit_param['fit_bkg_poly'] = []
            if self.chkbox_param_bkg_poly1.isChecked():
                self.fit_param['fit_bkg_poly'].append(1)
            if self.chkbox_param_bkg_poly2.isChecked():
                self.fit_param['fit_bkg_poly'].append(0)
            if self.chkbox_param_bkg_poly3.isChecked():
                self.fit_param['fit_bkg_poly'].append(-1)
            if self.chkbox_param_bkg_poly4.isChecked():
                self.fit_param['fit_bkg_poly'].append(-2)
            if self.chkbox_param_bkg_poly5.isChecked():
                self.fit_param['fit_bkg_poly'].append(-3)
            try:
                self.fit_param['fit_iter_num'] = int(self.tx_param_iter_num.text())
            except:
                self.fit_param['fit_iter_num'] = 100
                self.tx_param_iter_num.setText('100')
            try:
                self.fit_param['fit_iter_learning_rate'] = float(self.tx_param_fit_rate.text())
            except:
                self.fit_param['fit_iter_learning_rate'] = 0.02
                self.tx_param_fit_rate.text('0.02')

            try:
                self.fit_param['fit_iter_sigma'] = float(self.tx_param_fit_sigma.text())
            except:
                self.fit_param['fit_iter_sigma'] = 0.1
                self.tx_param_fit_sigma.setText('0.1')

            # mask
            self.fit_param['fit_mask_thickness_threshold'] = float(self.tx_param_threshold_thick.text())
            self.fit_param['fit_mask_cost_threshold'] = float(self.tx_param_threshold_error.text())

            cluster_comp = int(self.tx_param_smart_mask_comp.text())
            self.fit_param['mask_xanes_flag'] = 1 if cluster_comp else 0
            self.fit_param['n_comp'] = cluster_comp

            self.fit_param['norm_edge_method'] = 'new' if self.chkbox_param_fit_edge_method.isChecked() else 'old'
            self.fit_param['norm_txm_flag'] = 1 if self.rd_param_txm_norm_yes.isChecked() else 0

            if self.rd_param_fit_edge_yes.isChecked(): # need edge normalization
                self.fit_param['norm_edge_flag'] = 1
                # pre_edge for normalization
                pre_edge_s = self.tx_param_pre_s.text()
                try:
                    pre_edge_s = float(pre_edge_s)
                except:
                    save_successful = 0
                    raise Exception(self.msg_3d + 'fail to save "Pre-edge-start", ')
                pre_edge_e = self.tx_param_pre_e.text()
                try:
                    pre_edge_e = float(pre_edge_e)
                except:
                    save_successful = 0
                    raise Exception(self.msg_3d + 'fail to save "Pre-edge-end", ')
                self.fit_param['pre_edge'] = [pre_edge_s, pre_edge_e]
                self.tx_param_pre_s.setText(f'{pre_edge_s:2.4f}')
                self.tx_param_pre_e.setText(f'{pre_edge_e:2.4f}')

                # post_edge for normalization
                post_edge_e = self.tx_param_post_e.text()
                try:
                    post_edge_e = float(post_edge_e)
                except:
                    save_successful = 0
                    raise Exception(self.msg_3d + 'fail to save "Post-edge-start", ')
                post_edge_s = self.tx_param_post_s.text()
                try:
                    post_edge_s = float(post_edge_s)
                except:
                    save_successful = 0
                    raise Exception(self.msg_3d + 'fail to save "Post-edge-end", ')
                self.fit_param['post_edge'] = [post_edge_s, post_edge_e]
                self.tx_param_post_s.setText(f'{post_edge_s:2.4f}')
                self.tx_param_post_e.setText(f'{post_edge_e:2.4f}')
            else: # don't need edge normalization
                self.fit_param['norm_edge_flag'] = 0
                self.fit_param['post_edge'] = []
                self.fit_param['pre_edge'] = []

            '''
            self.fit_param['regulation_flag'] = 1 if self.rd_param_reg_edge_yes.isChecked() else 0
            peak_max = self.tx_param_reg_peak.text()
            peak_max = float(peak_max) if peak_max else 1.6
            self.fit_param['regulation_designed_max'] = peak_max
            self.tx_param_reg_peak.setText(f'{peak_max:2.4f}')

            peak_width = self.tx_param_reg_gamma.text()
            peak_width = float(peak_width) if peak_width else 0.05
            self.fit_param['regulation_gamma'] = peak_width
            self.tx_param_reg_gamma.setText(f'{peak_width:2.4f}')
            '''

            self.num_cpu = min(int(self.tx_param_cpu.text()), round(cpu_count() * 0.8))
            self.tx_param_cpu.setText(str(self.num_cpu))

            if self.rd_3D_tif.isChecked():
                self.fit_param['file_type'] = 'tiff'
            else:
                self.fit_param['file_type'] = 'h5'
            self.fit_param['hdf_attr'] = self.tx_param_hdf.text()
            self.fit_param['num_cpu'] = self.num_cpu

            self.fit_param['color'] = self.tx_param_color.text()
        except Exception as err:
            raise Exception(err)

    def save_3D_fit_param(self):
        self.save_fit_param_successful = 0
        save_successful = 1
        try:
            self.collect_3D_fit_param()
        except Exception as err:
            print(err)
            save_successful = 0
            self.lb_3D_msg.setText(str(err))
        # save to .csv
        if save_successful:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = 'csv (*.csv)'
            fn, _ = QFileDialog.getSaveFileName(self, 'Save File', "", file_type, options=options)
            if fn.split('.')[-1] != 'csv':
                fn += '.csv'
            pyxas.save_xanes_fit_param_file(self.fit_param, fn)
            self.lb_execute_output.setText(f'{fn} saved')
            self.tx_param_output.appendPlainText(f'{fn} saved')
            self.save_fit_param_successful = 1
        else:
            print('fails to save fitting parameter')
            self.lb_execute_output.setText('fails to save fitting parameter')
            self.save_fit_param_successful = 0

    def load_3D_fit_param(self):
        self.load_fit_param_successful = 0
        try:
            options = QFileDialog.Option()
            options |= QFileDialog.DontUseNativeDialog
            file_type = ' csv files (*.csv)'
            fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
            if fn:
                self.fit_param = pyxas.load_xanes_fit_param_file(fn, num_items=0)
                txt = self.lb_execute_output.text() + f'\nfit_param loaded: {fn}'
                self.lb_execute_output.setText(txt)
                self.load_fit_param_successful = 1

                if self.fit_param['align_flag']:
                    self.rd_param_align_yes.setChecked(1)
                    align_index = int(self.fit_param['align_ref_index'])
                    self.tx_param_align_ref.setText(str(align_index))
                    roi_ratio = self.fit_param['roi_ratio']
                    self.tx_param_align_roi.setText(str(roi_ratio))
                else:
                    self.rd_param_align_no.setChecked(True)
                '''
                fit_pre_edge_flag = self.fit_param['fit_pre_edge_flag']
                if fit_pre_edge_flag:
                    self.chkbox_fit_pre_edge.setChecked(1)
                else:
                    self.chkbox_fit_pre_edge.setChecked(0)
                fit_post_edge_flag = self.fit_param['fit_pre_edge_flag']
                if fit_post_edge_flag:
                    self.chkbox_fit_post_edge.setChecked(True)
                else:
                    self.chkbox_fit_post_edge.setChecked(0)
                '''
                # fit_eng
                try:
                    fit_eng_s = self.fit_param['fit_eng'][0]
                    self.tx_param_fit_range_s.setText(f'{fit_eng_s:2.4f}')
                    fit_eng_e = self.fit_param['fit_eng'][1]
                    self.tx_param_fit_range_e.setText(f'{fit_eng_e:2.4f}')
                except Exception as err:
                    print(err)

                '''
                # fit_iter_bound
                fit_iter_flag = self.fit_param['fit_iter_flag']
                if fit_iter_flag:
                    self.chkbox_fit_iter.setChecked(1)
                    fit_bound_s, fit_bound_e = self.fit_param['fit_iter_bound']
                    self.tx_param_iter_bounds_low.setText(str(fit_bound_s))
                    self.tx_param_iter_bounds_high.setText(str(fit_bound_e))
                    learn_rate = float(self.fit_param['fit_iter_learning_rate'])
                    self.tx_param_iter_rate.setText(f'{learn_rate:1.4f}')
                    fit_iter_num = int(self.fit_param['fit_iter_num'])
                    self.tx_param_iter_num.setText(str(fit_iter_num))
                    try:
                        fit_iter_lambda = float(self.fit_param['fit_iter_lambda'])
                    except Exception as err:
                        print(err)
                        fit_iter_lambda = 0.5
                    self.tx_param_iter_lambda.setText(f'{fit_iter_lambda:2.4f}')
                else:
                    self.chkbox_fit_iter.setChecked(0)
                '''

                # fit method
                fit_method = self.fit_param['fit_method']
                if fit_method == 'basic':
                    self.rd_param_fit_method1.setChecked(True)
                else:
                    self.rd_param_fit_method3.setChecked(True)
                bkg_poly = np.int16(self.fit_param['fit_bkg_poly'])

                if 1 in bkg_poly:
                    self.chkbox_param_bkg_poly1.setChecked(True)
                if 0 in bkg_poly:
                    self.chkbox_param_bkg_poly2.setChecked(True)
                if -1 in bkg_poly:
                    self.chkbox_param_bkg_poly3.setChecked(True)
                if -2 in bkg_poly:
                    self.chkbox_param_bkg_poly4.setChecked(True)
                if -3 in bkg_poly:
                    self.chkbox_param_bkg_poly5.setChecked(True)

                self.tx_param_iter_num.setText(str(self.fit_param['fit_iter_num']))
                self.tx_param_fit_rate.setText(str(self.fit_param['fit_iter_learning_rate']))

                self.tx_param_threshold_thick.setText(str(self.fit_param['fit_mask_thickness_threshold']))
                self.tx_param_threshold_error.setText(str(self.fit_param['fit_mask_cost_threshold']))

                mask_xanes_flag = self.fit_param['mask_xanes_flag']
                if mask_xanes_flag:
                    n_comp = self.fit_param['n_comp']
                else:
                    n_comp = 0
                self.tx_param_smart_mask_comp.setText(str(n_comp))

                if self.fit_param['norm_edge_method'] == 'new':
                    self.chkbox_param_fit_edge_method.setChecked(1)
                else:
                    self.chkbox_param_fit_edge_method.setChecked(0)

                if self.fit_param['norm_txm_flag']:
                    self.rd_param_txm_norm_yes.setChecked(1)
                else:
                    self.rd_param_txm_norm_no.setChecked(1)

                # edge normalization
                if self.fit_param['norm_edge_flag'] == 1:
                    self.rd_param_fit_edge_yes.setChecked(1)
                else:
                    self.rd_param_fit_edge_no.setChecked(1)
                try:
                    pre_edge_s, pre_edge_e = self.fit_param['pre_edge']
                    self.tx_param_pre_s.setText(f'{pre_edge_s:2.4f}')
                    self.tx_param_pre_e.setText(f'{pre_edge_e:2.4f}')
                except Exception as err:
                    print(err)
                    #self.rd_param_fit_edge_no.setChecked(1)
                    #self.fit_param['fit_pre_edge_flag'] = 0

                try:
                    post_edge_s, post_edge_e = self.fit_param['post_edge']
                    self.tx_param_post_s.setText(f'{post_edge_s:2.4f}')
                    self.tx_param_post_e.setText(f'{post_edge_e:2.4f}')
                    #self.rd_param_fit_edge_yes.setChecked(1)
                    #self.chkbox_fit_post_edge.setChecked(0)
                except Exception as err:
                    print(err)
                    #self.rd_param_fit_edge_no.setChecked(1)
                    #self.fit_param['fit_post_edge_flag'] = 0

                regulation_flag = self.fit_param['regulation_flag']
                if regulation_flag:
                    self.rd_param_reg_edge_yes.setChecked(1)
                    peak_max = self.fit_param['regulation_designed_max']
                    self.tx_param_reg_peak.setText(f'{peak_max:2.4f}')

                    peak_width = self.fit_param['regulation_gamma']
                    self.tx_param_reg_gamma.text()
                    self.tx_param_reg_gamma.setText(f'{peak_width:2.4f}')
                else:
                    self.rd_param_reg_edge_no.setChecked(1)

                num_cpu = int(self.fit_param['num_cpu'])
                self.tx_param_cpu.setText(str(num_cpu))

                if self.fit_param['file_type'] == 'tiff':
                    self.rd_3D_tif.setChecked(1)
                elif self.fit_param['file_type'] == 'h5':
                    self.rd_3D_hdf.setChecked(1)
                    self.tx_param_hdf.setText(str(self.fit_param['hdf_attr']))
                else:
                    print('un-recongnized file type')

                self.tx_param_color.setText(self.fit_param['color'])
        except Exception as err:
            print(err)
            self.load_fit_param_successful = 0

    def run_3D_command(self):
        stdouterr = os.popen4(self.batch_fitting())[1].read()
        self.self.lb_execute_output.setText(stdouterr)


    def test_single_fitting(self):
        try:
            txt = ''
            self.lb_execute_output.setText('Fitting is running, check terminal for progress ...')
            self.pb_param_test_fit.setEnabled(False)
            QApplication.processEvents()
            if self.load_eng_successful and self.load_file_successful and self.load_reference_successful:
                self.collect_3D_fit_param()
                fit_param = self.fit_param
                xanes_eng = self.eng
                file_path = self.file_path
                file_type = self.file_type
                file_prefix = self.file_prefix
                spectrum_ref = self.spectrum_ref
                try:
                    num_cpu = int(self.tx_param_cpu.text())
                except Exception:
                    num_cpu = self.fit_param['num_cpu']
            else:
                txt = ''
                if not self.load_eng_successful:
                    txt += 'Fail to load x-ray energy;      '
                if not self.load_file_successful:
                    txt += 'Fail to load xanes files;       '
                if not self.load_reference_successful:
                    txt += 'Fail to load refernece spectrum;    '
                self.lb_execute_output.setText(txt)
                QApplication.processEvents()
                return print(txt)

            file_save_path = f'{file_path}/fitted_single_xanes'
            pyxas.create_directory(file_save_path)
            thresh_thick = fit_param['fit_mask_thickness_threshold']  # thickness < thick_thresh will be 0
            thresh_cost = fit_param['fit_mask_cost_threshold']

            files_scan = pyxas.retrieve_file_type(file_path, file_prefix=file_prefix, file_type=file_type)
            n = len(files_scan)
            idx = int(self.tx_param_test_fit.text())
            if idx >= n:
                txt = f'"File id" should in the range of (0, n-1) '

                return 0
            else:
                fn = files_scan[idx].split('/')[-1].split('.')[0]
                try:
                    sli_id = int(fn.split('_')[-1])
                except:
                    sli_id = idx
                #file_save_path = f'{file_path}/fitted_single_xanes/xanes_{sli_id:04d}'
                file_save_path = f'{file_path}/fitted_single_xanes/xanes_{fn}'
                pyxas.create_directory(file_save_path)
                '''
                res = pyxas.fit_2D_xanes_single_file(files_scan[idx], xanes_eng,
                                                     fit_param, spectrum_ref, file_save_path)
                '''
                pyxas.fit_2D_xanes_single_file(files_scan[idx], xanes_eng,
                                               fit_param, spectrum_ref, file_save_path)
            txt = 'Single file fitting finished'
            #file_jpg_save = f'{file_save_path}/fig_{sli_id:04d}.jpg'
            file_jpg_save = f'{file_save_path}/fig_{fn}.jpg'
            plt.show()
            #pyxas.plot_fitting_results(res, fit_param['color'], file_jpg_save, display_flag=1, save_flag=1)
        except Exception as err:
            txt = str(err)
        finally:
            print(txt)
            self.lb_execute_output.setText(txt)
            self.pb_param_test_fit.setEnabled(True)
            QApplication.processEvents()


    def batch_fitting(self):
        try:
            txt = ''
            self.lb_execute_output.setText('Fitting is running, check terminal for progress ...')
            QApplication.processEvents()
            if self.load_eng_successful and self.load_file_successful and self.load_reference_successful:
                self.collect_3D_fit_param()
                fit_param = self.fit_param
                xanes_eng = self.eng
                file_path = self.file_path
                file_type = self.file_type
                file_prefix = self.file_prefix
                spectrum_ref = self.spectrum_ref
                try:
                    num_cpu = int(self.tx_param_cpu.text())
                    self.fit_param['num_cpu'] = num_cpu
                except Exception:
                    pass
                finally:
                    print(f'fit using {num_cpu} CPU')
            else:
                txt = ''
                if not self.load_eng_successful:
                    txt += 'Fail to load x-ray energy;      '
                if not self.load_file_successful:
                    txt += 'Fail to load xanes files;       '
                if not self.load_reference_successful:
                    txt += 'Fail to load refernece spectrum;    '
                self.lb_execute_output.setText(txt)
                QApplication.processEvents()
                return print(txt)
            pyxas.fit_2D_xanes_file_mpi(file_path, file_prefix, fit_param, xanes_eng, spectrum_ref)
            txt = 'fitting finished'
        except Exception as err:
            txt = str(err)
            print(err)
        finally:
            self.lb_execute_output.setText(txt)
            QApplication.processEvents()


    def show_3D_h5_attr(self):
        item = self.lst_3D_tomo.selectedItems()
        if len(item):
            fn_sub = item[0].text()
            fn = self.tomo_file['file_path'] + '/' + fn_sub
            file_type = self.tomo_file['file_type']
            if 'h5' in file_type:
                f = h5py.File(fn, 'r')
                k = list(f.keys())
                txt = ', '.join(t for t in k)
                self.lb_3D_h5_attr.setText(txt)


    def plot_3D_tomo(self):
        try:
            item = self.lst_3D_tomo.selectedItems()
            if len(item):
                fn_sub = item[0].text()
                fn = self.tomo_file['file_path'] + '/' + fn_sub
                file_type = self.tomo_file['file_type']
                if 'h5' in file_type:
                    hdf_att = self.tx_3D_h5_attr.text()
                    f = h5py.File(fn, 'r')
                    self.lb_3D_prep_msg.setText('loading image data ...')
                    img = np.array(f[hdf_att])
                    self.lb_3D_prep_msg.setText('loading finished')
                    f.close()
                elif 'tif' in file_type:
                    img = pyxas.get_img_from_tif_file(fn)
                s = img.shape
                circle_mask_ratio = np.float32(self.tx_3D_mask.text())
                if circle_mask_ratio < 1:
                    img = pyxas.circ_mask(img, axis=0, ratio=circle_mask_ratio)

                if self.chkbox_napari.isChecked():
                    try:
                        import napari
                        print('view in napari')
                        napari.view_image(img)
                    except Exception:
                        self.slider_handler = pyxas.plot3D(img)
                        #plt.figure(f'circle_mask_ratio = {circle_mask_ratio}')
                        #plt.imshow(img[s[0]//2])
                        #plt.show()
                        #QApplication.processEvents()
                        print('view in matplotlib')
                else:
                    self.slider_handler = pyxas.plot3D(img)

                '''
                plt.figure(f'circle_mask_ratio = {circle_mask_ratio}')
                plt.imshow(img[s[0] // 2])
                plt.show()
                QApplication.processEvents()
                print('view in matplotlib')
                '''

        except Exception as err:
            print(err)


    def load_3D_tomo_file(self, type='raw'):
        if type == 'raw':
            file_prefix = self.tx_3D_prefix.text()
        elif type == 'align':
            file_prefix = self.tx_3D_assemble_prefix.text()
        else:
            file_prefix = ''
        self.tomo_file = {}

        self.lst_3D_tomo.clear()
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = '*.*'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            fn_tmp = fn.split('/')
            self.tomo_file['file_path'] = '/'.join(t for t in fn_tmp[:-1])
            tmp_prefix = fn_tmp[-1][0]
            if not (tmp_prefix in file_prefix):
                self.tomo_file['file_prefix'] = fn_tmp[-1][0]
            else:
                self.tomo_file['file_prefix'] = file_prefix
            self.tomo_file['file_type'] = '.' + fn_tmp[-1].split('.')[-1]
            self.tomo_file['files'] = pyxas.retrieve_file_type(self.tomo_file['file_path'],
                                                               self.tomo_file['file_prefix'],
                                                               self.tomo_file['file_type'])
            num = len(self.tomo_file['files'])
            self.lb_3D_prep_msg.setText(f'Totally {num} files loaded')
            for i in range(num):
                tmp = self.tomo_file['files'][i].split('/')[-1]
                self.lst_3D_tomo.addItem(tmp)

    def align_3D_tomo_file(self):
        try:
            self.pb_align_tomo_file.setText('Aligning ...')
            self.lb_3D_prep_msg.setText('Aligning ...    check terminal output for progress.')
            QApplication.processEvents()
            ref_index = int(self.tx_3D_ref_index.text())
            binning = int(self.tx_3D_bin.text())
            circle_mask_ratio = float(self.tx_3D_mask.text())
            align_method = int(self.tx_3D_align_method.text())
            hdf_attr = self.tx_3D_tomo_attr_img.text()
            num_cpu = int(self.tx_3D_tomo_cpu.text())
            if num_cpu == 1:
                pyxas.align_3D_tomo_folder(file_path = self.tomo_file['file_path'],
                                         ref_index = ref_index,
                                         binning = binning,
                                         circle_mask_ratio = circle_mask_ratio,
                                         file_prefix = self.tomo_file['file_prefix'],
                                         file_type = self.tomo_file['file_type'],
                                         align_coarse = 1,
                                         align_method = align_method,
                                         hdf_attr = hdf_attr
                                         )
            else:
                pyxas.align_3D_tomo_folder_mpi(file_path=self.tomo_file['file_path'],
                                         ref_index=ref_index,
                                         binning=binning,
                                         circle_mask_ratio=circle_mask_ratio,
                                         file_prefix=self.tomo_file['file_prefix'],
                                         file_type=self.tomo_file['file_type'],
                                         align_coarse=1,
                                         align_method=align_method,
                                         hdf_attr=hdf_attr,
                                         num_cpu=num_cpu)
        except Exception as err:
            print(err)
            self.lb_3D_prep_msg.setText(f'{str(err)}')
        finally:
            self.pb_align_tomo_file.setText('Align tomo files')
            self.lb_3D_prep_msg.setText('Align finished')
            QApplication.processEvents()

    def align_3D_tomo_file_single(self):
        try:
            self.pb_align_tomo_single.setText('Aligning ...')
            self.lb_3D_prep_msg.setText('Aligning ...    check terminal output for progress.')
            QApplication.processEvents()

            fn_ref_sub = self.tx_sel_ref.text()
            fn_align_sub = self.tx_sel_align.text()

            fn_ref = self.tomo_file['file_path'] + '/' + fn_ref_sub
            fn_align = self.tomo_file['file_path'] + '/' + fn_align_sub

            binning = int(self.tx_3D_bin.text())
            circle_mask_ratio = float(self.tx_3D_mask.text())
            align_method = int(self.tx_3D_align_method.text())
            hdf_attr = self.tx_3D_tomo_attr_img.text()

            pyxas.align_3D_tomo_file_specific(file_save_path=self.tomo_file['file_path'],
                                              files_recon=[fn_align],
                                              files_ref=fn_ref,
                                              binning=binning,
                                              circle_mask_ratio=circle_mask_ratio,
                                              align_coarse=1,
                                              align_method=align_method,
                                              hdf_attr=hdf_attr)
        except Exception as err:
            print(err)
            self.lb_3D_prep_msg.setText(f'{str(err)}')
        finally:
            self.pb_align_tomo_single.setText('Align single file')
            self.lb_3D_prep_msg.setText('Align finished')
            QApplication.processEvents()


    def select_3D_ref_file(self):
        item = self.lst_3D_tomo.selectedItems()
        if len(item):
            fn_sub = item[0].text()
            self.tx_sel_ref.setText(fn_sub)


    def select_3D_align_file(self):
        item = self.lst_3D_tomo.selectedItems()
        if len(item):
            fn_sub = item[0].text()
            self.tx_sel_align.setText(fn_sub)


    def assemble_3D_xanes(self):
        attr_img = self.tx_3D_attr_img.text()
        try:
            sli = eval(self.tx_3D_assemble_sli.text())
        except Exception:
            sli = []
        align_flag = self.tx_3D_assemble_ali_flag.text()
        if 'F' in align_flag:
            align_flag = False
            self.tx_3D_assemble_ali_flag.setText('False')
        else:
            align_flag = True
            self.tx_3D_assemble_ali_flag.setText('True')
        QApplication.processEvents()
        #align_flag = eval(self.tx_3D_assemble_ali_flag.text())
        align_ref_index = int(self.tx_3D_assemble_ali_ref.text())
        align_roi_ratio = float(self.tx_3D_assemble_mask.text())
        if self.rd_3D_ali_method_translation.isChecked():
            align_method = 'translation'
        elif self.rd_3D_ali_method_rigid.isChecked():
            align_method = 'rigid'
        else:
            align_method = 'scaled rotation'

        num_cpu = int(self.tx_3D_assemble_cpu.text())
        roi_r_s = int(self.tx_3D_ali_roi_rs.text())
        roi_r_e = int(self.tx_3D_ali_roi_re.text())
        roi_c_s = int(self.tx_3D_ali_roi_cs.text())
        roi_c_e = int(self.tx_3D_ali_roi_ce.text())
        roi = [roi_r_s, roi_r_e, roi_c_s, roi_c_e]

        try:
            file_path = self.tomo_file['file_path']
            file_prefix = self.tomo_file['file_prefix']
            file_type = self.tomo_file['file_type']
            fn_tmp = pyxas.retrieve_file_type(file_path, file_prefix, file_type)[0]
            if 'tif' in file_type:
                img_tmp = pyxas.get_img_from_tif_file(fn_tmp)
                s1, s2, s3 = img_tmp.shape
            elif 'h5' in file_type:
                attr_img = attr_img
                f = h5py.File(fn_tmp, 'r')
                tmp = f[attr_img]
                s1 = len(tmp)
                s2, s3 = tmp[0].shape
                f.close()
            else:
                s1, s2, s3 = 0, 0, 0
            if not len(sli):
                sli = [0, s1]
            self.pb_3D_assemble.setEnabled(False)
            self.pb_3D_assemble.setText('Assembling ...')
            self.lb_3D_prep_msg.setText(f'assembling slice from {sli[0]} to {sli[1]} ...   Check terminal output for progress')
            QApplication.processEvents()
            pyxas.assemble_xanes_slice_from_tomo_mpi(file_path = file_path,
                                                     file_prefix = file_prefix,
                                                     file_type = file_type,
                                                     attr_img = attr_img,
                                                     sli = sli,
                                                     align_flag = align_flag,
                                                     align_ref_index = align_ref_index,
                                                     align_roi_ratio = align_roi_ratio,
                                                     roi = roi,
                                                     ali_sli = [],
                                                     align_algorithm = 'stackreg',
                                                     align_method = align_method,
                                                     flag_save_2d_xanes = 1,
                                                     flag_mask = 0,
                                                     num_cpu = num_cpu)
        except Exception as err:
            print(err)
            msg = str(err)
            self.lb_3D_prep_msg.setText(msg)
        finally:
            self.pb_3D_assemble.setText('Assemble XANES')
            self.pb_3D_assemble.setEnabled(True)
            self.lb_3D_prep_msg.setText(f'Assembling finished. Files are saved to {file_path}/xanes_assemble')
            QApplication.processEvents()


    def select_3D_batch_fitting_method(self):
        if self.rd_batch_fit_edge_norm.isChecked():
            self.enable_3D_fit_param(True)
        else:
            self.enable_3D_fit_param(False)


    def seg_select_all(self):
        self.lst_3D_tomo.setSelectionMode(QAbstractItemView.MultiSelection)
        self.lst_3D_tomo.selectAll()

    def seg_unselect_all(self):
        self.lst_3D_tomo.clearSelection()
        self.lst_3D_tomo.setSelectionMode(QAbstractItemView.SingleSelection)

    def seg_seg(self):
        try:
            fn_all = self.tomo_file['files']
            file_type = self.tomo_file['file_type']
            file_path_root = self.tomo_file['file_path']
            file_save_root = file_path_root + '/label'
            pyxas.mk_directory(file_save_root)
            gf = int(self.tx_seg_gf.text())
            fs = int(self.tx_seg_fs.text())
            bin = int(self.tx_seg_bin.text())
            dis = int(self.tx_seg_dis.text())

            self.pb_seg_go.setEnabled(False)
            items = self.lst_3D_tomo.selectedItems()
            n = len(items)
            for i in range(n):
                self.pb_seg_go.setText(f'segment {i+1}/{n}')
                QApplication.processEvents()
                fn = items[i].text()
                fn_short = fn.split('.')[0]
                flag_exist = False
                fn_idx = -1
                for j in range(len(fn_all)):
                    if fn in fn_all[j]:
                        flag_exist = True
                        fn_idx = j
                        break
                if flag_exist:
                    fn_full = fn_all[fn_idx]
                    if 'tif' in file_type:
                        image = io.imread(fn_full)
                    elif 'h5' in file_type:
                        attr = self.tx_3D_attr_img.text()
                        with h5py.File(fn_full, 'r') as f:
                            image = np.array(f[attr])
                    lb, bw = pyxas.watershed_mask(image,
                                            binning=bin,
                                            gf_size=gf,
                                            fs=fs,
                                            min_distance=dis)
                    fn_save = file_save_root + f'/label_{fn_short}.tiff'
                    io.imsave(fn_save, lb.astype(np.float32))
                    self.lb_3D_prep_msg.setText(f'save file to: {fn_save}')
                    QApplication.processEvents()
        except Exception as err:
            print(err)
        finally:
            self.pb_seg_go.setText('Segment')
            self.pb_seg_go.setEnabled(True)


    def extract_open_label(self):
        self.label_file = {}

        self.lst_3D_tomo2.clear()
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = '*.*'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            fn_tmp = fn.split('/')
            self.label_file['file_path'] = '/'.join(t for t in fn_tmp[:-1])
            tmp_prefix = fn_tmp[-1][0:3]
            self.label_file['file_prefix'] = fn_tmp[-1][0]
            self.label_file['file_type'] = '.' + fn_tmp[-1].split('.')[-1]
            self.label_file['files'] = pyxas.retrieve_file_type(self.label_file['file_path'],
                                                               self.label_file['file_prefix'],
                                                               self.label_file['file_type'])
            num = len(self.label_file['files'])
            self.lb_3D_prep_msg.setText(f'Totally {num} files loaded')
            for i in range(num):
                tmp = self.label_file['files'][i].split('/')[-1]
                self.lst_3D_tomo2.addItem(tmp)


    def extract_open_tomo(self):
        self.load_3D_tomo_file('raw')

    def extract_open_slice(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = '*.*'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            self.tx_extr_open_fn_slice.setText(fn)


    def extract_view_slice(self):
        try:
            fn_sli = self.tx_extr_open_fn_slice.text()
            img = io.imread(fn_sli)
            self.slider_handler = pyxas.plot3D(img)
        except Exception as err:
            print(err)


    def extract_particle(self):
        try:
            self.pb_extr_extr.setEnabled(False)

            fn_sli = self.tx_extr_open_fn_slice.text()
            row = int(self.tx_extr_row.text())
            col = int(self.tx_extr_col.text())
            dilation_iter = int(self.tx_extr_dilation_iter.text())
            ms = int(self.tx_extr_sz.text())
            save_prefix = self.tx_extr_save_prefix.text()

            img_sli = io.imread(fn_sli)
            val = img_sli[:, row, col]

            file_label = self.label_file['files']
            file_tomo = self.tomo_file['files']
            type_tomo = self.tomo_file['file_type']
            root_path = self.tomo_file['file_path']
            root_save_path = root_path + '/' + save_prefix
            pyxas.mk_directory(root_save_path)

            n1 = len(file_label)
            n = len(file_tomo)
            assert n1==n, "number of tomo-files ({n}) not equal to  number of label-files ({n1})"

            for i in trange(n):
                self.pb_extr_extr.setText(f'Extracting {i+1}/{n}')
                QApplication.processEvents()
                fn_tomo = file_tomo[i]
                fn_label = file_label[i]
                if 'h5' in type_tomo:
                    with h5py.File(fn_tomo, 'r') as hf:
                        img = np.array(hf['img'])
                else:
                    img = io.imread(fn_tomo)
                img[np.isnan(img)] = 0
                img_label = io.imread(fn_label)
                mask_img = pyxas.match_img_label(img, img_label, val[i], ms=ms, dilation_iter=dilation_iter)
                fsave = root_save_path + f'/{save_prefix}_{i:04d}.tiff'
                io.imsave(fsave, mask_img.astype(np.float32))
            self.lb_3D_prep_msg.setText('Particle extraction finished')
        except Exception as err:
            self.lb_3D_prep_msg.setText(str(err))
            print(err)
        finally:
            self.pb_extr_extr.setEnabled(True)
            self.pb_extr_extr.setText('Extract')



    def enable_3D_fit_param(self, edge_norm_flag):
        flag = edge_norm_flag
        self.tx_param_cpu.setEnabled(flag)
        # TXM -log()
        self.rd_param_txm_norm_yes.setEnabled(True)
        self.rd_param_txm_norm_no.setEnabled(True)
        # edge normalization
        self.chkbox_param_fit_edge_method.setEnabled(flag)
        self.rd_param_fit_edge_yes.setEnabled(flag)
        self.rd_param_fit_edge_no.setEnabled(flag)
        self.tx_param_pre_s.setEnabled(flag)
        self.tx_param_pre_e.setEnabled(flag)
        self.tx_param_post_s.setEnabled(flag)
        self.tx_param_post_e.setEnabled(flag)
        # peak regularization
        self.rd_param_reg_edge_yes.setEnabled(flag)
        self.rd_param_reg_edge_no.setEnabled(flag)
        self.tx_param_reg_peak.setEnabled(flag)
        self.tx_param_reg_gamma.setEnabled(flag)
        # alignment
        self.rd_param_align_yes.setEnabled(True)
        self.rd_param_align_no.setEnabled(True)
        self.tx_param_align_ref.setEnabled(True)
        self.tx_param_align_roi.setEnabled(True)
        # cluster mask
        self.tx_param_smart_mask_comp.setEnabled(flag)
        self.tx_param_threshold_thick.setEnabled(flag)
        self.tx_param_threshold_error.setEnabled(flag)
        # xanes fitting
        self.chkbox_fit_pre_edge.setEnabled(flag)
        self.chkbox_fit_post_edge.setEnabled(flag)
        self.tx_param_fit_range_s.setEnabled(True)
        self.tx_param_fit_range_e.setEnabled(True)
        #self.rd_param_fit_iter_yes.setEnabled(flag)
        #self.rd_param_fit_iter_no.setEnabled(flag)
        self.chkbox_fit_iter.setEnabled(flag)
        self.tx_param_iter_rate.setEnabled(flag)
        self.tx_param_iter_num.setEnabled(flag)
        self.tx_param_iter_bounds_low.setEnabled(flag)
        self.tx_param_iter_bounds_high.setEnabled(flag)
        self.tx_param_iter_lambda.setEnabled(flag)
        # cluster mask
        self.tx_param_smart_mask_comp.setEnabled(flag)
        self.tx_param_threshold_thick.setEnabled(True)
        self.tx_param_threshold_error.setEnabled(True)
        #colormix
        self.tx_param_color.setEnabled(True)


    def find_3D_peak_image_poly(self):
        if not self.load_eng_successful:
            msg = 'XANES energy not loaded'
            print(msg)
            self.lb_3D_msg.setText(msg)
            return 0
        if self.load_file_successful:
            fit_max = 1
            try:
                xanes_eng = self.eng
            except Exception:
                xanes_eng = []

            file_path = self.file_path
            file_type = self.file_type
            file_prefix = self.file_prefix
            hdf_attr = self.tx_param_hdf.text()
            file_save_peak_fit_pos = f'{file_path}/peak_fit_pos'
            file_save_peak_fit_err = f'{file_path}/peak_fit_error'
            file_save_peak_fit_val = f'{file_path}/peak_fit_height'
            file_save_peak_fit_th_mask = f'{file_path}/threshold_mask'

            pyxas.create_directory(file_save_peak_fit_pos)
            pyxas.create_directory(file_save_peak_fit_err)
            pyxas.create_directory(file_save_peak_fit_val)

            if self.rd_3D_peak_max.isChecked():
                fit_max = 1
            if self.rd_3D_peak_min.isChecked():
                fit_max = -1
            try:
                xs = float(self.tx_3D_edge_s.text())
                xe = float(self.tx_3D_edge_e.text())
                eng_range = [xs, xe]
            except Exception:
                eng_range = []
            fs = pyxas.retrieve_file_type(file_path,
                                          file_prefix=file_prefix,
                                          file_type=file_type)
            file_suffix = fs[0].split('.')[-1]
            fit_order = int(self.tx_3D_edge_order.text())
            scale = float(self.tx_3D_scale_img.text())
            try:
                self.collect_3D_fit_param()
                fit_param = self.fit_param
                for i in range(len(fs)):
                    fn = fs[i]
                    fn_save = fn.split('/')[-1].split('.')[0]
                    print(f'processing {fn}')
                    self.pb_3D_find_peak_img.setText(f'processing {i + 1}/{len(fs)} ... ')
                    QApplication.processEvents()
                    if 'tif' in file_suffix:  # tiff file
                        img_xanes = pyxas.get_img_from_tif_file(fn)
                    else:  # h5 file
                        img_xanes = pyxas.get_img_from_hdf_file(fn, hdf_attr)[hdf_attr]
                    img_xanes *= scale * fit_max
                    if len(xanes_eng) != len(img_xanes):
                        print('number of energy does not match image shape')
                        self.msg = 'number of energy does not match image shape'
                        self.update_msg()
                    time_s = time.time()
                    img_xanes = pyxas.check_if_need_align(img_xanes, fit_param)
                    xanes_eng, img_xanes = pyxas.check_eng_image_order(xanes_eng, img_xanes)
                    peak_pos, peak_val, fit_error = pyxas.fit_peak_2D_xanes_poly(img_xanes, xanes_eng,
                                                                 eng_range, fit_order, fit_max)

                    time_e = time.time()
                    print(f'fitting using {time_e - time_s:5.1f} sec\n')
                    fn_save_pos = f'{file_save_peak_fit_pos}/{fn_save}_peak_pos.tiff'
                    fn_save_err = f'{file_save_peak_fit_err}/{fn_save}_fit_error.tiff'
                    fn_save_val = f'{file_save_peak_fit_val}/{fn_save}_peak_val.tiff'

                    io.imsave(fn_save_pos, peak_pos.astype(np.float32))
                    io.imsave(fn_save_err, fit_error.astype(np.float32))
                    io.imsave(fn_save_val, peak_val.astype(np.float32))

                    if self.chkbox_3D_gen_th_mask.isChecked():
                        pyxas.create_directory(file_save_peak_fit_th_mask)
                        fn_save_th_mask = f'{file_save_peak_fit_th_mask}/{fn_save}_threshold_mask.tiff'
                        thresh_thick = float(self.tx_param_threshold_thick.text())
                        thresh_cost = float(self.tx_param_threshold_error.text())
                        mask = pyxas.fit_xanes2D_generate_mask(peak_val, fit_error,
                                                         thresh_cost=thresh_cost,
                                                         thresh_thick=thresh_thick)
                        io.imsave(fn_save_th_mask, mask.astype(np.float32))
            except Exception as err:
                msg = str(err)
                print(msg)
                self.lb_3D_msg.setText(msg)
                return 0
            self.pb_3D_find_peak_img.setText('Find peak')
            msg = 'Find peak finished'
            print(msg)
            self.lb_3D_msg.setText(msg)
        else:
            msg = 'Fails to load files. Need to press "Load" first'
            print(msg)
            self.lb_3D_msg.setText(msg)


    def gen_3D_smart_mask(self):
        mask_comp = int(self.tx_param_smart_mask_comp.text())
        if self.load_file_successful and mask_comp:
            # generate saving folder
            fs = {}
            file_path = self.file_path
            for i in range(mask_comp):
                fs[str(i)] = f'{file_path}/cluster_mask/mask_{i}'
                pyxas.create_directory(fs[str(i)])

            fit_max = 1
            try:
                xanes_eng = self.eng
            except Exception as err:
                print(err)
                xanes_eng = []
            file_path = self.file_path
            file_type = self.file_type
            file_prefix = self.file_prefix
            hdf_attr = self.tx_param_hdf.text()

            if self.rd_3D_peak_max.isChecked():
                fit_max = 1
            if self.rd_3D_peak_min.isChecked():
                fit_max = -1
            try:
                xs = float(self.tx_3D_edge_s.text())
                xe = float(self.tx_3D_edge_e.text())
                xs_id = pyxas.find_nearest(xanes_eng, xs)
                xe_id = pyxas.find_nearest(xanes_eng, xe)
            except Exception as err:
                print(err)
                xs_id, xe_id = 0, -1
            files = pyxas.retrieve_file_type(file_path,
                                          file_prefix=file_prefix,
                                          file_type=file_type)
            file_suffix = files[0].split('.')[-1]
            scale = float(self.tx_3D_scale_img.text())

            align_flag = 1 if self.rd_param_align_yes.isChecked() else 0
            align_ref_index = int(self.tx_param_align_ref.text())

            time_s = time.time()
            try:
                for i in range(len(files)):
                    msg = ''
                    fn = files[i]
                    fn_save = fn.split('/')[-1].split('.')
                    fn_save ='.'.join(i for i in fn_save[:-1])
                    msg = f'processing {i + 1}/{len(files)} ... '
                    print(f'processing {fn}')
                    self.pb_3D_gen_cl_mask.setText(msg)
                    QApplication.processEvents()
                    if 'tif' in file_suffix:  # tiff file
                        img_xanes = pyxas.get_img_from_tif_file(fn)
                    else:  # h5 file
                        img_xanes = pyxas.get_img_from_hdf_file(fn, hdf_attr)[hdf_attr]
                    img_xanes *= scale * fit_max
                    img_xanes = img_xanes[xs_id:xe_id]
                    if align_flag:
                        image_xanes = pyxas.align_img_stack_stackreg2_mpi(img_xanes, align_ref_index, img_xanes, 4)
                    smart_mask, img_labels = pyxas.kmean_mask(img_xanes * scale, mask_comp)
                    for j in range(mask_comp):
                        fn_save_mask = f'{fs[str(j)]}/{fn_save}_cmask_{j}.tiff'
                        io.imsave(fn_save_mask, smart_mask[j].astype(np.float32))
                    time_e = time.time()
                    msg = f'processed {i + 1}/{len(files)}. Taking {time_e-time_s:3.1f} sec up to now'
                    self.lb_3D_msg.setText(msg)
                    QApplication.processEvents()
                    print(msg)
                msg = f'All slices finished. Files are saved to {file_path}/cluster_mask'
                self.lb_3D_msg.setText(msg)
                QApplication.processEvents()
                print(msg)
            except Exception as err:
                print(err)
                self.lb_3D_msg.setText(str(err))
                QApplication.processEvents()
        else:
            msg = 'Failed :(    Need to load file first and make sure "Cluster Mask comp" > 0'
            self.lb_3D_msg.setText(msg)
            print(msg)
        self.pb_3D_gen_cl_mask.setText('Gen. cluster mask')

    def layout_ml(self):
        tab1 = QWidget()
        tab1.setLayout(self.layout_ml_denoise())

        tabs = QTabWidget()
        tabs.addTab(tab1, 'TXM-XANES Denoise')

        layout = QVBoxLayout()
        layout.addWidget(tabs)
        layout.addStretch()

        return layout


    def layout_ml_denoise_load_model(self):
        lb_space = QLabel()
        lb_space.setFixedWidth(30)

        # load model
        lb_model = QLabel()
        lb_model.setText('Model path:')
        lb_model.setFont(self.font2)
        lb_model.setFixedWidth(120)

        self.tx_ml_model_path = QLineEdit()
        self.tx_ml_model_path.setFixedWidth(600)
        self.tx_ml_model_path.setFont(self.font2)
        #self.ml_load_model_path(self.ml_model_path)

        self.pb_ml_model_open = QPushButton('Open')
        self.pb_ml_model_open.setFixedWidth(80)
        self.pb_ml_model_open.setFont(self.font2)
        self.pb_ml_model_open.clicked.connect(self.ml_load_model)

        self.pb_ml_model_open_multi = QPushButton('Open mulitple')
        self.pb_ml_model_open_multi.setFixedWidth(120)
        self.pb_ml_model_open_multi.setFont(self.font2)
        self.pb_ml_model_open_multi.clicked.connect(self.ml_load_model_multiple)

        self.pb_ml_model_open_default = QPushButton('Open default')
        self.pb_ml_model_open_default.setFixedWidth(120)
        self.pb_ml_model_open_default.setFont(self.font2)
        self.pb_ml_model_open_default.clicked.connect(self.ml_load_model_default)

        hbox_path = QHBoxLayout()
        hbox_path.addWidget(lb_model)
        hbox_path.addWidget(self.tx_ml_model_path)
        hbox_path.addWidget(self.pb_ml_model_open)
        hbox_path.addWidget(self.pb_ml_model_open_multi)
        hbox_path.addWidget(self.pb_ml_model_open_default)
        hbox_path.setAlignment(QtCore.Qt.AlignLeft)
        hbox_path.addStretch()
        return hbox_path

    def layout_ml_denoise_load_img(self):
        lb_space = QLabel()
        lb_space.setFixedWidth(10)

        lb_model = QLabel()
        lb_model.setText('Image path:')
        lb_model.setFont(self.font2)
        lb_model.setFixedWidth(120)

        self.tx_ml_img_path = QLineEdit()
        self.tx_ml_img_path.setFixedWidth(600)
        self.tx_ml_img_path.setFont(self.font2)

        self.pb_ml_img_open = QPushButton('Open')
        self.pb_ml_img_open.setFixedWidth(80)
        self.pb_ml_img_open.setFont(self.font2)
        self.pb_ml_img_open.clicked.connect(self.ml_load_img)

        self.lb_ml_msg_img = QLabel()
        self.lb_ml_msg_img.setFont(self.font2)
        self.lb_ml_msg_img.setFixedWidth(200)

        hbox_path = QHBoxLayout()
        hbox_path.addWidget(lb_model)
        hbox_path.addWidget(self.tx_ml_img_path)
        hbox_path.addWidget(self.pb_ml_img_open)
        hbox_path.addWidget(lb_space)
        hbox_path.addWidget(self.lb_ml_msg_img)
        hbox_path.setAlignment(QtCore.Qt.AlignLeft)
        hbox_path.addStretch()

        return hbox_path

    def layout_ml_denoise_load_energy(self):
        lb_space = QLabel()
        lb_space.setFixedWidth(10)

        lb_model = QLabel()
        lb_model.setText('X_Eng path:')
        lb_model.setFont(self.font2)
        lb_model.setFixedWidth(120)

        self.tx_ml_eng_path = QLineEdit()
        self.tx_ml_eng_path.setFixedWidth(600)
        self.tx_ml_eng_path.setFont(self.font2)

        self.pb_ml_eng_open = QPushButton('Open')
        self.pb_ml_eng_open.setFixedWidth(80)
        self.pb_ml_eng_open.setFont(self.font2)
        self.pb_ml_eng_open.clicked.connect(self.ml_load_energy)

        self.lb_ml_msg_eng = QLabel()
        self.lb_ml_msg_eng.setFont(self.font2)
        self.lb_ml_msg_eng.setFixedWidth(240)

        hbox_path = QHBoxLayout()
        hbox_path.addWidget(lb_model)
        hbox_path.addWidget(self.tx_ml_eng_path)
        hbox_path.addWidget(self.pb_ml_eng_open)
        hbox_path.addWidget(lb_space)
        hbox_path.addWidget(self.lb_ml_msg_eng)
        hbox_path.setAlignment(QtCore.Qt.AlignLeft)
        hbox_path.addStretch()

        return hbox_path

    def layout_ml_denoise_crop_img(self):
        lb_space = QLabel()
        lb_space.setFixedWidth(30)

        lb_space1 = QLabel()
        lb_space1.setFixedWidth(35)

        w = 80

        lb_crop = QLabel()
        lb_crop.setText('Crop image:')
        lb_crop.setFont(self.font2)
        lb_crop.setFixedWidth(120)

        lb_crop_cen_x = QLabel()
        lb_crop_cen_x.setText('X center:')
        lb_crop_cen_x.setFont(self.font2)
        lb_crop_cen_x.setFixedWidth(70)

        lb_crop_cen_y = QLabel()
        lb_crop_cen_y.setText('Y center:')
        lb_crop_cen_y.setFont(self.font2)
        lb_crop_cen_y.setFixedWidth(70)

        lb_crop_size_x = QLabel()
        lb_crop_size_x.setText('  X length:')
        lb_crop_size_x.setFont(self.font2)
        lb_crop_size_x.setFixedWidth(70)

        lb_crop_size_y = QLabel()
        lb_crop_size_y.setText('  Y length:')
        lb_crop_size_y.setFont(self.font2)
        lb_crop_size_y.setFixedWidth(70)

        self.tx_ml_crop_cen_x = QLineEdit()
        self.tx_ml_crop_cen_x.setText('0')
        self.tx_ml_crop_cen_x.setFont(self.font2)
        self.tx_ml_crop_cen_x.setFixedWidth(50)

        self.tx_ml_crop_cen_y = QLineEdit()
        self.tx_ml_crop_cen_y.setText('0')
        self.tx_ml_crop_cen_y.setFont(self.font2)
        self.tx_ml_crop_cen_y.setFixedWidth(50)

        self.tx_ml_crop_size_x = QLineEdit()
        self.tx_ml_crop_size_x.setText('0')
        self.tx_ml_crop_size_x.setFont(self.font2)
        self.tx_ml_crop_size_x.setFixedWidth(50)

        self.tx_ml_crop_size_y = QLineEdit()
        self.tx_ml_crop_size_y.setText('0')
        self.tx_ml_crop_size_y.setFont(self.font2)
        self.tx_ml_crop_size_y.setFixedWidth(50)

        self.pb_ml_crop_display = QPushButton('Display')
        self.pb_ml_crop_display.setFont(self.font2)
        self.pb_ml_crop_display.setFixedWidth(w)
        self.pb_ml_crop_display.clicked.connect(lambda:self.crop_roi_display(self.canvas_ml))

        self.pb_ml_crop_exec = QPushButton('Crop image')
        self.pb_ml_crop_exec.setFont(self.font2)
        self.pb_ml_crop_exec.setFixedWidth(120)
        self.pb_ml_crop_exec.clicked.connect(lambda:self.ml_crop_roi(self.canvas_ml))

        lb_ml_device = QLabel()
        lb_ml_device.setText('Device:')
        lb_ml_device.setFont(self.font2)
        lb_ml_device.setFixedWidth(60)

        self.cb_ml_device = QComboBox()
        self.cb_ml_device.setFont(self.font2)
        self.cb_ml_device.setFixedWidth(85)
        if self.gpu_count == 0:
            self.cb_ml_device.addItem('cpu')
        elif self.gpu_count == 1:
            self.cb_ml_device.addItem('cuda')
        else:
            for i in range(self.gpu_count):
                self.cb_ml_device.addItem(f'cuda:{i:d}')

        hbox_crop = QHBoxLayout()
        hbox_crop.addWidget(lb_crop)
        hbox_crop.addWidget(lb_crop_cen_x)
        hbox_crop.addWidget(self.tx_ml_crop_cen_x)
        hbox_crop.addWidget(lb_crop_size_x)
        hbox_crop.addWidget(self.tx_ml_crop_size_x)
        hbox_crop.addWidget(lb_space)
        hbox_crop.addWidget(lb_crop_cen_y)
        hbox_crop.addWidget(self.tx_ml_crop_cen_y)
        hbox_crop.addWidget(lb_crop_size_y)
        hbox_crop.addWidget(self.tx_ml_crop_size_y)
        hbox_crop.addWidget(lb_space1)
        hbox_crop.addWidget(self.pb_ml_crop_display)
        #hbox_crop.addWidget(lb_space)
        hbox_crop.addWidget(self.pb_ml_crop_exec)
        #hbox_crop.addWidget(lb_space)
        hbox_crop.addWidget(lb_ml_device)
        hbox_crop.addWidget(self.cb_ml_device)
        hbox_crop.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        return hbox_crop

    def layout_ml_denoise_function(self):
        lb_empty = QLabel()
        lb_space = QLabel()
        lb_space.setFixedWidth(20)
        layout_apply_model = self.layout_ml_apply_model()
        layout_prod_prep = self.layout_ml_production_prep()
        layout_train_prod = self.layout_ml_train()

        vbox_canvas = self.layout_canvas_ml()

        hbox1 = QHBoxLayout()
        hbox1.addLayout(layout_apply_model)
        hbox1.addWidget(lb_space)
        hbox1.addLayout(layout_prod_prep)
        hbox1.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        hbox1.addStretch()

        vbox = QVBoxLayout()
        #vbox.addLayout(layout_apply_model)
        #vbox.addWidget(lb_empty)
        #vbox.addLayout(layout_prod_prep)
        vbox.addLayout(hbox1)
        vbox.addWidget(lb_empty)
        vbox.addLayout(layout_train_prod)
        vbox.addWidget(lb_empty)
        vbox.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)
        vbox.addStretch()

        hbox = QHBoxLayout()
        hbox.addLayout(vbox)
        hbox.addLayout(vbox_canvas)
        hbox.addWidget(lb_empty)
        hbox.setAlignment(QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft)

        return hbox


    def layout_ml_apply_model(self):
        lb_empty = QLabel()
        lb_space = QLabel()
        lb_space.setFixedWidth(30)

        lb_space1 = QLabel()
        lb_space1.setFixedHeight(10)

        lb_lst_ml_model = QLabel()
        lb_lst_ml_model.setFont(self.font2)
        lb_lst_ml_model.setText('Model list:')
        lb_lst_ml_model.setFixedWidth(80)
        lb_lst_ml_model.setFixedHeight(28)

        self.lst_ml_model = QListWidget()
        self.lst_ml_model.setFont(self.font2)
        #self.lst_ml_model.setSelectionMode(QAbstractItemView.MultiSelection)
        self.lst_ml_model.setFixedWidth(120)
        self.lst_ml_model.setFixedHeight(210)

        self.pb_ml_model_clear = QPushButton('Clear')
        self.pb_ml_model_clear.setFont(self.font2)
        self.pb_ml_model_clear.clicked.connect(self.ml_clear_model)
        self.pb_ml_model_clear.setFixedWidth(120)

        lb_ml_apply = QLabel()
        lb_ml_apply.setText('Apply ML model')
        lb_ml_apply.setFont(self.font1)
        lb_ml_apply.setFixedWidth(150)

        self.pb_ml_apply = QPushButton('Apply to stack')
        self.pb_ml_apply.setFont(self.font2)
        self.pb_ml_apply.setFixedWidth(120)
        self.pb_ml_apply.clicked.connect(self.ml_apply_img)

        self.pb_ml_apply_single = QPushButton('Apply to image')
        self.pb_ml_apply_single.setFont(self.font2)
        self.pb_ml_apply_single.setFixedWidth(120)
        self.pb_ml_apply_single.clicked.connect(self.ml_apply_img_single)

        lb_ml_iter = QLabel('Num. Iter:')
        lb_ml_iter.setFixedWidth(80)
        lb_ml_iter.setFont(self.font2)

        self.tx_ml_iter = QLineEdit()
        self.tx_ml_iter.setText('1')
        self.tx_ml_iter.setFont(self.font2)
        self.tx_ml_iter.setFixedWidth(35)
        self.tx_ml_iter.setValidator(QIntValidator())

        lb_ml_filter_sz = QLabel('filter sz:')
        lb_ml_filter_sz.setFixedWidth(80)
        lb_ml_filter_sz.setFont(self.font2)

        self.tx_ml_filter_sz = QLineEdit()
        self.tx_ml_filter_sz.setText('1')
        self.tx_ml_filter_sz.setFont(self.font2)
        self.tx_ml_filter_sz.setFixedWidth(35)
        self.tx_ml_filter_sz.setValidator(QIntValidator())

        lb_ml_norm_factor = QLabel('Bkg. avg:')
        lb_ml_norm_factor.setFixedWidth(80)
        lb_ml_norm_factor.setFont(self.font2)

        self.tx_ml_norm_factor = QLineEdit()
        self.tx_ml_norm_factor.setText('1.0')
        self.tx_ml_norm_factor.setFont(self.font2)
        self.tx_ml_norm_factor.setFixedWidth(35)
        self.tx_ml_norm_factor.setValidator(QDoubleValidator())

        hbox_iter = QHBoxLayout()
        hbox_iter.addWidget(lb_ml_iter)
        hbox_iter.addWidget(self.tx_ml_iter)
        hbox_iter.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        hbox_iter.addStretch()

        hbox_filter = QHBoxLayout()
        hbox_filter.addWidget(lb_ml_filter_sz)
        hbox_filter.addWidget(self.tx_ml_filter_sz)
        hbox_filter.setAlignment(QtCore.Qt.AlignLeft)
        hbox_filter.addStretch()

        hbox_norm = QHBoxLayout()
        hbox_norm.addWidget(lb_ml_norm_factor)
        hbox_norm.addWidget(self.tx_ml_norm_factor)
        hbox_norm.setAlignment(QtCore.Qt.AlignLeft)
        hbox_norm.addStretch()

        vbox_model = QVBoxLayout()

        vbox_model.addLayout(hbox_iter)
        vbox_model.addLayout(hbox_filter)
        vbox_model.addLayout(hbox_norm)
        vbox_model.addWidget(lb_space1)
        vbox_model.addWidget(self.pb_ml_apply)
        vbox_model.addWidget(self.pb_ml_apply_single)
        vbox_model.addWidget(lb_space1)
        vbox_model.addWidget(self.pb_ml_model_clear)

        vbox_model.addWidget(lb_empty)
        vbox_model.setAlignment(QtCore.Qt.AlignTop)
        #vbox_model.addStretch()

        hbox_model = QHBoxLayout()
        hbox_model.addWidget(self.lst_ml_model)
        hbox_model.addLayout(vbox_model)
        hbox_model.setAlignment(QtCore.Qt.AlignLeft |QtCore.Qt.AlignTop)
        #hbox_model.addStretch()

        vbox_apply = QVBoxLayout()
        vbox_apply.addWidget(lb_ml_apply)
        vbox_apply.addLayout(hbox_model)
        vbox_apply.setAlignment(QtCore.Qt.AlignTop)
        vbox_apply.addStretch()
        '''
        hbox_ass = QHBoxLayout()
        hbox_ass.addLayout(vbox_apply)
        hbox_ass.addWidget(lb_space)
        hbox_ass.addLayout(vbox_canvas)
        hbox_ass.setAlignment(QtCore.Qt.AlignLeft)
        hbox_ass.addStretch()
        return hbox_ass
        '''
        return vbox_apply


    def layout_ml_production_prep(self):
        lb_space1 = QLabel()
        lb_space1.setFixedHeight(10)

        lb_prod = QLabel()
        lb_prod.setFixedWidth(150)
        #lb_prod.setFixedHeight(40)
        lb_prod.setFont(self.font1)
        lb_prod.setText('Prepare training data')

        lb_ml_elem = QLabel('')
        lb_ml_elem.setText('Elem:')
        lb_ml_elem.setFont(self.font2)
        lb_ml_elem.setFixedWidth(80)

        self.tx_ml_elem = QLineEdit()
        self.tx_ml_elem.setFixedWidth(80)
        self.tx_ml_elem.setFont(self.font2)

        lb_ml_edge = QLabel('')
        lb_ml_edge.setText('Excl. Eng:')
        lb_ml_edge.setFont(self.font2)
        lb_ml_edge.setFixedWidth(80)

        self.tx_ml_edge = QLineEdit()
        self.tx_ml_edge.setText('[]')
        self.tx_ml_edge.setFixedWidth(80)
        self.tx_ml_edge.setFont(self.font2)

        lb_ml_num = QLabel()
        lb_ml_num.setText('Num. Img:')
        lb_ml_num.setFont(self.font2)
        lb_ml_num.setFixedWidth(80)

        self.tx_ml_num = QLineEdit()
        self.tx_ml_num.setText('50')
        self.tx_ml_num.setFixedWidth(80)
        self.tx_ml_num.setFont(self.font2)
        self.tx_ml_num.setValidator(QIntValidator())

        ###
        lb_ml_stack_sz = QLabel()
        lb_ml_stack_sz.setText('Stack sz:')
        lb_ml_stack_sz.setFont(self.font2)
        lb_ml_stack_sz.setFixedWidth(80)

        self.tx_ml_stack_sz = QLineEdit()
        self.tx_ml_stack_sz.setText('16')
        self.tx_ml_stack_sz.setFixedWidth(80)
        self.tx_ml_stack_sz.setFont(self.font2)
        self.tx_ml_stack_sz.setValidator(QIntValidator())
        ##


        self.pb_ml_prep = QPushButton('Generate')
        self.pb_ml_prep.setFont(self.font2)
        self.pb_ml_prep.setFixedWidth(120)
        self.pb_ml_prep.clicked.connect(self.ml_prep_prod_dataset)

        self.pb_ml_elem_Ni = QPushButton('Ni')
        self.pb_ml_elem_Ni.setFont(self.font2)
        self.pb_ml_elem_Ni.setFixedWidth(40)
        self.pb_ml_elem_Ni.clicked.connect(lambda:self.ml_gen_elem('Ni'))

        self.pb_ml_elem_Co = QPushButton('Co')
        self.pb_ml_elem_Co.setFont(self.font2)
        self.pb_ml_elem_Co.setFixedWidth(40)
        self.pb_ml_elem_Co.clicked.connect(lambda: self.ml_gen_elem('Co'))

        self.pb_ml_elem_Mn = QPushButton('Mn')
        self.pb_ml_elem_Mn.setFont(self.font2)
        self.pb_ml_elem_Mn.setFixedWidth(40)
        self.pb_ml_elem_Mn.clicked.connect(lambda: self.ml_gen_elem('Mn'))

        hbox_elem = QHBoxLayout()
        hbox_elem.addWidget(lb_ml_elem)
        hbox_elem.addWidget(self.tx_ml_elem)
        hbox_elem.setAlignment(QtCore.Qt.AlignLeft)
        hbox_elem.addStretch()

        hbox_elem_but = QHBoxLayout()
        hbox_elem_but.addWidget(self.pb_ml_elem_Ni)
        hbox_elem_but.addWidget(self.pb_ml_elem_Co)
        hbox_elem_but.addWidget(self.pb_ml_elem_Mn)
        hbox_elem_but.setAlignment(QtCore.Qt.AlignLeft)
        hbox_elem_but.addStretch()

        hbox_num = QHBoxLayout()
        hbox_num.addWidget(lb_ml_num)
        hbox_num.addWidget(self.tx_ml_num)
        hbox_num.setAlignment(QtCore.Qt.AlignLeft)
        hbox_num.addStretch()

        hbox_eng = QHBoxLayout()
        hbox_eng.addWidget(lb_ml_edge)
        hbox_eng.addWidget(self.tx_ml_edge)
        hbox_eng.setAlignment(QtCore.Qt.AlignLeft)
        hbox_eng.addStretch()

        hbox_stack_sz = QHBoxLayout()
        hbox_stack_sz.addWidget(lb_ml_stack_sz)
        hbox_stack_sz.addWidget(self.tx_ml_stack_sz)
        hbox_stack_sz.setAlignment(QtCore.Qt.AlignLeft)
        hbox_stack_sz.addStretch()

        vbox1 = QVBoxLayout()
        vbox1.addWidget(lb_prod)
        vbox1.addLayout(hbox_num)
        vbox1.addLayout(hbox_eng)
        vbox1.addLayout(hbox_stack_sz)

        vbox1.addWidget(lb_space1)
        vbox1.addLayout(hbox_elem)
        vbox1.addLayout(hbox_elem_but)
        vbox1.addWidget(lb_space1)
        vbox1.addWidget(self.pb_ml_prep)
        vbox1.setAlignment(QtCore.Qt.AlignTop)
        vbox1.addStretch()

        return vbox1


    def layout_ml_train(self):
        w_open = 60
        w_dir = 280
        w_l = 85

        lb_ml_train = QLabel()
        lb_ml_train.setText('Train network')
        lb_ml_train.setFont(self.font1)
        lb_ml_train.setFixedWidth(100)
        lb_ml_train.setFixedHeight(40)

        # raw (whole) xanes image stack
        lb_ml_raw_img = QLabel()
        lb_ml_raw_img.setText('Raw XANES:')
        lb_ml_raw_img.setFont(self.font2)
        lb_ml_raw_img.setFixedWidth(w_l)

        self.tx_ml_raw_img = QLineEdit()
        self.tx_ml_raw_img.setFixedWidth(w_dir + w_open + 8)
        self.tx_ml_raw_img.setFont(self.font2)

        hbox_fn_raw = QHBoxLayout()
        hbox_fn_raw.addWidget(lb_ml_raw_img)
        hbox_fn_raw.addWidget(self.tx_ml_raw_img)
        hbox_fn_raw.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_raw.addStretch()

        # fn_root
        lb_fn_root = QLabel()
        lb_fn_root.setText('Root dir.')
        lb_fn_root.setFont(self.font2)
        lb_fn_root.setFixedWidth(w_l)

        self.tx_ml_fn_root = QLineEdit()
        self.tx_ml_fn_root.setFixedWidth(w_dir)
        self.tx_ml_fn_root.setFont(self.font2)

        self.pb_ml_fn_root = QPushButton('Open')
        self.pb_ml_fn_root.setFixedWidth(w_open)
        self.pb_ml_fn_root.setFont(self.font2)
        self.pb_ml_fn_root.clicked.connect(lambda:self.ml_open_directory('root'))

        hbox_fn_root = QHBoxLayout()
        hbox_fn_root.addWidget(lb_fn_root)
        hbox_fn_root.addWidget(self.tx_ml_fn_root)
        hbox_fn_root.addWidget(self.pb_ml_fn_root)
        hbox_fn_root.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_root.addStretch()

        # fn_img_gt
        lb_fn_gt = QLabel()
        lb_fn_gt.setText('GT dir.')
        lb_fn_gt.setFont(self.font2)
        lb_fn_gt.setFixedWidth(w_l)

        self.tx_ml_fn_gt = QLineEdit()
        self.tx_ml_fn_gt.setFixedWidth(w_dir)
        self.tx_ml_fn_gt.setFont(self.font2)

        self.pb_ml_fn_gt = QPushButton('Open')
        self.pb_ml_fn_gt.setFixedWidth(w_open)
        self.pb_ml_fn_gt.setFont(self.font2)
        self.pb_ml_fn_gt.clicked.connect(lambda: self.ml_open_directory('gt'))

        hbox_fn_gt = QHBoxLayout()
        hbox_fn_gt.addWidget(lb_fn_gt)
        hbox_fn_gt.addWidget(self.tx_ml_fn_gt)
        hbox_fn_gt.addWidget(self.pb_ml_fn_gt)
        hbox_fn_gt.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_gt.addStretch()

        # fn_img_blur
        lb_fn_blur = QLabel()
        lb_fn_blur.setText('Blur dir.')
        lb_fn_blur.setFont(self.font2)
        lb_fn_blur.setFixedWidth(w_l)

        self.tx_ml_fn_blur = QLineEdit()
        self.tx_ml_fn_blur.setFixedWidth(w_dir)
        self.tx_ml_fn_blur.setFont(self.font2)

        self.pb_ml_fn_blur = QPushButton('Open')
        self.pb_ml_fn_blur.setFixedWidth(w_open)
        self.pb_ml_fn_blur.setFont(self.font2)
        self.pb_ml_fn_blur.clicked.connect(lambda: self.ml_open_directory('blur'))

        hbox_fn_blur = QHBoxLayout()
        hbox_fn_blur.addWidget(lb_fn_blur)
        hbox_fn_blur.addWidget(self.tx_ml_fn_blur)
        hbox_fn_blur.addWidget(self.pb_ml_fn_blur)
        hbox_fn_blur.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_blur.addStretch()

        # fn_eng_list
        lb_fn_englist = QLabel()
        lb_fn_englist.setText('X-eng dir.')
        lb_fn_englist.setFont(self.font2)
        lb_fn_englist.setFixedWidth(w_l)

        self.tx_ml_fn_englist = QLineEdit()
        self.tx_ml_fn_englist.setFixedWidth(w_dir)
        self.tx_ml_fn_englist.setFont(self.font2)

        self.pb_ml_fn_englist = QPushButton('Open')
        self.pb_ml_fn_englist.setFixedWidth(w_open)
        self.pb_ml_fn_englist.setFont(self.font2)
        self.pb_ml_fn_englist.clicked.connect(lambda: self.ml_open_directory('eng'))

        hbox_fn_englist = QHBoxLayout()
        hbox_fn_englist.addWidget(lb_fn_englist)
        hbox_fn_englist.addWidget(self.tx_ml_fn_englist)
        hbox_fn_englist.addWidget(self.pb_ml_fn_englist)
        hbox_fn_englist.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_englist.addStretch()

        # mask file
        lb_fn_mask = QLabel()
        lb_fn_mask.setText('Mask')
        lb_fn_mask.setFont(self.font2)
        lb_fn_mask.setFixedWidth(w_l)

        self.tx_ml_fn_mask = QLineEdit()
        self.tx_ml_fn_mask.setFixedWidth(w_dir)
        self.tx_ml_fn_mask.setFont(self.font2)

        self.pb_ml_fn_mask = QPushButton('Open')
        self.pb_ml_fn_mask.setFixedWidth(w_open)
        self.pb_ml_fn_mask.setFont(self.font2)
        self.pb_ml_fn_mask.clicked.connect(self.ml_load_mask)

        hbox_fn_mask = QHBoxLayout()
        hbox_fn_mask.addWidget(lb_fn_mask)
        hbox_fn_mask.addWidget(self.tx_ml_fn_mask)
        hbox_fn_mask.addWidget(self.pb_ml_fn_mask)
        hbox_fn_mask.setAlignment(QtCore.Qt.AlignLeft)
        hbox_fn_mask.addStretch()


        # assemble directory
        vbox_dir = QVBoxLayout()
        vbox_dir.addLayout(hbox_fn_raw)
        vbox_dir.addLayout(hbox_fn_root)
        vbox_dir.addLayout(hbox_fn_gt)
        vbox_dir.addLayout(hbox_fn_blur)
        vbox_dir.addLayout(hbox_fn_englist)
        vbox_dir.addLayout(hbox_fn_mask)
        vbox_dir.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        vbox_dir.addStretch()

        # num_train_data
        lb_ml_n_train = QLabel()
        lb_ml_n_train.setText('Num. train data:')
        lb_ml_n_train.setFixedWidth(120)
        lb_ml_n_train.setFont(self.font2)

        self.tx_ml_n_train = QLineEdit()
        self.tx_ml_n_train.setText('20')
        self.tx_ml_n_train.setFont(self.font2)
        self.tx_ml_n_train.setFixedWidth(40)

        # num_epoch
        lb_ml_n_epoch = QLabel()
        lb_ml_n_epoch.setText('Epochs:')
        lb_ml_n_epoch.setFixedWidth(120)
        lb_ml_n_epoch.setFont(self.font2)
        lb_ml_n_epoch.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_ml_n_epoch = QLineEdit()
        self.tx_ml_n_epoch.setText('5')
        self.tx_ml_n_epoch.setFont(self.font2)
        self.tx_ml_n_epoch.setFixedWidth(40)

        hbox_n_train = QHBoxLayout()
        hbox_n_train.addWidget(lb_ml_n_train)
        hbox_n_train.addWidget(self.tx_ml_n_train)
        hbox_n_train.addWidget(lb_ml_n_epoch)
        hbox_n_train.addWidget(self.tx_ml_n_epoch)
        hbox_n_train.setAlignment(QtCore.Qt.AlignLeft)
        hbox_n_train.addStretch()

        # learning rate and tv_ratio
        lb_ml_learn_r = QLabel()
        lb_ml_learn_r.setText('Learning rate:')
        lb_ml_learn_r.setFixedWidth(120)
        lb_ml_learn_r.setFont(self.font2)

        self.tx_ml_learn_r = QLineEdit()
        self.tx_ml_learn_r.setText('2e-5')
        self.tx_ml_learn_r.setFont(self.font2)
        self.tx_ml_learn_r.setFixedWidth(40)

        lb_ml_ratio = QLabel()
        lb_ml_ratio.setText('MSE ratio:')
        lb_ml_ratio.setFixedWidth(120)
        lb_ml_ratio.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
        lb_ml_ratio.setFont(self.font2)

        self.tx_ml_ratio = QLineEdit()
        self.tx_ml_ratio.setText('0.99')
        self.tx_ml_ratio.setFont(self.font2)
        self.tx_ml_ratio.setFixedWidth(40)

        hbox_learn = QHBoxLayout()
        hbox_learn.addWidget(lb_ml_learn_r)
        hbox_learn.addWidget(self.tx_ml_learn_r)
        hbox_learn.addWidget(lb_ml_ratio)
        hbox_learn.addWidget(self.tx_ml_ratio)
        hbox_learn.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignVCenter)
        hbox_learn.addStretch()

        # thickness update rate and loss coef
        self.lb_ml_thick_update = QLabel()
        self.lb_ml_thick_update.setText('Thick update rate:')
        self.lb_ml_thick_update.setFixedWidth(120)
        self.lb_ml_thick_update.setFont(self.font2)

        self.tx_ml_thick_update = QLineEdit()
        self.tx_ml_thick_update.setText('2')
        self.tx_ml_thick_update.setFont(self.font2)
        self.tx_ml_thick_update.setFixedWidth(40)

        lb_ml_loss_ssim = QLabel()
        lb_ml_loss_ssim.setText('Loss SSIM:')
        lb_ml_loss_ssim.setFixedWidth(120)
        lb_ml_loss_ssim.setFont(self.font2)
        lb_ml_loss_ssim.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_ml_loss_ssim = QLineEdit()
        self.tx_ml_loss_ssim.setText('1e-4')
        self.tx_ml_loss_ssim.setFont(self.font2)
        self.tx_ml_loss_ssim.setFixedWidth(40)
        self.tx_ml_loss_ssim.setValidator(QDoubleValidator())

        lb_ml_loss_tv = QLabel()
        lb_ml_loss_tv.setText('TV:')
        lb_ml_loss_tv.setFixedWidth(40)
        lb_ml_loss_tv.setFont(self.font2)
        lb_ml_loss_tv.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)

        self.tx_ml_loss_tv = QLineEdit()
        self.tx_ml_loss_tv.setText('1e-9')
        self.tx_ml_loss_tv.setFont(self.font2)
        self.tx_ml_loss_tv.setFixedWidth(40)
        self.tx_ml_loss_tv.setValidator(QDoubleValidator())

        hbox_thick_update = QHBoxLayout()
        hbox_thick_update.addWidget(self.lb_ml_thick_update)
        hbox_thick_update.addWidget(self.tx_ml_thick_update)
        hbox_thick_update.addWidget(lb_ml_loss_ssim)
        hbox_thick_update.addWidget(self.tx_ml_loss_ssim)
        hbox_thick_update.addWidget(lb_ml_loss_tv)
        hbox_thick_update.addWidget(self.tx_ml_loss_tv)
        hbox_thick_update.setAlignment(QtCore.Qt.AlignLeft)
        hbox_thick_update.addStretch()


        # reference for training
        self.chkbox_ml_ref = QCheckBox('Train use reference')
        self.chkbox_ml_ref.setFont(self.font2)
        self.chkbox_ml_ref.setFixedWidth(155)
        self.chkbox_ml_ref.setChecked(False)
        self.chkbox_ml_ref.stateChanged.connect(self.ml_check_fit_use_ref)

        self.pb_ml_open_ref = QPushButton('Load')
        self.pb_ml_open_ref.setFont(self.font2)
        self.pb_ml_open_ref.setFixedWidth(75)
        self.pb_ml_open_ref.setEnabled(False)
        self.pb_ml_open_ref.clicked.connect(self.ml_load_ref)

        self.pb_ml_reset_ref = QPushButton('Reset')
        self.pb_ml_reset_ref.setFont(self.font2)
        self.pb_ml_reset_ref.setFixedWidth(75)
        self.pb_ml_reset_ref.setEnabled(False)
        self.pb_ml_reset_ref.clicked.connect(self.ml_reset_ref)

        self.lb_ml_ref = QLabel()
        self.lb_ml_ref.setFont(self.font2)
        self.lb_ml_ref.setStyleSheet('color: rgb(200, 50, 50);')
        self.lb_ml_ref.setVisible(False)
        self.lb_ml_ref.setFixedWidth(200)
        self.lb_ml_ref.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)

        lb_empty_ref = QLabel()
        lb_empty_ref.setFixedWidth(20)

        hbox_ref_load_reset = QHBoxLayout()
        hbox_ref_load_reset.addWidget(self.pb_ml_open_ref)
        hbox_ref_load_reset.addWidget(self.pb_ml_reset_ref)
        hbox_ref_load_reset.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        hbox_ref_load_reset.addStretch()

        vbox_ref = QVBoxLayout()
        vbox_ref.addWidget(self.chkbox_ml_ref)
        vbox_ref.addLayout(hbox_ref_load_reset)
        vbox_ref.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        vbox_ref.addStretch()

        hbox_ref = QHBoxLayout()
        hbox_ref.addLayout(vbox_ref)
        hbox_ref.addWidget(lb_empty_ref)
        hbox_ref.addWidget(self.lb_ml_ref)
        hbox_ref.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        hbox_ref.addStretch()

        self.pb_ml_train_prod = QPushButton('Train')
        self.pb_ml_train_prod.setFont(self.font2)
        self.pb_ml_train_prod.setFixedWidth(155)
        self.pb_ml_train_prod.clicked.connect(self.ml_train_prod)

        # assemble param
        vbox_param = QVBoxLayout()
        vbox_param.addLayout(hbox_n_train)
        vbox_param.addLayout(hbox_learn)
        vbox_param.addLayout(hbox_thick_update)
        vbox_param.addLayout(hbox_ref)
        vbox_param.addWidget(self.pb_ml_train_prod)
        vbox_param.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        vbox_param.addStretch()

        # assemble all
        vbox_train_all = QVBoxLayout()
        vbox_train_all.addWidget(lb_ml_train)
        vbox_train_all.addLayout(vbox_dir)
        vbox_train_all.addLayout(vbox_param)
        vbox_train_all.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        vbox_train_all.addStretch()

        return vbox_train_all

    def layout_ml_msg(self):
        lb_ml_msg = QLabel()
        lb_ml_msg.setText('Massage: ')
        lb_ml_msg.setFont(self.font1)
        lb_ml_msg.setFixedWidth(90)
        lb_ml_msg.setStyleSheet('color: rgb(200, 50, 50);')

        self.lb_ml_msg = QLabel()
        self.lb_ml_msg.setText('')
        self.lb_ml_msg.setFont(self.font2)
        self.lb_ml_msg.setFixedWidth(900)

        hbox1 = QHBoxLayout()
        hbox1.addWidget(lb_ml_msg)
        hbox1.addWidget(self.lb_ml_msg)
        hbox1.setAlignment(QtCore.Qt.AlignLeft)
        hbox1.addStretch()
        return hbox1

    def layout_ml_denoise(self):
        lb_space = QLabel()
        lb_space.setFixedHeight(30)

        hbox_ml_msg = self.layout_ml_msg()
        hbox_model_path = self.layout_ml_denoise_load_model()
        hbox_img_path = self.layout_ml_denoise_load_img()
        hbox_eng_path = self.layout_ml_denoise_load_energy()
        hbox_crop = self.layout_ml_denoise_crop_img()
        hbox_func = self.layout_ml_denoise_function()
        self.ml_load_model_path(self.ml_model_path) # load default model

        vbox = QVBoxLayout()
        vbox.addLayout(hbox_model_path)
        vbox.addLayout(hbox_img_path)
        vbox.addLayout(hbox_eng_path)
        vbox.addLayout(hbox_crop)
        vbox.addLayout(hbox_ml_msg)
        vbox.addWidget(lb_space)
        vbox.addLayout(hbox_func)
        vbox.setAlignment(QtCore.Qt.AlignTop)
        return vbox


    def layout_canvas_ml(self):
        from matplotlib.backends.backend_qt5agg import NavigationToolbar2QT as NavigationToolbar
        lb_empty = QLabel()
        lb_empty2 = QLabel()
        lb_empty2.setFixedWidth(10)
        self.canvas_ml = MyCanvas(obj=self, width=5, height=5)
        self.toolbar = NavigationToolbar(self.canvas_ml, self)
        self.sl1_ml = QScrollBar(QtCore.Qt.Horizontal)
        self.sl1_ml.setMaximum(0)
        self.sl1_ml.setMinimum(0)
        self.sl1_ml.valueChanged.connect(lambda:self.sliderval(self.canvas_ml))

        self.cb1_ml = QComboBox()
        self.cb1_ml.setFont(self.font2)
        self.cb1_ml.addItem('Raw image')
        self.cb1_ml.setFixedWidth(307)
        self.cb1_ml.currentIndexChanged.connect(self.ml_update_canvas_img)

        self.pb_ml_save_img_stack = QPushButton('Save image stack')
        self.pb_ml_save_img_stack.setFont(self.font2)
        self.pb_ml_save_img_stack.clicked.connect(lambda:self.save_img_stack(self.canvas_ml))
        self.pb_ml_save_img_stack.setFixedWidth(150)

        self.pb_ml_move_img_stack = QPushButton('Move to 2D-XANES')
        self.pb_ml_move_img_stack.setFont(self.font2)
        self.pb_ml_move_img_stack.clicked.connect(lambda: self.move_canvas_img_stack(self.canvas_ml, self.canvas1))
        self.pb_ml_move_img_stack.setFixedWidth(150)

        hbox_can_l = QHBoxLayout()
        hbox_can_l.addWidget(self.cb1_ml)
        hbox_can_l.addWidget(self.pb_ml_save_img_stack)
        hbox_can_l.addWidget(self.pb_ml_move_img_stack)
        hbox_can_l.setAlignment(QtCore.Qt.AlignLeft)

        lb_cmap = QLabel()
        lb_cmap.setFont(self.font2)
        lb_cmap.setText('colormap: ')
        lb_cmap.setFixedWidth(80)

        cmap = ['gray', 'bone', 'viridis', 'terrain', 'gnuplot', 'bwr', 'plasma', 'PuBu', 'summer', 'rainbow', 'jet']
        self.cb_ml_cmap = QComboBox()
        self.cb_ml_cmap.setFont(self.font2)
        for i in cmap:
            self.cb_ml_cmap.addItem(i)
        self.cb_ml_cmap.setCurrentText('viridis')
        self.cb_ml_cmap.currentIndexChanged.connect(lambda:self.change_colormap(self.canvas_ml))
        self.cb_ml_cmap.setFixedWidth(80)

        self.pb_ml_adj_cmap = QPushButton('Auto Contrast')
        self.pb_ml_adj_cmap.setFont(self.font2)
        self.pb_ml_adj_cmap.clicked.connect(lambda:self.auto_contrast(self.canvas_ml))
        self.pb_ml_adj_cmap.setEnabled(True)
        self.pb_ml_adj_cmap.setFixedWidth(120)

        lb_cmax = QLabel()
        lb_cmax.setFont(self.font2)
        lb_cmax.setText('cmax: ')
        lb_cmax.setFixedWidth(40)
        lb_cmin = QLabel()
        lb_cmin.setFont(self.font2)
        lb_cmin.setText('cmin: ')
        lb_cmin.setFixedWidth(40)

        self.tx_ml_cmax = QLineEdit(self)
        self.tx_ml_cmax.setFont(self.font2)
        self.tx_ml_cmax.setFixedWidth(80)
        self.tx_ml_cmax.setText('1.')
        self.tx_ml_cmax.setValidator(QDoubleValidator())
        self.tx_ml_cmax.setEnabled(True)

        self.tx_ml_cmin = QLineEdit(self)
        self.tx_ml_cmin.setFont(self.font2)
        self.tx_ml_cmin.setFixedWidth(80)
        self.tx_ml_cmin.setText('0.')
        self.tx_ml_cmin.setValidator(QDoubleValidator())
        self.tx_ml_cmin.setEnabled(True)

        self.pb_ml_set_cmap = QPushButton('Set')
        self.pb_ml_set_cmap.setFont(self.font2)
        self.pb_ml_set_cmap.clicked.connect(lambda:self.set_contrast(self.canvas_ml))
        self.pb_ml_set_cmap.setEnabled(True)
        self.pb_ml_set_cmap.setFixedWidth(60)

        hbox_cmap = QHBoxLayout()
        hbox_cmap.addWidget(lb_cmap)
        hbox_cmap.addWidget(self.cb_ml_cmap)
        hbox_cmap.addWidget(self.pb_ml_adj_cmap)
        hbox_cmap.addWidget(lb_cmin)
        hbox_cmap.addWidget(self.tx_ml_cmin)
        hbox_cmap.addWidget(lb_cmax)
        hbox_cmap.addWidget(self.tx_ml_cmax)
        hbox_cmap.addWidget(self.pb_ml_set_cmap)
        hbox_cmap.setAlignment(QtCore.Qt.AlignLeft)

        vbox_can_ml = QVBoxLayout()
        vbox_can_ml.addWidget(self.toolbar)
        vbox_can_ml.addWidget(self.canvas_ml)
        vbox_can_ml.addWidget(self.sl1_ml)
        vbox_can_ml.addLayout(hbox_can_l)
        vbox_can_ml.addLayout(hbox_cmap)
        vbox_can_ml.setAlignment(QtCore.Qt.AlignLeft)
        return vbox_can_ml

    def update_ml_msg(self):
        self.lb_ml_msg.setFont(self.font1)
        self.lb_ml_msg.setText(self.ml_msg)
        self.lb_ml_msg.setStyleSheet('color: rgb(200, 50, 50);')


    def ml_clean_model_list(self):
        self.ml_model_dict = {}
        self.lst_ml_model.clear()

    def ml_load_model(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'pth files (*.pth)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            self.ml_load_model_path(fn)
            '''
            try:
                print(fn)
                self.ml_pre_defined_model = RRDBNet(1, 1, 16, 4, 32)
                self.ml_model_path = fn
                self.ml_add_model_to_list('Init model', fn)

            except Exception as err:
                print(err)
                self.ml_model_path = ''
            finally:
                self.tx_ml_model_path.setText(self.ml_model_path)
                QApplication.processEvents()
            '''
        else:
            self_ml_model_path = ''


    def ml_load_model_path(self, fn):
        try:
            print(fn)
            self.ml_pre_defined_model = RRDBNet(1, 1, 16, 4, 32)
            self.ml_model_path = fn
            self.ml_add_model_to_list('Init model', fn)
        except Exception as err:
            print(err)
            self.ml_model_path = ''
        finally:
            self.tx_ml_model_path.setText(self.ml_model_path)
            QApplication.processEvents()


    def ml_load_model_multiple(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = '*.pth'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        fn_tmp = fn.split('/')
        file_path = '/'.join(t for t in fn_tmp[:-1])
        if fn:
            try:
                self.ml_pre_defined_model = RRDBNet(1, 1, 16, 4, 32)
                fpath = np.sort(glob.glob(file_path+'/*.pth'))
                n = len(fpath)
                self.ml_clean_model_list()
                for i in range(n):
                    fn_model = fpath[i]
                    model_name = (fn_model.split('/')[-1]).split('.')[0]
                    self.ml_model_path = fn_model
                    self.ml_add_model_to_list(model_name, fn_model)
                self.ml_msg = f'{n} model loaded'
            except Exception as err:
                print(err)
                self.ml_msg = str(err)
            finally:
                self.update_ml_msg()


    def ml_load_model_default(self):
        try:
            print(f'load default model: {self.ml_model_path_default}')
            self.ml_pre_defined_model = RRDBNet(1, 1, 16, 4, 32)
            self.ml_model_path = self.ml_model_path_default
            self.ml_add_model_to_list('Init model', self.ml_model_path_default)
        except Exception as err:
            print(err)
            self.ml_model_path = ''
        finally:
            self.tx_ml_model_path.setText(self.ml_model_path)
            QApplication.processEvents()

    def ml_load_img(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'tiff files (*.tiff)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                self.ml_img_path = fn
                img_stack = io.imread(self.ml_img_path)
                if len(img_stack.shape) == 2:
                    img_stack = np.expand_dims(img_stack, axis=0)
                self.ml_img_stack = img_stack.copy()
                del img_stack
                n_img = len(self.ml_img_stack)
                self.lb_ml_msg_img.setText(f'Total: {n_img} slices')
                self.cb1_ml.setCurrentText('Raw image')
                self.ml_update_canvas_img()
            except Exception as err:
                print(err)
                self.ml_img_path = ''
                self.tx_ml_msg_img.setText('')
            finally:
                self.tx_ml_img_path.setText(self.ml_img_path)
                self.tx_ml_raw_img.setText(self.ml_img_path)
                QApplication.processEvents()



    def ml_load_energy(self):
        self.ml_eng = []
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                self.ml_eng_path = fn
                self.ml_eng = np.loadtxt(self.ml_eng_path)
                n_eng = len(self.ml_eng)
                msg = f'{n_eng} energies: [{self.ml_eng[0]:2.4f}...{self.ml_eng[1]:2.4f}]'
            except Exception as err:
                print(err)
                self.ml_eng_path = ''
                msg = ''
            finally:
                self.tx_ml_eng_path.setText(self.ml_eng_path)
                self.lb_ml_msg_eng.setText(msg)
                QApplication.processEvents()


    def ml_load_mask(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'Tiff files (*.tiff)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                self.tx_ml_fn_mask.setText(fn)

            except Exception as err:
                print(err)
                self.tx_ml_fn_mask.setText('')
        else:
            self.tx_ml_fn_mask.setText('')

    def ml_crop_roi(self, current_canvas):
        x_s, x_e, y_s, y_e = self.get_crop_roi(current_canvas)
        image = current_canvas.img_stack
        try:
            self.ml_img_update = image[:, y_s:y_e, x_s:x_e]
            if self.cb1_ml.findText('Image updated') < 0:
                self.cb1_ml.addItem('Image updated')
            self.cb1_ml.setCurrentText('Image updated')
            self.ml_update_canvas_img()
        except Exception as err:
            print(err)


    def ml_select_model_from_list(self):
        device = self.cb_ml_device.currentText()
        item = self.lst_ml_model.selectedItems()
        model_exist = 0
        if len(item):
            model_prod = self.ml_pre_defined_model.to(device)
            model_name = item[0].text()
            self.ml_model_path = self.ml_model_dict[model_name]
            model_path = self.ml_model_path
            model_prod.load_state_dict(torch.load(model_path, map_location=torch.device(device)))
            model_exist = 1
        else:
            model_exist = 0
            model_prod = None
        return model_exist, model_prod, device, model_name

    def ml_apply_img(self):
        try:
            self.pb_ml_apply.setEnabled(False)
            self.pb_ml_apply.setText('Calculating...')
            self.pb_ml_apply.setEnabled(False)
            self.ml_msg = 'Applying selected model to image stack. Wait ...'
            self.update_ml_msg()
            QApplication.processEvents()

            f_norm = float(self.tx_ml_norm_factor.text())
            img_raw = self.canvas_ml.img_stack.copy()
            img_raw = img_raw / f_norm
            s = img_raw.shape
            img_rescale = pyxas.crop_scale_image(img_raw, output_size=(256, 256))
            model_exist, model_prod, device, model_name = self.ml_select_model_from_list()
            n_iter = int(self.tx_ml_iter.text())
            filt_sz = int(self.tx_ml_filter_sz.text())
            if model_exist:
                img_output_scale, img_bkg_scale = apply_model_to_stack(img_rescale, model_prod, device, n_iter, gaussian_filter=filt_sz)
                #img_output = pyxas.crop_scale_image(img_output_scale, (s[1], s[2]))
                img_bkg = pyxas.crop_scale_image(img_bkg_scale, (s[1], s[2]))
                img_output = img_raw / img_bkg
                self.ml_output_img = img_output.copy()
                self.ml_output_bkg = img_bkg.copy()
                if self.cb1_ml.findText('ML output image') < 0:
                    self.cb1_ml.addItem('ML output image')
                if self.cb1_ml.findText('ML output bkg') < 0:
                    self.cb1_ml.addItem('ML output bkg')
                if not self.cb1_ml.currentText() == 'ML output image':
                    self.cb1_ml.setCurrentText('ML output image')
                self.ml_update_canvas_img()
                self.ml_msg = 'Finished'
            else:
                self.ml_msg = 'model not exist'
                print('model not exist')
        except Exception as err:
            self.ml_msg = str(err)
            print(err)
        finally:
            self.pb_ml_apply.setEnabled(True)
            self.pb_ml_apply.setText('Apply to stack')
            self.update_ml_msg()


    def ml_apply_img_single(self):
        try:
            model_exist, model_prod, device, model_name = self.ml_select_model_from_list()
            f_norm = float(self.tx_ml_norm_factor.text())
            img_raw = self.canvas_ml.current_img.copy()
            img_raw = img_raw / f_norm
            s = img_raw.shape
            img_rescale = pyxas.crop_scale_image(img_raw, output_size=(256, 256))
            img_rescale = np.expand_dims(img_rescale, axis=0) # (1, 256, 256)
            device = self.cb_ml_device.currentText()
            n_iter = int(self.tx_ml_iter.text())
            filt_sz = int(self.tx_ml_filter_sz.text())
            cmin = float(self.tx_ml_cmin.text())
            cmax = float(self.tx_ml_cmax.text())
            cmap = self.cb_ml_cmap.currentText()

            if model_exist:
                #img_output_scale = check_image_fitting(model_prod, img_rescale, device, plot_flag=0, clim=[0, 1], title=model_name)
                img_output_scale, img_bkg_scale = apply_model_to_stack(img_rescale, model_prod, device, n_iter, gaussian_filter=filt_sz)
                img_bkg = pyxas.crop_scale_image(img_bkg_scale[0], (s[0], s[1]))
                img_output = img_raw / img_bkg

                clim = [cmin, cmax]
                plt.figure(figsize=(20, 5))
                plt.subplot(131)
                plt.imshow(np.squeeze(img_raw), clim=clim, cmap=cmap)
                plt.colorbar()
                plt.title('raw image')
                plt.subplot(133)
                plt.imshow(np.squeeze(img_output), clim=clim, cmap=cmap)
                plt.colorbar()
                plt.show()
                plt.title('ML output Img.')
                plt.subplot(132)
                plt.imshow(np.squeeze(img_bkg), clim=clim, cmap=cmap)
                plt.colorbar()
                plt.title('ML output Bkg.')
            else:
                print('model not exist')
        except Exception as err:
            print(err)
            self.ml_msg = str(err)
            self.update_ml_msg()

    def ml_add_model_to_list(self, model_name, model_path):
        exist_model_name = list(self.ml_model_dict.keys())
        self.ml_model_dict[model_name] = model_path
        item = QListWidgetItem(model_name)
        model_exist = False
        for k in exist_model_name:
            if model_name == k:
                model_exist = True
        if not model_exist:
            self.lst_ml_model.addItem(item)
        self.lst_ml_model.setCurrentItem(item)


    def ml_clear_model(self):
        self.lst_ml_model.clear()
        self.ml_model_dict = {}
        for selectItem in self.lst_ml_model.selectedItems():
            self.lst_ml_model.removeItemWidget(selectItem)


    def _ml_get_eng_exclude(self):
        try:
            tx = self.tx_ml_edge.text()
            tx = tx.replace('[', '')
            tx = tx.replace(']', '')
            tx = tx.split(',')
            eng_exclude = [float(k.strip()) for k in tx]
        except:
            eng_exclude = []
        return eng_exclude


    def ml_prep_prod_dataset(self):
        try:
            self.pb_ml_prep.setEnabled(False)
            self.ml_msg = 'Generating training data ...'
            self.update_ml_msg()
            QApplication.processEvents()
            fn_img_xanes = self.ml_img_path
            if not len(fn_img_xanes):
                fn_img_xanes = '/tmp/tmp_image.tiff'
            elem = self.tx_ml_elem.text()
            eng = self.ml_eng
            num_img = np.int16(self.tx_ml_num.text())
            f_norm = float(self.tx_ml_norm_factor.text())
            eng_exclude = self._ml_get_eng_exclude()
            n_stack = int(self.tx_ml_stack_sz.text())
            prepare_production_training_dataset(fn_img_xanes, elem, eng, eng_exclude, num_img, f_norm, n_stack)

            #root_dir = self.ml_img_path.split('/')
            #self.ml_train_root_dir = '/'.join(k for k in root_dir[:-1]) + '/train_production'
            self.ml_train_root_dir = fn_img_xanes.split('.')[0] + '_train_production'
            self.ml_train_gt_dir = 'img_gt_stack'
            self.ml_train_blur_dir = 'img_blur_stack'
            self.ml_train_eng_dir = 'img_eng_list'
            self.ml_update_train_dir()
            self.ml_msg = f'Trainning data generated in "{self.ml_train_root_dir}"'
        except Exception as err:
            self.ml_msg = str(err)
            print(err)
        finally:
            self.pb_ml_prep.setEnabled(True)
            self.update_ml_msg()


    def ml_gen_elem(self, elem):
        try:
            self.tx_ml_elem.setText(elem)
            edge = xraylib.EdgeEnergy(xraylib.SymbolToAtomicNumber(elem), xraylib.K_SHELL)
            eng_edge = np.round([edge - 0.02, edge + 0.08], 2)
            self.tx_ml_edge.setText(f'[{eng_edge[0]}, {eng_edge[1]}]')
        except Exception as err:
            print(err)
            self.ml_msg = str(err)
            self.update_ml_msg()

    def ml_update_train_dir(self):
        self.tx_ml_fn_root.setText(self.ml_train_root_dir)
        self.tx_ml_fn_gt.setText(self.ml_train_gt_dir)
        self.tx_ml_fn_blur.setText(self.ml_train_blur_dir)
        self.tx_ml_fn_englist.setText(self.ml_train_eng_dir)


    def ml_open_directory(self, mode):
        dir_name = QFileDialog.getExistingDirectory(self, "Select a Directory")
        if dir_name:
            dir_short = dir_name.split('/')[-1]
            if mode == 'root':
                self.ml_train_root_dir = dir_name
                dir_exist = np.sort(glob.glob(dir_name + '/*'))
                n = len(dir_exist)
                for i in range(n):
                    if 'img_gt_stack' in dir_exist[i]:
                        self.ml_train_gt_dir = dir_exist[i].split('/')[-1]
                    if 'img_blur_stack' in dir_exist[i]:
                        self.ml_train_blur_dir = dir_exist[i].split('/')[-1]
                    if 'img_eng_list' in dir_exist[i]:
                        self.ml_train_eng_dir = dir_exist[i].split('/')[-1]
            if mode == 'gt':
                self.ml_train_gt_dir = dir_short
            if mode == 'blur':
                self.ml_train_blur_dir = dir_short
            if mode == 'eng':
                self.ml_train_eng_dir = dir_short
            self.ml_update_train_dir()


    def ml_check_train_dir_exist(self):
        fn_root = self.tx_ml_fn_root.text()
        fn_gt = self.tx_ml_fn_gt.text()
        fn_blur = self.tx_ml_fn_blur.text()
        fn_eng = self.tx_ml_fn_englist.text()
        flag_exist = 1
        if not os.path.exists(fn_root):
            flag_exist = 0
        if not os.path.exists(fn_root + '/' + fn_gt):
            flag_exist = 0
        if not os.path.exists(fn_root + '/' + fn_blur):
            flag_exist = 0
        if not os.path.exists(fn_root + '/' + fn_eng):
            flag_exist = 0
        if flag_exist:
            self.ml_train_root_dir = fn_root
            self.ml_train_gt_dir = fn_gt
            self.ml_train_blur_dir = fn_blur
            self.ml_train_eng_dir = fn_eng
        return flag_exist


    def ml_check_fit_use_ref(self):
        if self.chkbox_ml_ref.isChecked():
            self.pb_ml_open_ref.setEnabled(True)
            self.pb_ml_reset_ref.setEnabled(True)
            self.lb_ml_ref.setVisible(True)
            self.tx_ml_ratio.setEnabled(False)
            self.lb_ml_thick_update.setText('Fit update rate')
        else:
            self.pb_ml_open_ref.setEnabled(False)
            self.pb_ml_reset_ref.setEnabled(False)
            self.lb_ml_ref.setVisible(False)
            self.tx_ml_ratio.setEnabled(True)
            self.lb_ml_thick_update.setText('Thick update rate')


    def ml_load_ref(self):
        options = QFileDialog.Option()
        options |= QFileDialog.DontUseNativeDialog
        file_type = 'txt files (*.txt)'
        fn, _ = QFileDialog.getOpenFileName(xanes, "QFileDialog.getOpenFileName()", "", file_type, options=options)
        if fn:
            try:
                print(fn)
                fn_ref = fn.split('/')[-1]
                print(f'selected reference: {fn_ref}')
                self.lb_ml_ref.setText(self.lb_ml_ref.text() + '\n' + f'ref #{self.ml_num_ref}: ' + fn_ref)
                self.lb_ml_ref.setStyleSheet('color: rgb(200, 50, 50);')
                QApplication.processEvents()

                ref = np.loadtxt(fn)
                ref = pyxas.rm_duplicate(ref)
                self.ml_spectrum_ref[f'ref{self.num_ref}'] = ref
                self.ml_num_ref += 1
            except Exception as err:
                self.ml_msg = str(err)
                self.update_ml_msg()
                print(f'un-supported xanes reference format. Error: {str(err)}')


    def ml_reset_ref(self):
        self.ml_num_ref = 0
        self.lb_ml_ref.setText('')
        self.ml_spectrum_ref = {}


    def ml_train_prod(self):
        try:
            self.pb_ml_train_prod.setText('Training ...')
            self.pb_ml_train_prod.setEnabled(False)
            QApplication.processEvents()
            dir_exist = self.ml_check_train_dir_exist()
            model_exist, model_prod, device, model_name = self.ml_select_model_from_list()
            n_train = int(self.tx_ml_n_train.text())
            n_epoch = int(self.tx_ml_n_epoch.text())
            ratio = float(self.tx_ml_ratio.text())
            elem = self.tx_ml_elem.text()
            lr = float(self.tx_ml_learn_r.text())
            spectrum_ref = self.ml_spectrum_ref
            thickness_update_rate = int(self.tx_ml_thick_update.text())
            x_eng = self.ml_eng

            thickness_elem = None
            save_flag = True
            fn_img_raw = self.tx_ml_raw_img.text()
            #loss_mse = float(self.tx_ml_loss_mse.text())
            loss_tv = float(self.tx_ml_loss_tv.text())
            loss_ssim = float(self.tx_ml_loss_ssim.text())
            loss_r = {}
            loss_r['mse_fit_img'] = 1
            loss_r['tv_bkg'] = loss_tv
            loss_r['ssim_img'] = loss_ssim

            try:
                fn_mask = self.tx_ml_fn_mask.text()
                mask = io.imread(fn_mask)
            except:
                mask = 1

            self.ml_msg = 'train network now, check terminal for updates ...'
            if not dir_exist:
                self.ml_msg = 'train folder not exist'
            if not model_exist:
                self.ml_msg = 'neural network model not exist, check "Model path" on the top'
            if not len(x_eng):
                self.ml_msg = 'X_Eng not exist, check "X_Eng path" on the top'
            if not len(elem):
                self.ml_msg = 'Need to assign the "Elem", e.g., Ni'
            self.update_ml_msg()
            QApplication.processEvents()
            if dir_exist and model_exist and len(x_eng) and len(elem):
                img_raw = io.imread(fn_img_raw)
                f_norm = float(self.tx_ml_norm_factor.text())
                fn_root = self.ml_train_root_dir
                gt_dir = self.ml_train_gt_dir
                blur_dir = self.ml_train_blur_dir
                eng_dir =self.ml_train_eng_dir
                if self.chkbox_ml_ref.isChecked(): # use reference to fit
                    '''
                    main_train_xanes_bkg_production_with_reference(fn_root, img_raw, x_eng, model_prod, spectrum_ref,
                                                                   loss_r, f_norm, blur_dir, gt_dir, eng_dir, lr, ratio,
                                                                   mask, n_train, n_epoch, device, save_flag)
                    '''
                    self.ml_h_loss = main_train_production_with_fitted_param(fn_root, img_raw, x_eng, model_prod,
                                                        spectrum_ref, loss_r, f_norm, blur_dir, gt_dir, eng_dir, lr,
                                                    thickness_update_rate, mask, n_train, n_epoch, device, save_flag)
                else:
                    self.ml_h_loss = main_train_xanes_bkg_production(fn_root, img_raw, x_eng, elem, model_prod, loss_r, f_norm,
                                                    gt_dir, blur_dir, eng_dir, thickness_elem, ratio, lr,
                                                    thickness_update_rate, mask, n_train, n_epoch, device, save_flag)
                self.ml_update_model_list_and_show_img(fn_root)
                QApplication.processEvents()
                self.ml_msg = 'training finished.'
                torch.cuda.empty_cache()
                gc.collect()
        except Exception as err:
            print(err)
            self.ml_msg = str(err)
        finally:
            torch.cuda.empty_cache()
            gc.collect()
            self.update_ml_msg()
            self.pb_ml_train_prod.setText('Train')
            self.pb_ml_train_prod.setEnabled(True)


    def ml_update_model_list_and_show_img(self, fn_root):
        fpath_model = fn_root + '/model_saved'
        fpath_img = fn_root + '/model_output'
        f_model = np.sort(glob.glob(fpath_model + '/*.pth'))
        n = len(f_model)
        #self.lst_ml_model.clear()
        self.ml_clear_model()
        fn_model_init = self.tx_ml_model_path.text()
        self.ml_add_model_to_list('Init model', fn_model_init)
        for i in range(n):
            model_name = f_model[i].split('/')[-1]
            model_name = model_name.split('.')[0]
            model_path = f_model[i]
            self.ml_add_model_to_list(model_name, model_path)
        QApplication.processEvents()

        n_iter = int(self.tx_ml_iter.text())
        filt_sz = int(self.tx_ml_filter_sz.text())
        model_exist, model_prod, device, model_name = self.ml_select_model_from_list()
        img_raw = self.ml_img_stack
        if model_exist:
            img_output, img_bkg = apply_model_to_stack(img_raw, model_prod, device, n_iter, gaussian_filter=filt_sz)
            self.ml_output_img = img_output.copy()
            self.ml_output_bkg = img_bkg.copy()
            if self.cb1_ml.findText('ML output image') < 0:
                self.cb1_ml.addItem('ML output image')
            if self.cb1_ml.findText('ML output bkg') < 0:
                self.cb1_ml.addItem('ML output bkg')
            if not self.cb1_ml.currentText() == 'ML output image':
                self.cb1_ml.setCurrentText('ML output image')

            if not self.ml_h_loss is None:
                if self.cb1_ml.findText('ML train loss') < 0:
                    self.cb1_ml.addItem('ML train loss')

            self.ml_update_canvas_img()

    def ml_extract_model_img(self, mode):
        item = self.lst_ml_model.selectedItems()
        if len(item):
            model_name = item[0].text()
            if model_name == 'Init model':
                if mode == 'output_bkg':
                    img = self.ml_output_bkg
                else:
                    img = self.ml_output_img
                return img
            else:
                model_path = self.ml_model_dict[model_name]
                fn_root = model_path.split('/')
                fn_root = '/'.join(k for k in fn_root[:-2])
                fpath_img = fn_root + '/model_output'
                f_img = np.sort(glob.glob(fpath_img + '/output*'))
                f_bkg = np.sort(glob.glob(fpath_img + '/bkg*'))

                idx = (model_name.split('.')[0]).split('_')[-1]
                idx = int(idx)

                if mode == 'output_bkg':
                    img = io.imread(f_bkg[idx])
                elif mode == 'output_img':
                    img = io.imread(f_img[idx])
                return img
        else:
            return None

    def move_canvas_img_stack(self, from_canvas, to_canvas):
        self.img_external = from_canvas.img_stack.copy()
        if to_canvas == self.canvas1:
            if self.cb1.findText('Moved from external') < 0:
                self.cb1.addItem('Moved from external')
            self.cb1.setCurrentText('Moved from external')
            self.update_canvas_img()
        elif to_canvas == self.canvas_ml:
            if self.cb1_ml.findText('Moved from external') < 0:
                self.cb1_ml.addItem('Moved from external')
            self.cb1_ml.setCurrentText('Moved from external')
            self.ml_update_canvas_img()
        QApplication.processEvents()



    def ml_update_canvas_img(self):
        canvas = self.canvas_ml
        slide = self.sl1_ml
        type_index = self.cb1_ml.currentText()
        QApplication.processEvents()
        canvas.draw_line = False
        self.pb_ml_adj_cmap.setEnabled(True)
        self.pb_ml_set_cmap.setEnabled(True)
        try:
            if type_index == 'Raw image':
                canvas.rgb_flag = 0
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = self.ml_img_stack.shape
                canvas.img_stack = self.smooth(self.ml_img_stack)
                canvas.special_info = None
                canvas.current_img_index = self.sl1_ml.value()
                canvas.title = [f'#{i:3d},   {self.ml_eng[i]:2.4f} keV' for i in range(len(self.ml_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = self.ml_img_stack[0]

            elif type_index == 'Image updated':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.ml_img_update
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = img.copy()
                canvas.special_info = None
                canvas.current_img_index = self.sl1_ml.value()
                canvas.title = [f'#{i:3d},   {self.ml_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]

            elif type_index == 'Moved from external':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                img = self.img_external
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = img.copy()
                canvas.special_info = None
                canvas.current_img_index = self.sl1_ml.value()
                #canvas.title = [f'#{i:3d},   {self.ml_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]

            elif type_index == 'ML output image':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                #img = self.ml_extract_model_img('output_img')
                img = self.ml_output_img
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = img.copy()
                canvas.special_info = None
                canvas.current_img_index = self.sl1_ml.value()
                canvas.title = [f'#{i:3d},   {self.ml_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]

            elif type_index == 'ML output bkg':
                self.img_colormix_raw = np.array([])
                canvas.rgb_flag = 0
                #img = self.ml_extract_model_img('output_bkg')
                img = self.ml_output_bkg
                self.pb_roi_draw.setEnabled(True)
                canvas.x, canvas.y = [], []
                canvas.axes.clear()  # this is important, to clear the current image before another imshow()
                sh = img.shape
                canvas.img_stack = img.copy()
                canvas.special_info = None
                canvas.current_img_index = self.sl1_ml.value()
                canvas.title = [f'#{i:3d},   {self.ml_eng[i]:2.4f} keV' for i in range(len(self.xanes_eng))]
                canvas.update_img_stack()
                slide.setMaximum(max(sh[0] - 1, 0))
                self.current_image = img[0]

            elif type_index == 'ML train loss':
                try:
                    plot_h_loss(self.ml_h_loss)
                    QApplication.processEvents()
                except Exception as err:
                    print(err)

        except Exception as err:
            print(err)

def adv(mode=1):
    xanes.refresh(mode)



###################
class MyCanvas(FigureCanvas):
    def __init__(self, parent=None, width=5, height=3, dpi=120, obj=[]):
        self.obj = obj
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = self.fig.add_subplot(111)
        self.axes.axis('off')
        self.cmax = 1
        self.cmin = 0
        self.rgb_flag = 0
        self.img_stack = np.zeros([1, 100, 100])
        self.current_img = self.img_stack[0]
        self.current_img_index = 0
        self.mask = np.array([1])
        self.rgb_mask = np.array([1])
        self.colorbar_on_flag = True
        self.colormap = 'viridis'
        self.title = []
        self.draw_line = False
        self.overlay_flag = True
        self.x, self.y, = [], []
        self.plot_label = ''
        self.legend_flag = False
        self.roi_list = {}
        self.roi_color = {}
        self.roi_count = 0
        self.show_roi_flag = False
        self.current_roi = [0, 0, 0, 0, '0'] # x1, y1, x2, y1, roi_name
        self.color_list = ['red', 'green', 'blue', 'cyan', 'pink', 'yellow', 'orange', 'olive', 'purple', 'gray']
        self.current_color = 'red'
        self.special_info = None
        FigureCanvas.__init__(self, self.fig)
        FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
        FigureCanvas.updateGeometry(self)
        self.setParent(parent)
        self.mpl_connect('motion_notify_event', self.mouse_moved)

    def mouse_moved(self, mouse_event):
        if mouse_event.inaxes:
            x, y = mouse_event.xdata, mouse_event.ydata
            self.obj.lb_x_l.setText('x: {:3.2f}'.format(x))
            self.obj.lb_y_l.setText('y: {:3.2f}'.format(y))
            row = int(np.max([np.min([self.current_img.shape[0], y]), 0]))
            col = int(np.max([np.min([self.current_img.shape[1], x]), 0]))
            try:
                z = self.current_img[row][col]
                self.obj.lb_z_l.setText('intensity: {:3.4f}'.format(z))
            except Exception as err:
                print(err)
                self.obj.lb_z_l.setText('')

    def update_img_stack(self):
        #self.axes = self.fig.add_subplot(111)
        if self.rgb_flag:  # RGB image
            return self.update_img_one(self.img_stack)
        elif self.img_stack.shape[0] == 0:
            img_blank = np.zeros([100, 100])
            return self.update_img_one(img_blank, img_index=0)
        else:
            s = self.img_stack.shape
            if len(s) == 2:
                self.img_stack = self.img_stack.reshape(1, s[0], s[1])
            if self.current_img_index >= len(self.img_stack):
                self.current_img_index = 0
            return self.update_img_one(self.img_stack[self.current_img_index], img_index=self.current_img_index)

    def update_img_one(self, img=np.array([]), img_index=0):
        self.axes.clear()
        try:
            if self.rgb_flag:
                self.rgb_mask = self.mask
                if len(self.mask.shape) == 3:
                    self.rgb_mask = self.mask[0]
                for i in range(img.shape[2]):
                    img[:,:,i] *= self.rgb_mask
                self.im = self.axes.imshow(img)
                self.draw()
            else:
                if len(img) == []: img = self.current_img
                self.current_img = img
                self.current_img_index = img_index
                self.im = self.axes.imshow(img*self.mask, cmap=self.colormap, vmin=self.cmin, vmax=self.cmax)
                self.axes.axis('on')
                self.axes.set_aspect('equal', 'box')
                if len(self.title) == self.img_stack.shape[0]:
                    self.axes.set_title('current image: ' + self.title[img_index])
                else:
                    self.axes.set_title('current image: ' + str(img_index))
                self.axes.title.set_fontsize(10)

                if self.colorbar_on_flag:
                    self.add_colorbar()
                    self.colorbar_on_flag = False
                self.draw()
            if self.show_roi_flag:
                for i in range(len(self.roi_list)):
                    self.current_color = self.color_list[i % 10]
                    try:
                        self.roi_display(self.roi_list[f'roi_{i}'])
                    except:
                        pass
        except Exception as err:
            print(f'Error in updating image. Error: {str(err)}')

    def add_line(self):
        if self.draw_line:
            if self.overlay_flag:
                self.axes.plot(self.x, self.y, '-', color=self.current_color, linewidth=1.0, label=self.plot_label)
            else:
                self.rm_colorbar()
                line, = self.axes.plot(self.x, self.y, '.-', color=self.current_color, linewidth=1.0, label=self.plot_label)
                if self.legend_flag:
                    self.axes.legend(handles=[line])
                self.axes.axis('on')
                self.axes.set_aspect('auto')
                self.draw()

    def draw_roi(self):
        self.cidpress = self.mpl_connect('button_press_event', self.on_press)
        self.cidrelease = self.mpl_connect('button_release_event', self.on_release)
        self.show_roi_flag = True

    def on_press(self, event):
        x1, y1 = event.xdata, event.ydata
        self.current_roi[0] = x1
        self.current_roi[1] = y1

    def on_release(self, event):
        x2, y2 = event.xdata, event.ydata
        self.current_roi[2] = x2
        self.current_roi[3] = y2
        self.current_roi[4] = str(self.roi_count)
        self.roi_add_to_list()
        self.roi_display(self.current_roi)
        self.roi_disconnect()

    def roi_disconnect(self):
        self.mpl_disconnect(self.cidpress)
        self.mpl_disconnect(self.cidrelease)

    def roi_display(self, selected_roi):
        x1, y1 = selected_roi[0], selected_roi[1]
        x2, y2 = selected_roi[2], selected_roi[3]
        roi_index = selected_roi[4]
        self.x = [x1, x2, x2, x1, x1]
        self.y = [y1, y1, y2, y2, y1]
        self.draw_line = True
        self.add_line()
        self.draw_line = False
        roi_name = f'#{roi_index}'
        s = self.current_img.shape
        self.axes.annotate(roi_name, xy=(x1, y1 - s[0] // 40),
                           bbox={'facecolor': self.current_color, 'alpha': 0.5, 'pad': 2},
                           fontsize=10)
        self.draw()
        # self.roi_count += 1
        '''
        self.obj.tx_roi_x1.setText('{:4.1f}'.format(x1))
        self.obj.tx_roi_y1.setText('{:4.1f}'.format(y1))
        self.obj.tx_roi_x2.setText('{:4.1f}'.format(x2))
        self.obj.tx_roi_y2.setText('{:4.1f}'.format(y2))
        '''
        self.obj.pb_roi_draw.setEnabled(True)
        QApplication.processEvents()

    def roi_add_to_list(self, roi_name=''):
        if not len(roi_name):
            roi_name = 'roi_' + str(self.roi_count)
        self.roi_list[roi_name] = deepcopy(self.current_roi)
        self.current_color = self.color_list[self.roi_count % 10]
        self.roi_color[roi_name] = self.current_color
        self.roi_count += 1
        self.obj.update_roi_list(mode='add', item_name=roi_name)

    def set_contrast(self, cmin, cmax):
        self.cmax = cmax
        self.cmin = cmin
        self.colorbar_on_flag = True
        if self.rgb_flag:
            #img = (self.img_stack - cmin) / (cmax - cmin)
            img = self.img_stack.copy()
            mask = deepcopy(self.mask)
            if len(mask.shape) == 2:
                mask = np.expand_dims(mask,axis=2)
                mask = np.repeat(mask, repeats=3, axis=2)
            self.update_img_one(img[:,:,:3] * mask)
        else:
            self.update_img_one(self.current_img*self.mask, self.current_img_index)

    def auto_contrast(self):
        try:
            img = self.current_img*self.mask
        except:
            print('image and mask has different shape, will not apply mask')
            img = self.current_img.copy()
        self.cmax = np.max(img)
        self.cmin = np.min(img)
        self.colorbar_on_flag = True
        self.update_img_one(self.current_img*self.mask, self.current_img_index)
        return self.cmin, self.cmax

    def rm_colorbar(self):
        try:
            self.cb.remove()
            self.draw()
        except Exception as err:
            print(err)

    def add_colorbar(self):
        if self.colorbar_on_flag:
            try:
                self.cb.remove()
                self.draw()
            except Exception as err:
                print(err)
            self.divider = make_axes_locatable(self.axes)
            self.cax = self.divider.append_axes('right', size='3%', pad=0.06)
            self.cb = self.fig.colorbar(self.im, cax=self.cax, orientation='vertical')
            self.cb.ax.tick_params(labelsize=10)
            self.draw()



if __name__ == '__main__':

    warnings.filterwarnings("ignore")
    app = QApplication(sys.argv)
    xanes = App()
    xanes.show()


    sys.exit(app.exec_())
